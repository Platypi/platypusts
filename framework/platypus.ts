/* tslint:disable */
/**
 * PlatypusTS v0.9.0 (http://getplatypi.com) 
 * Copyright 2014 Platypi, LLC. All rights reserved. 
 * 
 * PlatypusTS is licensed under the GPL-3.0 found at  
 * http://opensource.org/licenses/GPL-3.0 
 * 
 */
    /**
     * @name plat
     * @kind namespace
     * @access public
     * 
     * @description
     * The entry point into the platypus library.
     */
module plat {
    /* tslint:disable:no-unused-variable */
    /*
     * Injectables
     */
    var __AppStatic = '$AppStatic',
        __App = '$App',
        __Http = '$Http',
        __HttpConfig = '$HttpConfig',
        __Promise = '$Promise',
        __Compat = '$Compat',
        __ControlFactory = '$ControlFactory',
        __AttributeControlFactory = '$AttributeControlFactory',
        __Document = '$Document',
        __DispatchEventInstance = '$DispatchEventInstance',
        __ErrorEventStatic = '$ErrorEventStatic',
        __EventManagerStatic = '$EventManagerStatic',
        __LifecycleEventStatic = '$LifecycleEventStatic',
        __NavigationEventStatic = '$NavigationEventStatic',
        __ExceptionStatic = '$ExceptionStatic',
        __Parser = '$Parser',
        __Regex = '$Regex',
        __Tokenizer = '$Tokenizer',
        __NavigatorInstance = '$NavigatorInstance',
        __RoutingNavigator = '$RoutingNavigator',
        __ContextManagerStatic = '$ContextManagerStatic',
        __Compiler = '$Compiler',
        __CommentManagerFactory = '$CommentManagerFactory',
        __ElementManagerFactory = '$ElementManagerFactory',
        __NodeManagerStatic = '$NodeManagerStatic',
        __TextManagerFactory = '$TextManagerFactory',
        __CacheFactory = '$CacheFactory',
        __ManagerCache = '$ManagerCache',
        __TemplateCache = '$TemplateCache',
        __Animator = '$Animator',
        __AttributesInstance = '$AttributesInstance',
        __BindableTemplatesFactory = '$BindableTemplatesFactory',
        __Dom = '$Dom',
        __DomEvents = '$DomEvents',
        __DomEventsConfig = '$DomEventsConfig',
        __DomEventInstance = '$DomEventInstance',
        __ResourcesFactory = '$ResourcesFactory',
        __TemplateControlFactory = '$TemplateControlFactory',
        __BaseViewControlFactory = '$BaseViewControlFactory',
        __Utils = '$Utils',
        __Browser = '$Browser',
        __BrowserConfig = '$BrowserConfig',
        __Router = '$Router',
        __UrlUtilsInstance = '$UrlUtilsInstance',
        __Window = '$Window',
        __LocalStorage = '$LocalStorage',
        __SessionStorage = '$SessionStorage',
        __Geolocation = '$Geolocation',
    
        /**
         * Controls
         */
        __Plat = 'plat-',
        __Bind = __Plat + 'bind',
        __Href = __Plat + 'href',
        __Src = __Plat + 'src',
        __KeyDown = __Plat + 'keydown',
        __KeyPress = __Plat + 'keypress',
        __KeyUp = __Plat + 'keyup',
        __Name = __Plat + 'name',
        __Options = __Plat + 'options',
        __Checked = __Plat + 'checked',
        __Disabled = __Plat + 'disabled',
        __Selected = __Plat + 'selected',
        __ReadOnly = __Plat + 'readonly',
        __Visible = __Plat + 'visible',
        __Style = __Plat + 'style',
        __Tap = __Plat + 'tap',
        __Blur = __Plat + 'blur',
        __Change = __Plat + 'change',
        __Copy = __Plat + 'copy',
        __Cut = __Plat + 'cut',
        __Paste = __Plat + 'paste',
        __DblTap = __Plat + 'dbltap',
        __Focus = __Plat + 'focus',
        __Submit = __Plat + 'submit',
        __TouchStart = __Plat + 'touchstart',
        __TouchEnd = __Plat + 'touchend',
        __TouchMove = __Plat + 'touchmove',
        __TouchCancel = __Plat + 'touchcancel',
        __Hold = __Plat + 'hold',
        __Release = __Plat + 'release',
        __Swipe = __Plat + 'swipe',
        __SwipeLeft = __Plat + 'swipeleft',
        __SwipeRight = __Plat + 'swiperight',
        __SwipeUp = __Plat + 'swipeup',
        __SwipeDown = __Plat + 'swipedown',
        __Track = __Plat + 'track',
        __TrackLeft = __Plat + 'trackleft',
        __TrackRight = __Plat + 'trackright',
        __TrackUp = __Plat + 'trackup',
        __TrackDown = __Plat + 'trackdown',
        __TrackEnd = __Plat + 'trackend',
        __Anchor = 'a',
        __ForEach = __Plat + 'foreach',
        __Html = __Plat + 'html',
        __If = __Plat + 'if',
        __Ignore = __Plat + 'ignore',
        __Select = __Plat + 'select',
        __Template = __Plat + 'template',
        __Routeport = __Plat + 'routeport',
        __Viewport = __Plat + 'viewport',
    
        /**
         * Animations
         */
        __Hide = __Plat + 'hide',
        __Animating = __Plat + 'animating',
        __SimpleAnimation = __Plat + 'animation',
        __SimpleTransition = __Plat + 'transition',
        __Enter = __Plat + 'enter',
        __Leave = __Plat + 'leave',
        __Move = __Plat + 'move',
        __FadeIn = __Plat + 'fadein',
        __FadeOut = __Plat + 'fadeout',
    
        /**
         * Custom events
         */
        __$tap = '$tap',
        __$dbltap = '$dbltap',
        __$touchstart = '$touchstart',
        __$touchend = '$touchend',
        __$touchmove = '$touchmove',
        __$touchcancel = '$touchcancel',
        __$hold = '$hold',
        __$release = '$release',
        __$swipe = '$swipe',
        __$swipeleft = '$swipeleft',
        __$swiperight = '$swiperight',
        __$swipeup = '$swipeup',
        __$swipedown = '$swipedown',
        __$track = '$track',
        __$trackleft = '$trackleft',
        __$trackright = '$trackright',
        __$trackup = '$trackup',
        __$trackdown = '$trackdown',
        __$trackend = '$trackend',
    
        /**
         * Constants
         */
        __startSymbol = '{{',
        __endSymbol = '}}',
        __STATIC = 'static',
        __SINGLETON = 'singleton',
        __INSTANCE = 'instance',
        __FACTORY = 'factory',
        __CLASS = 'class',
        __CSS = 'css',
        __COMPILED = '-compiled',
        __BOUND_PREFIX = '-@',
        __START_NODE = ': start node',
        __END_NODE = ': end node',
        __JS = 'js',
        __noopInjector = 'noop';
    /* tslint:enable:no-unused-variable */
    
    /* tslint:disable:no-unused-variable */
    var __nativeIsArray = !!Array.isArray,
        __uids__: plat.IObject<Array<string>> = {};
    
    function noop(): void { }
    
    function extend(destination: any, ...sources: any[]): any {
        if (isNull(destination)) {
            return destination;
        }
    
        var deep = isBoolean(destination);
    
        if (deep) {
            destination = sources.shift();
        }
    
        var keys: Array<string>,
            property: any;
    
        forEach(sources, (source, k) => {
            if (!isObject(source)) {
                return;
            }
    
            keys = Object.keys(source);
    
            forEach(keys, (key) => {
                property = source[key];
                if (deep) {
                    if (isArray(property)) {
                        extend(deep, destination[key] || (destination[key] = []), property);
                        return;
                    } else if (isDate(property)) {
                        destination[key] = new Date(property.getTime());
                        return;
                    } else if (isRegExp(property)) {
                        destination[key] = new RegExp(property);
                        return;
                    } else if (isNode(property)) {
                        destination[key] = (<Node>property).cloneNode(true);
                        return;
                    } else if (isObject(property)) {
                        extend(deep, destination[key] || (destination[key] = {}), property);
                        return;
                    }
                }
                destination[key] = property;
            });
        });
    
        return destination;
    }
    
    function deepExtend(destination: any, ...sources: any[]): any {
        return extend.apply(null, [true, destination].concat(sources));
    }
    
    function _clone(obj: any, deep?: boolean) {
        if (!isObject(obj)) {
            return obj;
        } else if (isDate(obj)) {
            return new Date((<Date>obj).getTime());
        } else if (isRegExp(obj)) {
            return new RegExp(obj);
        } else if (isNode(obj)) {
            return (<Node>obj).cloneNode(deep);
        } else if (isError(obj)) {
            return new obj.constructor((<Error>obj).message);
        }
    
        var type = {};
    
        if (isArray(obj)) {
            type = [];
        }
    
        if (isBoolean(deep) && deep) {
            return deepExtend(type, obj);
        }
    
        return extend(type, obj);
    }
    
    function isError(obj: any): boolean {
        return Object.prototype.toString.call(obj) === '[object Error]';
    }
    
    function isObject(obj: any): boolean {
        return obj != null && typeof obj === 'object';
    }
    
    function isWindow(obj: any): boolean {
        return !!(obj && obj.document && obj.setInterval);
    }
    
    function isDocument(obj: any): boolean {
        return !!(obj && obj.nodeType === Node.DOCUMENT_NODE);
    }
    
    function isNode(obj: any): boolean {
        return !!(obj && typeof obj.nodeType === 'number');
    }
    
    function isDocumentFragment(obj: any): boolean {
        return !!(obj && (<Node>obj).nodeType === Node.DOCUMENT_FRAGMENT_NODE);
    }
    
    function isFile(obj: any): boolean {
        return isObject(obj) && obj.toString() === '[object File]';
    }
    
    function isString(obj: any): boolean {
        return typeof obj === 'string';
    }
    
    function isRegExp(obj: any): boolean {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    }
    
    function isPromise(obj: any): boolean {
        return isObject(obj) && (obj.toString() === '[object Promise]' || isFunction(obj.then));
    }
    
    function isEmpty(obj: any): boolean {
        if (isNull(obj)) {
            return true;
        }
    
        if (isString(obj) || isArray(obj)) {
            return obj.length === 0;
        }
    
        if (!isObject(obj)) {
            return false;
        }
    
        return Object.keys(obj).length === 0;
    }
    
    function isBoolean(obj: any): boolean {
        return typeof obj === 'boolean';
    }
    
    function isNumber(obj: any): boolean {
        return typeof obj === 'number' && !isNaN(obj);
    }
    
    function isFunction(obj: any): boolean {
        return typeof obj === 'function';
    }
    
    function isNull(obj: any): boolean {
        return obj === null || obj === undefined;
    }
    
    function isUndefined(obj: any): boolean {
        return obj === undefined;
    }
    
    function isArray(obj: any): boolean {
        if (__nativeIsArray) {
            return Array.isArray(obj);
        }
    
        return Object.prototype.toString.call(obj) === '[object Array]';
    }
    
    function isArrayLike(obj: any): boolean {
        if (isNull(obj) || isWindow(obj) || isFunction(obj)) {
            return false;
        }
    
        return isString(obj) || obj.length >= 0;
    }
    
    function isDate(obj: any): boolean {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }
    
    function filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T> {
        var arr: Array<T> = [];
        if (isNull(obj)) {
            return arr;
        }
    
        if (isFunction(obj.filter)) {
            return obj.filter(iterator, context);
        }
    
        forEach<T>(obj, (value: T, key: any, obj: any) => {
            if (iterator(value, key, obj)) {
                arr.push(value);
            }
        });
    
        return arr;
    }
    
    function where(obj: any, properties: any): Array<any> {
        return filter(obj, (value)
            => !some(properties, (property, key)
                => (<any>value)[key] !== property));
    }
    
    function forEach<T>(array: Array <T>, iterator: (value: T, index: number, obj: any) => void, context?: any): Array < T>;
    function forEach<T>(obj: any, iterator: (value: T, key: string, obj: any) => void, context?: any): any;
    function forEach<T>(obj: any, iterator: (value: T, key: any, obj: any) => void, context?: any): any {
        if (isNull(obj) || !(isObject(obj) || isArrayLike(obj))) {
            return obj;
        }
    
        var i: number,
            key: string,
            length: number;
    
        if (isFunction(obj.forEach)) {
            return obj.forEach(iterator, context);
        } else if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; ++i) {
                iterator.call(context, obj[i], i, obj);
            }
        } else {
            var keys = Object.keys(obj);
            length = keys.length;
            while (keys.length > 0) {
                key = keys.shift();
                iterator.call(context, obj[key], key, obj);
            }
        }
    
        return obj;
    }
    
    function map<T, U>(obj: any, iterator: (value: T, key: any, obj: any) => U, context?: any): Array<U> {
        var arr: Array<U> = [];
    
        if (isNull(obj)) {
            return arr;
        }
    
        if (isFunction(obj.map)) {
            return obj.map(iterator, context);
        }
    
        forEach(obj, (value, key) => {
            arr.push(iterator.call(context, value, key, obj));
        });
    
        return arr;
    }
    
    function pluck<T, U>(obj: any, key: string): Array<U> {
        return map<T, U>(obj, (value) => (<any>value)[key]);
    }
    
    function some<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): boolean {
        if (isNull(obj) || isFunction(obj)) {
            return false;
        }
    
        var i: number,
            key: string,
            length: number,
            ret: boolean;
    
        if (isFunction(obj.some)) {
            return obj.some(iterator, context);
        } else if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; ++i) {
                ret = iterator.call(context, obj[i], i, obj);
                if (ret === true) {
                    return true;
                }
            }
        } else {
            var keys = Object.keys(obj);
            length = keys.length;
            while (keys.length > 0) {
                key = keys.shift();
                ret = iterator.call(context, obj[key], key, obj);
                if (ret === true) {
                    return true;
                }
            }
        }
    
        return false;
    }
    
    function postpone(method: (...args: any[]) => void, args?: Array<any>, context?: any): plat.IRemoveListener {
        return defer(method, 0, args, context);
    }
    
    function defer(method: (...args: any[]) => void, timeout: number, args?: Array<any>, context?: any): plat.IRemoveListener {
        function defer() {
            method.apply(context, args);
        }
    
        var timeoutId = setTimeout(defer, timeout);
    
        return () => {
            clearTimeout(timeoutId);
        };
    }
    
    function uniqueId(prefix?: string): string {
        if (isNull(prefix)) {
            prefix = '';
        }
    
        var puid = __uids__[prefix];
    
        if (isNull(puid)) {
            puid = __uids__[prefix] = ['0', '/'];
        }
    
        var index = puid.length,
            charCode: number;
    
        while (index--) {
            charCode = puid[index].charCodeAt(0);
            // '9'
            if (charCode === 57) {
                puid[index] = 'A';
                return join();
            }
    
            // 'Z'
            if (charCode === 90) {
                puid[index] = 'a';
                return join();
            }
    
            // 'z'
            if (charCode === 122) {
                puid[index] = '0';
            } else {
                puid[index] = String.fromCharCode(charCode + 1);
                return join();
            }
        }
    
        puid.unshift('0');
    
        function join(): string {
            return prefix + puid.join('');
        }
    
        return join();
    }
    
    var camelCaseRegex: RegExp;
    
    function camelCase(str: string): string {
        if (!isString(str) || isEmpty(str)) {
            return str;
        }
    
        str = str.charAt(0).toLowerCase() + str.slice(1);
        camelCaseRegex = camelCaseRegex || (<plat.expressions.IRegex>plat.acquire(__Regex)).camelCaseRegex;
    
        return str.replace(camelCaseRegex,
            (match: string, delimiter?: string, char?: string, index?: number)
                => index ? char.toUpperCase() : char);
    }
    
    function deleteProperty(obj: any, property: number): any;
    function deleteProperty(obj: any, property: string): any;
    function deleteProperty(obj: any, property: any): any {
        if (!isNull(obj)) {
            /* tslint:disable:no-unused-expression */
            delete obj[property];
            /* tslint:enable:no-unused-expression */
        }
    
        return obj;
    }
    
    function access(obj: any, property: number): any;
    function access(obj: any, property: string): any;
    function access(obj: any, property: any): any {
        if (isNull(obj)) {
            return obj;
        }
        return obj[property];
    }
    /* tslint:enable:no-unused-variable */
    
    /* tslint:disable:no-unused-variable */
    var __nodeNameRegex = /<([\w:]+)/,
        __option = [1, '<select multiple="multiple">', '</select>'],
        __table = [1, '<table>', '</table>'],
        __tableData = [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        __svg = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'],
        __innerTableWrappers: plat.IObject<Array<any>> = {
            thead: __table,
            tbody: __table,
            tfoot: __table,
            colgroup: __table,
            caption: __table,
            tr: [2, '<table><tbody>', '</tbody></table>'],
            col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
            td: __tableData,
            th: __tableData
        },
        __innerHtmlWrappers: plat.IObject<Array<any>> = extend({}, __innerTableWrappers, {
            option: __option,
            optgroup: __option,
            legend: [1, '<fieldset>', '</fieldset>'],
            area: [1, '<map>', '</map>'],
            param: [1, '<object>', '</object>'],
            text: __svg,
            circle: __svg,
            ellipse: __svg,
            line: __svg,
            path: __svg,
            polygon: __svg,
            polyline: __svg,
            rect: __svg,
            _default: [0, '', '']
        });
    
    function appendChildren(nodeList: any, root?: Node): Node {
        var isFragment = isDocumentFragment(root),
            nullRoot = isNull(root),
            fragment: DocumentFragment = isFragment ?
            <DocumentFragment>root :
            (plat.acquire(__Document)).createDocumentFragment();
    
        if (nullRoot) {
            root = fragment;
        }
    
        var list: Array<Node>;
    
        if (isFunction(nodeList.push)) {
            list = nodeList;
        } else {
            list = Array.prototype.slice.call(nodeList);
        }
    
        while (list.length > 0) {
            fragment.insertBefore(list.shift(), null);
        }
    
        if (!(isFragment || nullRoot)) {
            root.appendChild(fragment);
        }
    
        return root;
    }
    
    function clearNode(node: Node): void {
        var childNodes = Array.prototype.slice.call(node.childNodes);
    
        while (childNodes.length > 0) {
            node.removeChild(childNodes.pop());
        }
    }
    
    function clearNodeBlock(nodeList: any, parent: Node): void {
        if (!isFunction(nodeList.push)) {
            nodeList = Array.prototype.slice.call(nodeList);
        }
    
        if (!isNull(parent)) {
            clearNodeBlockWithParent(nodeList, parent);
            return;
        }
    
        var node: Node;
    
        while (nodeList.length > 0) {
            node = nodeList.pop();
            parent = node.parentNode;
    
            if (isNull(parent)) {
                continue;
            }
    
            parent.removeChild(node);
        }
    }
    
    function clearNodeBlockWithParent(nodeList: Array<Node>, parent: Node): void {
        while (nodeList.length > 0) {
            parent.removeChild(nodeList.pop());
        }
    }
    
    function stringToNode(html: string): Node {
        var $compat: plat.ICompat = plat.acquire(__Compat),
            $document: Document = plat.acquire(__Document),
            nodeName = __nodeNameRegex.exec(html),
            element = <HTMLElement>$document.createElement('div');
    
        if (isNull(nodeName)) {
            element = innerHtml(element, html);
            return element.removeChild(element.lastChild);
        }
    
        // trim html string
        html = html.trim();
    
        var mapTag = nodeName[1];
    
        if ($compat.pushState && isUndefined(__innerTableWrappers[mapTag])) {
            return innerHtml(element, html);
        } else if (mapTag === 'body') {
            element = innerHtml($document.createElement('html'), html);
            return element.removeChild(element.lastChild);
        }
    
        var wrapper = __innerHtmlWrappers[mapTag] || (<any>__innerHtmlWrappers)._default,
            depth = wrapper[0],
            parentStart = wrapper[1],
            parentEnd = wrapper[2];
    
        element = innerHtml(element, parentStart + html + parentEnd);
    
        while (depth-- > 0) {
            element = <HTMLElement>element.lastChild;
        }
    
        return element;
    }
    
    function setInnerHtml(node: Node, html: string): Node {
        clearNode(node);
    
        if (isEmpty(html)) {
            return;
        }
    
        var element = stringToNode(html);
    
        if (element.childNodes.length > 0) {
            appendChildren(element.childNodes, node);
        } else {
            node.insertBefore(element, null);
        }
    
        return node;
    }
    
    function insertBefore(parent: Node, nodes: any, endNode?: Node): Array<Node> {
        if (isNull(parent) || !isObject(nodes)) {
            return;
        } else if (isUndefined(endNode)) {
            endNode = null;
        }
    
        var fragment: DocumentFragment;
    
        if (isNode(nodes)) {
            fragment = nodes;
    
            nodes = Array.prototype.slice.call(fragment.childNodes);
            parent.insertBefore(fragment, endNode);
    
            return nodes;
        }
    
        if (!isFunction(nodes.push)) {
            nodes = Array.prototype.slice.call(nodes);
        }
    
        var $document = plat.acquire(__Document),
            length = nodes.length;
    
        fragment = $document.createDocumentFragment();
    
        for (var i = 0; i < length; ++i) {
            fragment.insertBefore(nodes[i], null);
        }
    
        parent.insertBefore(fragment, endNode);
    
        return nodes;
    }
    
    function replace(node: Node): Array<Node> {
        var parent = node.parentNode,
            nodes = insertBefore(parent, node.childNodes, node);
    
        parent.removeChild(node);
    
        return nodes;
    }
    
    function replaceWith(node: Node, newNode: HTMLElement): HTMLElement;
    function replaceWith(node: Node, newNode: Element): Element;
    function replaceWith(node: Node, newNode: Node): Node;
    function replaceWith(node: any, newNode: any): any {
        if (isNull(newNode)) {
            return newNode;
        }
    
        if (node.nodeType === Node.ELEMENT_NODE) {
            var attributes = node.attributes,
                length = attributes.length,
                attribute: Attr;
    
            for (var i = 0; i < length; ++i) {
                attribute = attributes[i];
                newNode.setAttribute(attribute.name, attribute.value);
            }
        }
    
        var parent = node.parentNode;
    
        insertBefore(newNode, node.childNodes);
        parent.replaceChild(newNode, node);
    
        return newNode;
    }
    
    function serializeHtml(html?: string): DocumentFragment {
        var $document = plat.acquire(__Document),
            templateElement = $document.createDocumentFragment();
    
        if (!isEmpty(html)) {
            setInnerHtml(templateElement, html);
        }
    
        return templateElement;
    }
    
    function removeBetween(startNode: Node, endNode?: Node): void {
        if (isNull(startNode)) {
            return;
        }
    
        var currentNode = startNode.nextSibling,
            parentNode = startNode.parentNode,
            tempNode: Node;
    
        if (isNull(endNode)) {
            endNode = null;
        }
    
        if (isNull(parentNode) || (!isNull(endNode) && endNode.parentNode !== parentNode)) {
            return;
        }
    
        while (currentNode !== endNode) {
            tempNode = currentNode.nextSibling;
            parentNode.removeChild(currentNode);
            currentNode = tempNode;
        }
    }
    
    function removeAll(startNode: Node, endNode?: Node): void {
        if (isNull(startNode)) {
            return;
        }
    
        removeBetween(startNode, endNode);
    
        removeNode(startNode);
        removeNode(endNode);
    }
    
    /**
     * Safely sets innerHTML of an element. Uses MSApp.execUnsafeLocalFunction if 
     * available.
     */
    function innerHtml(element: HTMLElement, html: string): HTMLElement {
        var $compat: plat.ICompat = plat.acquire(__Compat);
    
        if ($compat.msApp) {
            MSApp.execUnsafeLocalFunction(() => {
                element.innerHTML = html;
            });
        } else {
            element.innerHTML = html;
        }
    
        return element;
    }
    
    function removeNode(node: Node): void {
        if (isNull(node)) {
            return;
        }
    
        var parentNode = node.parentNode;
    
        if (!isNull(parentNode)) {
            node.parentNode.removeChild(node);
        }
    }
    
    function addClass(element: HTMLElement, className: string): void {
        if (!isString(className) || className === '') {
            return;
        }
    
        if (isUndefined(element.classList)) {
            if (isEmpty(element.className)) {
                element.className = className;
                return;
            }
    
            element.className += ' ' + className;
            return;
        }
    
        element.classList.add(className);
    }
    
    function removeClass(element: HTMLElement, className: string): void {
        if (!isString(className) || className === '') {
            return;
        }
    
        if (isUndefined(element.classList)) {
            if (element.className === className) {
                element.className = '';
                return;
            }
    
            element.className = element.className
                .replace(new RegExp('^' + className + '\\s|\\s' + className + '$|\\s' + className + '|' + className + '\\s', 'g'), '');
            return;
        }
    
        element.classList.remove(className);
    }
    
    function toggleClass(element: HTMLElement, className: string): void {
        if (!isString(className) || className === '') {
            return;
        }
    
        if (isUndefined(element.classList)) {
            var name = element.className;
            if (name === '') {
                element.className = className;
            } else if (name === className) {
                element.className = '';
                return;
            }
    
            var classNameRegex = new RegExp('^' + className + '\\s|\\s' + className + '$|\\s' + className + '|' + className + '\\s', 'g');
            if (classNameRegex.test(name)) {
                element.className = name.replace(classNameRegex, '');
                return;
            }
    
            element.className += ' ' + className;
            return;
        }
    
        element.classList.toggle(className);
    }
    
    function hasClass(element: HTMLElement, className: string): boolean {
        if (!isString(className) || className === '') {
            return;
        }
    
        if (isUndefined(element.classList)) {
            var name = element.className;
            if (name === '') {
                return false;
            } else if (name === className) {
                return true;
            }
    
            return new RegExp('^' + className + '\\s|\\s' + className + '$|\\s' + className + '|' + className + '\\s', 'g').test(name);
        }
    
        return element.classList.contains(className);
    }
    /* tslint:enable:no-unused-variable */
    
    /**
     * @name register
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds all the classes and interfaces related to registering components for platypus.
     */
    export module register {
        /**
         * @name add
         * @memberof plat.register
         * @kind function
         * @access private
         * @exported false
         * 
         * @description
         * Generic function for creating an {@link plat.dependency.Injector|Injector} and 
         * adding it to an {@link plat.dependency.IInjectorObject|IInjectorObject}.
         * 
         * @param {plat.dependency.IInjectorObject<any>} obj The {@link plat.dependency.IInjectorObject|IInjectorObject} 
         * to which to add an {@link plat.dependency.Injector|Injector}.
         * @param {string} name The name used to set/get the {@link plat.dependency.Injector|Injector} from the 
         * {@link plat.dependency.IInjectorObject|IInjectorObject}.
         * @param {any} Type The constructor or function definition for the {@link plat.dependency.Injector|Injector}.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the
         * {@link plat.dependency.Injector|Injector}.
         * @param {string} injectableType? The injectable type.
         * @param {boolean} isStatic The injectable type is a static type.
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        function add(obj: dependency.IInjectorObject<any>, name: string, Type: any, dependencies?: Array<any>,
            injectableType?: string, isStatic?: boolean): typeof register {
            var injector = obj[name] = new dependency.Injector<any>(name, Type, dependencies, injectableType);

            if (isStatic === true) {
                staticInjectors[name] = injector;
            }

            return register;
        }
    
        /**
         * @name app
         * @memberof plat.register
         * @kind function
         * @access public
         * 
         * @description
         * Registers the {@link plat.IApp|IApp} with the framework. The framework will instantiate the {@link plat.IApp|IApp} 
         * when needed, and wire up the Application Lifecycle events. The dependencies array corresponds to injectables that will be 
         * passed into the Constructor of the app.
         * 
         * @param {string} name The name of your app.
         * @param {new (...args: any[]) => plat.IApp} Type The constructor for the {@link plat.IApp|IApp}.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the app injector.
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function app(name: string, Type: new (...args: any[]) => IApp, dependencies?: Array<any>): typeof register {
            var app = new dependency.Injector<IApp>(name, Type, dependencies),
                $appStatic: IAppStatic = acquire(__AppStatic);

            $appStatic.registerApp(app);
            return register;
        }
    
        /**
         * @name control
         * @memberof plat.register
         * @kind function
         * @access public
         * 
         * @description
         * Registers an {@link plat.IControl|IControl} with the framework. The framework will instantiate the 
         * {@link plat.IControl|IControl} when needed. The dependencies array corresponds to injectables that 
         * will be passed into the Constructor of the control.
         * 
         * @param {string} name The control type, corresponding to the HTML notation for creating a new IControl (e.g. 'plat-foreach').
         * @param {new (...args: any[]) => plat.IControl} Type The constructor for the {@link plat.IControl|IControl}.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the {@link plat.IControl|IControl} 
         * injector.
         * 
         * @example plat.register.control('my-tap', MyTap, [plat.expressions.IParser]);
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function control(name: string, Type: new (...args: any[]) => IControl, dependencies?: Array<any>): typeof register {
            if (isString(name)) {
                name = name.toLowerCase();
            } else {
                throw new Error('A Control must be registered with a string name');
            }

            return add(controlInjectors, name, Type, dependencies);
        }
    
        /**
         * @name viewControl
         * @memberof plat.register
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Registers an {@link plat.ui.IViewControl|IViewControl} with the framework. The framework will 
         * instantiate the control when needed. The dependencies array corresponds to injectables that will be 
         * passed into the Constructor of the control.
         * 
         * @param {string} name The control type, corresponding to the HTML notation for creating a new 
         * {@link plat.ui.IViewControl|IViewControl}. Used for navigation to the specified {@link plat.ui.IViewControl|IViewControl}.
         * @param {new (...args: any[]) => plat.ui.IViewControl} Type The constructor for the {@link plat.ui.IViewControl|IViewControl}.
         * @param {Array<any>} dependencies? An optional array of strings representing the dependencies needed for the 
         * {@link plat.ui.IViewControl|IViewControl} injector.
         * 
         * @example plat.register.viewControl('my-view-control', MyViewControl);
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function viewControl(name: string, Type: new (...args: any[]) => ui.IViewControl,
            dependencies?: Array<any>): typeof register;
        /**
         * @name viewControl
         * @memberof plat.register
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Registers an {@link plat.ui.IWebViewControl|WebViewControl} with the framework. The framework will instantiate the 
         * control when needed. The dependencies array corresponds to injectables that will be passed into the Constructor of the control.
         * 
         * @param {string} name The control type, corresponding to the HTML notation for creating a new 
         * {@link plat.ui.IWebViewControl|WebViewControl}. Used for navigation to the specified {@link plat.ui.IWebViewControl|WebViewControl}.
         * @param {new (...args: any[]) => ui.IWebViewControl} Type The constructor for the {@link plat.ui.IWebViewControl|WebViewControl}.
         * @param {Array<any>} dependencies? An optional array of strings representing the dependencies needed for the 
         * {@link plat.ui.IWebViewControl|WebViewControl} injector.
         * @param {Array<any>} routes? Optional route strings (or regular expressions) used for matching a URL to the 
         * registered {@link plat.ui.IWebViewControl|WebViewControl}.
         * 
         * @example plat.register.viewControl('my-view-control', MyViewControl, null, ['customers/:customer(/:ordernumber)']);
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function viewControl(name: string, Type: new (...args: any[]) => ui.IWebViewControl,
            dependencies: Array<any>, routes: Array<any>): typeof register;
        export function viewControl(name: string, Type: new (...args: any[]) => ui.IBaseViewControl,
            dependencies?: Array<any>, routes?: Array<any>): typeof register {
            if (isString(name)) {
                name = name.toLowerCase();
            } else {
                throw new Error('A ViewControl must be registered with a string name');
            }

            var ret = add(viewControlInjectors, name, Type, dependencies);

            if (isArray(routes)) {
                var $Router: web.IRouter = acquire(__Router);
                $Router.registerRoutes(name, routes);
            }

            return ret;
        }
    
        /**
         * @name injectable
         * @memberof plat.register
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Registers an injectable with the framework. Injectables are objects that can be used for dependency injection into other objects.
         * The dependencies array corresponds to injectables that will be passed into the Constructor of the injectable.
         * 
         * @param {string} name The name of the injector, used when another component is specifying dependencies.
         * @param {new (...args: any[]) => any} Type The constructor for the injectable. The injectable will only be 
         * instantiated once during the application lifetime.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the injectable's injector.
         * @param {string} injectableType? Specifies the type of injectable, either {@link plat.register.injectable.SINGLETON|SINGLETON}, 
         * {@link plat.register.injectable.STATIC|STATIC}, {@link plat.register.injectable.INSTANCE|INSTANCE}, 
         * {@link plat.register.injectable.FACTORY|FACTORY}, {@link plat.register.injectable.CLASS|CLASS} 
         * (defaults to {@link plat.register.injectable.SINGLETON|SINGLETON}).
         * 
         * @example
         * plat.register.injectable('$CacheFactory', [plat.expressions.IParser], Cache);
         * plat.register.injectable('database', MyDatabase, null, plat.register.injectable.INSTANCE);
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function injectable(name: string, Type: new (...args: any[]) => any,
            dependencies?: Array<any>, injectableType?: string): typeof register;
        /**
         * @name injectable
         * @memberof plat.register
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Registers an injectable with the framework. Injectables are objects that can be used for dependency injection into other objects.
         * The dependencies array corresponds to injectables that will be passed into the Constructor of the injectable.
         * 
         * @param {string} name The name of the injector, used when another component is specifying dependencies.
         * @param {(...args: any[]) => any} method A method that returns the injectable.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the injectable's injector.
         * @param {string} injectableType? Specifies the type of injectable, either {@link plat.register.injectable.SINGLETON|SINGLETON}, 
         * {@link plat.register.injectable.STATIC|STATIC}, {@link plat.register.injectable.INSTANCE|INSTANCE}, 
         * {@link plat.register.injectable.FACTORY|FACTORY}, {@link plat.register.injectable.CLASS|CLASS} 
         * (defaults to {@link plat.register.injectable.SINGLETON|SINGLETON}).
         * 
         * @example
         * plat.register.injectable('$CacheFactory', [plat.expressions.IParser], 
         *     function(parser: plat.expressions.IParser) { return { ... }; });
         * plat.register.injectable('database', function() { return new Database(); }, null, register.injectable.INSTANCE);
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function injectable(name: string, method: (...args: any[]) => any,
            dependencies?: Array<any>, injectableType?: string): typeof register;
        export function injectable(name: string, Type: any, dependencies?: Array<any>, injectableType?: string): typeof register {
            if (!isString(injectableType)) {
                injectableType = __SINGLETON;
            } else {
                injectableType = injectableType.toLowerCase();
                if (injectableType === __FACTORY || injectableType === __STATIC || injectableType === __CLASS) {
                    return add(injectableInjectors, name, Type, dependencies, injectableType, true);
                } else if (!(injectableType === __SINGLETON || injectableType === __INSTANCE)) {
                    throw new Error('Invalid injectable type ' + injectableType + ' during injectable registration.');
                }
            }

            return add(injectableInjectors, name, Type, dependencies, injectableType, false);
        }
 
        /**
         * @name injectable
         * @memberof plat.register
         * @kind namespace
         * @access public
         * 
         * @description
         * Contains constants for injectable type.
         */

        export module injectable {
                /**
                 * @name STATIC
                 * @memberof plat.register.injectable
                 * @kind property
                 * @access public
                 * @static
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Static injectables will be injected before the application loads. This provides a way to create 
                 * a static constructor and load dependencies into static class properties.
                 */
                export var STATIC = __STATIC;
        
                /**
                 * @name SINGLETON
                 * @memberof plat.register.injectable
                 * @kind property
                 * @access public
                 * @static
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Singleton injectables will contain a constructor. A Singleton injectable will be instantiated once and 
                 * used throughout the application lifetime. It will be instantiated when another component is injected 
                 * and lists it as a dependency.
                 */
                export var SINGLETON = __SINGLETON;
        
                /**
                 * @name INSTANCE
                 * @memberof plat.register.injectable
                 * @kind property
                 * @access public
                 * @static
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Instance injectables will contain a constructor. An Instance injectable will be instantiated multiple times 
                 * throughout the application lifetime. It will be instantiated whenever another component is injected 
                 * and lists it as a dependency.
                 */
                export var INSTANCE = __INSTANCE;
        
                /**
                 * @name FACTORY
                 * @memberof plat.register.injectable
                 * @kind property
                 * @access public
                 * @static
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Factory injectables will not contain a constructor but will instead contain a method for obtaining an 
                 * instance, such as getInstance() or create(). It will be injected before the application loads, similar to a Static 
                 * injectable.
                 */
                export var FACTORY = __FACTORY;
        
                /**
                 * @name CLASS
                 * @memberof plat.register.injectable
                 * @kind property
                 * @access public
                 * @static
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Class injectables are essentially a direct reference to a class's constructor. It may contain both 
                 * static and instance methods as well as a constructor for creating a new instance.
                 */
                export var CLASS = __CLASS;
        }
        /**
         * @name animation
         * @memberof plat.register
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Adds a CSS animation denoted by its name. If you wish to also support legacy browsers, make sure to register a 
         * JS implementation as well.
         * 
         * @param {string} name The unique idenitifer of the animation.
         * @param {new (...args: any[]) => plat.ui.animations.ICssAnimation} Type The constructor for the custom animation.
         * @param {Array<any>} dependencies? Any dependencies that need to be injected into the animation at 
         * instantiation.
         * @param {string} animationType The type of animation. Both the intended type and default value are 
         * {@link plat.register.animation.CSS|CSS}.
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function animation(name: string, Type: new (...args: any[]) => ui.animations.ICssAnimation,
            dependencies?: Array<any>, animationType?: 'css'): typeof register;
        export function animation(name: string, Type: new (...args: any[]) => ui.animations.ICssAnimation,
            dependencies?: Array<any>, animationType?: string): typeof register;
        /**
         * @name animation
         * @memberof plat.register
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Adds a JS animation denoted by its name. If  Intended to be used when JS animation implementations for legacy browsers 
         * is desired.
         * 
         * @param {string} name The unique idenitifer of the animation.
         * @param {new (...args: any[]) => plat.ui.animations.IJsAnimation} Type The constructor for the custom animation.
         * @param {Array<any>} dependencies? Any dependencies that need to be injected into the animation at 
         * instantiation.
         * @param {string} animationType The type of animation. Both the intended type and default value are 
         * {@link plat.register.animation.JS|JS}.
         * 
         * @returns {plat.register} The object that contains the register methods (for method chaining).
         */
        export function animation(name: string, Type: new (...args: any[]) => ui.animations.IJsAnimation,
            dependencies: Array<any>, animationType: 'js'): typeof register;
        export function animation(name: string, Type: new (...args: any[]) => ui.animations.IJsAnimation,
            dependencies: Array<any>, animationType: string): typeof register;
        export function animation(name: string, Type: new (...args: any[]) => ui.animations.IBaseAnimation,
            dependencies?: Array<any>, animationType?: string): typeof register {
            if (!isString(animationType)) {
                animationType = __CSS;
            } else {
                animationType = animationType.toLowerCase();
                if (!(animationType === animation.CSS || animationType === animation.JS)) {
                    throw new Error('Invalid animationType "' + animationType + '" during animation registration.');
                }
            }

            return add((animationType === __JS ? jsAnimationInjectors : animationInjectors),
                name, Type, dependencies, register.injectable.INSTANCE);
        }
    
        /**
         * @name animation
         * @memberof plat.register
         * @kind namespace
         * @access public
         * 
         * @description
         * Contains constants for animation type.
         */

        export module animation {
                /**
                 * @name CSS
                 * @memberof plat.register.animation
                 * @kind property
                 * @access public
                 * @static
                 * 
                 * @type {string}
                 * 
                 * @description
                 * A CSS animation.
                 */
                export var CSS = __CSS;
        
                /**
                 * @name CSS
                 * @memberof plat.register.animation
                 * @kind property
                 * @access public
                 * @static
                 * 
                 * @type {string}
                 * 
                 * @description
                 * A JavaScript animation.
                 */
                export var JS = __JS;
        }
    }
    /**
     * @name controlInjectors
     * @memberof plat.register
     * @kind property
     * @access private
     * @static
     * @exported false
     * 
     * @type {plat.dependency.IInjectorObject<plat.IControl>}
     * 
     * @description
     * An {@link plat.dependency.IInjectorObject|IInjectorObject} of {@link plat.IControl|IControls}. 
     * Contains all the registered controls for an application.
     */
    var controlInjectors: plat.dependency.IInjectorObject<plat.IControl> = {};
    
    /**
     * @name viewControlInjectors
     * @memberof plat.register
     * @kind property
     * @access private
     * @static
     * @exported false
     * 
     * @type {plat.dependency.IInjectorObject<plat.ui.IBaseViewControl>}
     * 
     * @description
     * An {@link plat.dependency.IInjectorObject|IInjectorObject} of {@link plat.ui.IBaseViewControl|IBaseViewControls}. 
     * Contains all the registered view controls for an application.
     */
    var viewControlInjectors: plat.dependency.IInjectorObject<plat.ui.IBaseViewControl> = {};
    
    /**
     * @name injectableInjectors
     * @memberof plat.register
     * @kind property
     * @access private
     * @static
     * @exported false
     * 
     * @type {plat.dependency.IInjectorObject<plat.dependency.IInjector<any>>}
     * 
     * @description
     * An {@link plat.dependency.IInjectorObject|IInjectorObject} of objects. Contains all the registered 
     * injectables for an application.
     */
    var injectableInjectors: plat.dependency.IInjectorObject<plat.dependency.IInjector<any>> = {};
    
    /**
     * @name staticInjectors
     * @memberof plat.register
     * @kind property
     * @access private
     * @static
     * @exported false
     * 
     * @type {plat.dependency.IInjectorObject<plat.dependency.IInjector<any>>}
     * 
     * @description
     * An {@link plat.dependency.IInjectorObject|IInjectorObject} of static objects. Contains all the registered 
     * static injectables for an application.
     */
    var staticInjectors: plat.dependency.IInjectorObject<plat.dependency.IInjector<any>> = {};
    
    /**
     * @name animationInjectors
     * @memberof plat.register
     * @kind property
     * @access private
     * @static
     * @exported false
     * 
     * @type {plat.dependency.IInjectorObject<plat.ui.animations.IBaseAnimation>}
     * 
     * @description
     * An {@link plat.dependency.IInjectorObject|IInjectorObject} of animations. Can be either CSS or JS implementations.
     */
    var animationInjectors: plat.dependency.IInjectorObject<plat.ui.animations.IBaseAnimation> = {};
    
    /**
     * @name jsAnimationInjectors
     * @memberof plat.register
     * @kind property
     * @access private
     * @static
     * @exported false
     * 
     * @type {plat.dependency.IInjectorObject<plat.ui.animations.IBaseAnimation>}
     * 
     * @description
     * An IInjectorObject of animations. Should only contain JS implementations.
     */
    var jsAnimationInjectors: plat.dependency.IInjectorObject<plat.ui.animations.IBaseAnimation> = {};
    
    /**
     * @name dependency
     * @memberof plat
     * @kind namespace
     * @access public
     *  
     * @description
     * Holds classes and interfaces related to dependency injection components in platypus.
     */
    export module dependency {
        /**
         * @name Injector
         * @memberof plat.dependency
         * @kind class
         * 
         * @implements {plat.dependency.IInjector}
         * 
         * @description
         * The Injector class is used for dependency injection. You can create an injector object,
         * specify dependencies and a constructor for your component. When the injector object is
         * 'injected' it will create a new instance of your component and pass in the dependencies
         * to the constructor.
         * 
         * @typeparam {any} T The type of object that will be returned when the inject method is invoked.
         */
        export class Injector<T> implements IInjector<T> {
            /**
             * @name initialize
             * @memberof plat.dependency.Injector
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Initializes all static injectors.
             * 
             * @returns {void}
             */
            static initialize(): void {
                var injectors = staticInjectors,
                    keys = Object.keys(injectors),
                    length = keys.length;

                for (var i = 0; i < length; ++i) {
                    injectors[keys[i]].inject();
                }

                staticInjectors = {};
            }

            /**
             * @name getDependencies
             * @memberof plat.dependency.Injector
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Gathers and returns the array of listed dependencies.
             * 
             * @param {Array<any>} dependencies The array of dependencies specified 
             * by either their Constructor or their registered name.
             * 
             * @returns {Array<plat.dependency.IInjecor<any>>} The dependencies
             */
            static getDependencies(dependencies: Array<any>): Array<IInjector<any>> {
                if (isNull(dependencies) || isEmpty(dependencies)) {
                    return [];
                }

                var deps: Array<IInjector<any>> = [],
                    length = dependencies.length;

                for (var i = 0; i < length; ++i) {
                    deps.push(Injector.getDependency(dependencies[i]));
                }

                return deps;
            }

            /**
             * @name getDependency
             * @memberof plat.dependency.Injector
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Finds and returns the dependency.
             * 
             * @param {any} dependency an object/string used to find the dependency.
             * 
             * @returns {plat.dependency.IInjector<any>} The dependency
             */
            static getDependency(dependency: any): IInjector<any> {
                if (isNull(dependency) || dependency === __noopInjector) {
                    return Injector.__noop();
                } else if (Injector.isInjector(dependency)) {
                    return dependency;
                }

                return Injector.__locateInjector(dependency);
            }

            /**
             * @name convertDependencies
             * @memberof plat.dependency.Injector
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Converts dependencies specified by their Constructors into 
             * equivalent dependencies specified by their registered string 
             * name.
             * 
             * @param {Array<any>} dependencies The array of dependencies specified 
             * by either their Constructor or their registered name.
             * 
             * @returns {Array<string>} The dependency strings.
             */
            static convertDependencies(dependencies: Array<any>): Array<string> {
                if (!isArray(dependencies)) {
                    return [];
                }
                var deps: Array<string> = [],
                    length = dependencies.length,
                    dependency: any,
                    value: string;

                for (var i = 0; i < length; ++i) {
                    dependency = dependencies[i];

                    if (isNull(dependency)) {
                        deps.push('noop');
                        continue;
                    }

                    value = Injector.__getInjectorName(dependency);

                    deps.push(value);
                }

                return deps;
            }

            /**
             * @name isInjector
             * @memberof plat.dependency.Injector
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Checks if the object being passed in fulfills the requirements for being an Injector.
             * 
             * @param {plat.dependency.Injector<any>} dependency The object to check.
             * 
             * @returns {boolean} Whether or not the object passed in is an injector.
             */
            static isInjector(dependency: Injector<any>): boolean {
                return isFunction(dependency.inject) &&
                    !isUndefined(dependency.type) &&
                    !isUndefined(dependency.name) &&
                    !isUndefined(dependency.Constructor);
            }

            /**
             * @name __getInjectorName
             * @memberof plat.dependency.Injector
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Gets the string name related to an injector.
             * 
             * @param {any} dependency The object to search for.
             * 
             * @returns {string} The string injector name
             */
            private static __getInjectorName(dependency: any): string {
                if (isNull(dependency)) {
                    return __noopInjector;
                } else if (isString(dependency)) {
                    return dependency;
                } else if (dependency === window) {
                    return __Window;
                } else if (dependency === window.document) {
                    return __Document;
                }

                var injectors = injectableInjectors,
                    injector: IInjector<any>,
                    keys = Object.keys(injectors),
                    length = keys.length,
                    key: string,
                    value: any;

                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    injector = injectors[key];

                    value = injector.Constructor;

                    if (value === dependency) {
                        return key;
                    }
                }

                return __noopInjector;
            }

            /**
             * @name __construct
             * @memberof plat.dependency.Injector
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Calls the injector's constructor with the associated dependencies.
             * 
             * @param {any} Constructor The Constructor to call.
             * @param {Array<any>} args The arguments to pass to the constructor.
             * 
             * @returns {any} The instantiated constructor.
             */
            private static __construct(Constructor: any, args: Array<any>): any {
                if (isNull(Constructor) || isNull(Constructor.prototype)) {
                    return Constructor;
                }
                var obj = Object.create(Constructor.prototype),
                    ret = obj.constructor.apply(obj, args);

                if (!isUndefined(ret)) {
                    return ret;
                }

                return obj;
            }

            /**
             * @name __locateInjector
             * @memberof plat.dependency.Injector
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Finds an injector object with the associated constructor.
             * 
             * @param {any} Constructor The Constructor to locate.
             * 
             * @returns {any} The located injector.
             */
            private static __locateInjector(Constructor: any): any {
                if (isNull(Constructor)) {
                    return;
                } else if (isString(Constructor)) {
                    return injectableInjectors[Constructor] || Injector.__noop();
                } else if (Constructor === window) {
                    return (<any>injectableInjectors).$Window;
                } else if (Constructor === window.document) {
                    return (<any>injectableInjectors).$Document;
                }

                var injectors = injectableInjectors,
                    injector: IInjector<any>,
                    keys = Object.keys(injectors),
                    length = keys.length;

                for (var i = 0; i < length; ++i) {
                    injector = injectors[keys[i]];

                    if (injector.Constructor === Constructor) {
                        return injector;
                    }
                }

                return Injector.__wrap(Constructor);
            }

            /**
             * @name __wrap
             * @memberof plat.dependency.Injector
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Once an injector is injected, it is wrapped to prevent further injection.
             * 
             * @param {any} value The injected value.
             * 
             * @returns {plat.dependency.IInjector<any>} The wrapped injector.
             */
            private static __wrap(value: any): IInjector<any> {
                return {
                    inject: () => value,
                    name: 'wrapped',
                    __dependencies: [],
                    Constructor: value
                };
            }

            /**
             * @name __noop
             * @memberof plat.dependency.Injector
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Returns an empty injector object.
             * 
             * @returns {plat.dependency.IInjector<any>} The noop injector.
             */
            private static __noop(): IInjector<any> {
                return {
                    inject: noop,
                    type: __noopInjector,
                    name: __noopInjector,
                    __dependencies: [],
                    Constructor: <any>noop
                };
            }

            /**
             * @name __findCircularReferences
             * @memberof plat.dependency.Injector
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Determines if there is a circular dependency in a dependency tree.
             * 
             * @param {plat.dependency.Injector<any>} injector The starting point for the dependency tree search.
             * 
             * @returns {string} The end of the circular dependency chain, if one exists.
             */
            private static __findCircularReferences(injector: Injector<any>): string {
                if (!(isObject(injector) && isArray(injector.__dependencies))) {
                    return;
                }

                var source = injector.name,
                    dependencies = injector.__dependencies,
                    node: {
                        name: string;
                        dependencies: Array<string>;
                    },
                    stack: Array<typeof node> = [{
                        name: source,
                        dependencies: dependencies.slice(0)
                    }],
                    dependency: string,
                    locate = Injector.__locateInjector,
                    length: number;

                while (stack.length > 0) {
                    node = stack.pop();

                    dependencies = node.dependencies;
                    length = dependencies.length;

                    for (var i = 0; i < length; ++i) {
                        dependency = dependencies[i];

                        if (dependency === source) {
                            return node.name;
                        }

                        injector = locate(dependency);

                        if (!(isObject(injector) && isArray(injector.__dependencies))) {
                            continue;
                        }

                        stack.push({
                            name: injector.name,
                            dependencies: injector.__dependencies.slice(0)
                        });
                    }
                }
            }

            /**
             * @name __dependencies
             * @memberof plat.dependency.Injector
             * @kind property
             * @access private
             * 
             * @type {Array<string>}
             * 
             * @description
             * The dependencies for this injector
             */
            private __dependencies: Array<string>;

            /**
             * @name constructor
             * @memberof plat.dependency.Injector
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for an injector. Converts any non-string dependencies to strings to support mocking Injectors during runtime.
             * 
             * @param {string} name The name of the injected type.
             * @param {new () => T} Constructor The constructor method for the component requiring the dependency 
             * injection.
             * @param {Array<any>} dependencies An array of strings specifying the injectable dependencies for the 
             * associated constructor.
             * @param {string} type The type of injector, used for injectables specifying a injectableType of 
             * STATIC, SINGLETON, FACTORY, INSTANCE, or CLASS. The default is SINGLETON.
             * 
             * @returns {plat.dependency.Injector}
             */
            constructor(public name: string, public Constructor: new () => T, dependencies?: Array<any>, public type: string = null) {
                var deps = this.__dependencies = Injector.convertDependencies(dependencies),
                    index = deps.indexOf(__noopInjector),
                    circularReference: string;

                if (index > -1) {
                    var dependency = dependencies[index];

                    if (isNull(dependency)) {
                        throw new TypeError('The dependency for ' +
                            name + ' at index ' +
                            index + ' is undefined, did you forgot to include a file?');
                    }

                    throw new TypeError('Could not resolve dependency ' +
                        dependency.slice(9, dependency.indexOf('(')) +
                        ' for ' +
                        name +
                        '. Are you using a static injectable Type?');
                }

                circularReference = Injector.__findCircularReferences(this);

                if (isString(circularReference)) {
                    throw new Error('Circular dependency detected from ' + name + ' to ' + circularReference + '.');
                }

                if (name === __AppStatic) {
                    var App: IAppStatic = <IAppStatic>(<any>this).inject();
                    this.__dependencies = deps;
                    App.start();
                }
            }

            /**
             * @name inject
             * @memberof plat.dependency.Injector
             * @kind function
             * @access public
             * 
             * @description
             * Gathers the dependencies for the Injector object and creates a new instance of the 
             * Constructor, passing in the dependencies in the order they were specified. If the 
             * Injector contains a Constructor for an injectable and the Constructor is registered 
             * as a SINGLE type it will only inject that injectable once.
             * 
             * @returns {T} The injected object
             */
            inject(): T {
                var toInject: any = [],
                    type = this.type;

                var dependencies = this.__dependencies,
                    length = dependencies.length,
                    dependency: IInjector<any>,
                    injectable: any;

                for (var i = 0; i < length; ++i) {
                    dependency = Injector.getDependency(dependencies[i]);
                    toInject.push(dependency.inject());
                }

                injectable = <T>Injector.__construct(this.Constructor, toInject);

                if (type === __SINGLETON || type === __FACTORY ||
                    type === __STATIC || type === __CLASS) {
                    this._wrapInjector(injectable);
                }

                return injectable;
            }

            /**
             * @name _wrapInjector
             * @memberof plat.dependency.Injector
             * @kind function
             * @access protected
             * 
             * @description
             * Wraps the injector with the instantiated value in the case of a 
             * SINGLE or STATIC type so that it does not re-instantiate.
             * 
             * @param {any} value The value to wrap
             */
            _wrapInjector(value: any): IInjector<any> {
                var name = this.name;
                return injectableInjectors[name] = <IInjector<any>>{
                    type: this.type,
                    name: name,
                    __dependencies: this.__dependencies,
                    Constructor: this.Constructor,
                    inject: () => <T>value
                };
            }
        }

        /**
         * @name IInjectorObject
         * @memberof plat.dependency
         * @kind interface
         * @access public
         * 
         * @description
         * An object whose values are all {@link plat.dependency.IInjector|IInjectors}.
         */
        export interface IInjectorObject<T> extends IObject<IInjector<T>> { }

        /**
         * @name IInjector
         * @memberof plat.dependency
         * @kind class
         * 
         * @description
         * The IInjector interface is used for dependency injection. You can create an injector object,
         * specify dependencies and a constructor for your component. When the injector object is
         * 'injected' it will create a new instance of your component and pass in the dependencies
         * to the constructor.
         * 
         * @typeparam {any} T The type of object that will be returned when the inject method is invoked.
         */
        export interface IInjector<T> {
            /**
             * @name inject
             * @memberof plat.dependency.IInjector
             * @kind function
             * @access public
             * 
             * @description
             * Gathers the dependencies for the IInjector object and creates a new instance of the 
             * Constructor, passing in the dependencies in the order they were specified. If the 
             * Injector contains a Constructor for an injectable and the Constructor is registered 
             * as a SINGLE type it will only inject that injectable once.
             * 
             * @returns {T} The injected object
             */
            inject(): T;

            /**
             * @name Constructor
             * @memberof plat.dependency.IInjector
             * @kind property
             * @access public
             * 
             * @type {new () => T}
             * 
             * @description
             * The constructor method for the component requiring the dependency injection.
             */
            Constructor: new () => T;

            /**
             * @name type
             * @memberof plat.dependency.IInjector
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of injector, used for injectables specifying a register.injectableType of 
             * STATIC, SINGLE, or MULTI. The default is SINGLE.
             */
            type?: string;

            /**
             * @name name
             * @memberof plat.dependency.IInjector
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The name registered for the injector.
             */
            name: string;
        }
    }
    /**
     * @name acquire
     * @memberof plat
     * @kind function
     * @variation 0
     * @access public
     * @static
     * 
     * @description
     * Returns the requested injectable dependency.
     * 
     * @typeparam {any} T The type of the requested dependency.
     * 
     * @param {() => T} dependency The dependency Type to return.
     * 
     * @returns T The requested dependency.
     */
    export function acquire<T>(dependency: () => T): T;
    /**
     * @name acquire
     * @memberof plat
     * @kind function
     * @variation 1
     * @access public
     * @static
     * 
     * @description
     * Returns the requested injectable dependency.
     * 
     * @param {Function} dependency The dependency Type to return.
     * 
     * @returns {any} The requested dependency.
     */
    export function acquire(dependency: Function): any;
    /**
     * @name acquire
     * @memberof plat
     * @kind function
     * @variation 2
     * @access public
     * @static
     * 
     * @description
     * Returns the requested injectable dependency.
     * 
     * @param {Function} dependency An array of Types specifying the injectable dependencies.
     * 
     * @returns {Array<any>} The dependencies, in the order they were requested.
     */
    export function acquire(dependencies: Array<Function>): Array<any>;
    /**
     * @name acquire
     * @memberof plat
     * @kind function
     * @variation 3
     * @access public
     * @static
     * 
     * @description
     * Returns the requested injectable dependency.
     * 
     * @param {string} dependency The injectable dependency type to return.
     * 
     * @returns {any} The requested dependency.
     */
    export function acquire(dependency: string): any;
    /**
     * @name acquire
     * @memberof plat
     * @kind function
     * @variation 4
     * @access public
     * @static
     * 
     * @description
     * Gathers dependencies and returns them as an array in the order they were requested.
     * 
     * @param {Array<string>} dependencies An array of strings specifying the injectable dependencies.
     * 
     * @returns {Array<any>} The dependencies, in the order they were requested.
     */
    export function acquire(dependencies: Array<string>): Array<any>;
    /**
     * @name acquire
     * @memberof plat
     * @kind function
     * @variation 5
     * @access public
     * @static
     * 
     * @description
     * Gathers dependencies and returns them as an array in the order they were requested.
     * 
     * @param {Array<any>} dependencies An array of strings or Functions specifying the injectable dependencies.
     * 
     * @returns {Array<any>} The dependencies, in the order they were requested.
     */
    export function acquire(dependencies: Array<any>): Array<any>;
    export function acquire(dependencies: any) {
        var deps: Array<dependency.IInjector<any>>,
            array = isArray(dependencies);

        if (array) {
            deps = dependency.Injector.getDependencies(dependencies);
        } else {
            deps = dependency.Injector.getDependencies([dependencies]);
        }

        var length = deps.length,
            output: Array<any> = [];

        for (var i = 0; i < length; ++i) {
            output.push(deps[i].inject());
        }

        if (!array) {
            return output[0];
        }

        return output;
    }

    /**
     * @name Exception
     * @memberof plat
     * @kind class
     * @access public
     * 
     * @description
     * Manages the throwing and consuming of errors and warnings.
     */
    export class Exception {
        /**
         * @name warn
         * @memberof plat.Exception
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Method for sending a warning to all listeners. Will 
         * not throw an error.
         * 
         * @param {string} message The message to be sent to the listeners.
         * @param {number} type? Denotes the type of fatal exception.
         * 
         * @returns {void}
         */
        static warn(message: string, type?: number): void {
            raise(message, type, false);
        }

        /**
         * @name fatal
         * @memberof plat.Exception
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Method for sending a fatal error to all listeners. Will
         * throw an error.
         * 
         * @param {Error} error The Error to be sent to all the listeners.
         * @param {number} type? Denotes the type of fatal exception. 
         * 
         * @returns {void}
         */
        static fatal(error: Error, type?: number): void;
        /**
         * @name fatal
         * @memberof plat.Exception
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Method for sending a fatal message to all listeners. Will
         * throw an error.
         * 
         * @param {string} message The message to be sent to all the listeners.
         * @param {number} type? Denotes the type of fatal exception. 
         * 
         * @returns {void}
         */
        static fatal(message: string, type?: number): void;
        static fatal(message: any, type?: number) {
            raise(message, type, true);
        }

        /**
         * @name PARSE
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for parsing exceptions
         */
        static PARSE = 0;

        /**
         * @name COMPILE
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for compiling exceptions
         */
        static COMPILE = 1;

        /**
         * @name BIND
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for binding exceptions
         */
        static BIND = 2;

        /**
         * @name NAME
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for name exceptions
         */
        static NAME = 3;

        /**
         * @name NAVIGATION
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for navigation exceptions
         */
        static NAVIGATION = 4;

        /**
         * @name TEMPLATE
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for template exceptions
         */
        static TEMPLATE = 5;

        /**
         * @name AJAX
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for ajax exceptions
         */
        static AJAX = 6;

        /**
         * @name CONTEXT
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for context exceptions
         */
        static CONTEXT = 7;

        /**
         * @name EVENT
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for event exceptions
         */
        static EVENT = 8;

        /**
         * @name INJECTABLE
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for injectable exceptions
         */
        static INJECTABLE = 9;

        /**
         * @name COMPAT
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for compat exceptions
         */
        static COMPAT = 10;

        /**
         * @name PROMISE
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for promise exceptions
         */
        static PROMISE = 11;

        /**
         * @name ANIMATION
         * @memberof plat.Exception
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for animation exceptions
         */
        static ANIMATION = 12;
    }

    /**
     * The Type for referencing the '$ExceptionStatic' injectable as a dependency.
     */
    export function IExceptionStatic(): IExceptionStatic {
        return Exception;
    }

    register.injectable(__ExceptionStatic, IExceptionStatic, null, __STATIC);

    /**
     * @name IExceptionStatic
     * @memberof plat
     * @kind interface
     * @access public
     * 
     * @description
     * Manages the throwing and consuming of errors and warnings.
     */
    export interface IExceptionStatic {
        /**
         * @name warn
         * @memberof plat.IExceptionStatic
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Method for sending a warning to all listeners. Will 
         * not throw an error.
         * 
         * @param {string} message The message to be sent to the listeners.
         * @param {number} type? Denotes the type of fatal exception.
         * 
         * @returns {void}
         */
        warn(message: string, type?: number): void;

        /**
         * @name fatal
         * @memberof plat.IExceptionStatic
         * @kind function
         * @access public
         * @static
         *
         * @description
         * Method for sending a fatal error to all listeners. Will
         * throw an error.
         *
         * @param {Error} error The Error to be sent to all the listeners.
         * @param {number} type? Denotes the type of fatal exception.
         *
         * @returns {void}
         */
        fatal(error: Error, type?: number): void;
        /**
         * @name fatal
         * @memberof plat.IExceptionStatic
         * @kind function
         * @access public
         * @static
         *
         * @description
         * Method for sending a fatal message to all listeners. Will
         * throw an error.
         *
         * @param {string} message The message to be sent to all the listeners.
         * @param {number} type? Denotes the type of fatal exception.
         *
         * @returns {void}
         */
        fatal(message: string, type?: number): void;

        /**
         * @name PARSE
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         * 
         * @type {number}
         * 
         * @description
         * Exception Type for parsing exceptions
         */
        PARSE: number;

        /**
         * @name COMPILE
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for compiling exceptions
         */
        COMPILE: number;

        /**
         * @name BIND
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for binding exceptions
         */
        BIND: number;

        /**
         * @name NAME
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for name exceptions
         */
        NAME: number;

        /**
         * @name NAVIGATION
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for navigation exceptions
         */
        NAVIGATION: number;

        /**
         * @name TEMPLATE
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for template exceptions
         */
        TEMPLATE: number;

        /**
         * @name AJAX
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for ajax exceptions
         */
        AJAX: number;

        /**
         * @name CONTEXT
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for context exceptions
         */
        CONTEXT: number;

        /**
         * @name EVENT
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for event exceptions
         */
        EVENT: number;

        /**
         * @name INJECTABLE
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for injectable exceptions
         */
        INJECTABLE: number;

        /**
         * @name COMPAT
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for compat exceptions
         */
        COMPAT: number;

        /**
         * @name PROMISE
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for promise exceptions
         */
        PROMISE: number;

        /**
         * @name ANIMATION
         * @memberof plat.IExceptionStatic
         * @kind property
         * @access public
         * @static
         * @readonly
         *
         * @type {number}
         *
         * @description
         * Exception Type for animation exceptions
         */
        ANIMATION: number;
    }

    /**
     * @name PlatException
     * @memberof plat
     * @kind class
     * @exported false
     * @access private
     * 
     * @implements {Error}
     * 
     * @description
     * A class for exceptions with platypus-specific names
     */
    class PlatException implements Error {
        /**
         * @name constructor
         * @memberof plat.PlatException
         * @kind function
         * @access public
         * 
         * @description
         * Creates a new {@link plat.PlatException|PlatException}
         * 
         * @param {string} message The message for the exception
         * @param {string} name The name of the exception
         * 
         * @returns {PlatException} The new exception object.
         */
        constructor(public message: string, public name: string) { }
    }

    /**
     * @name PlatError
     * @memberof plat
     * @kind class
     * @exported false
     * @access private
     * 
     * @implements {Error}
     * 
     * @description
     * A class for errors with platypus-specific names
     */
    class PlatError implements Error {
        /**
         * @name name
         * @memberof plat.PlatError
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The name of the error.
         */
        name = 'PlatError';

        /**
         * @name constructor
         * @memberof plat.PlatError
         * @kind function
         * @access public
         * 
         * @description
         * Creates a new {@link plat.PlatError|PlatError}
         * 
         * @param {string} message? The message for the exception
         * 
         * @returns {PlatError} The new error object.
         */
        constructor(public message?: string) {
            this.message = message || '';
        }
    }

    /**
     * @name setPrototypes
     * @memberof plat
     * @kind function
     * @access private
     * @exported false
     * 
     * @description
     * Sets the {@link plat.PlatException|PlatException} and {@link plat.PlatError|PlatError} prototypes to the passed in Error type
     * 
     * @typeparam {Error} T The type of platError.
     * 
     * @param {T} platError The prototype of the Error.
     * 
     * @returns {void}
     */
    function setPrototypes<T extends Error>(platError?: T): void {
        PlatError.prototype = platError || Error.prototype;
        PlatException.prototype = new PlatError();
    }

    /**
     * @name raise
     * @memberof plat
     * @kind function
     * @access private
     * @exported false
     * 
     * @description
     * Dispatches error events, and throws an Error if it is fatal.
     * 
     * @param {any} message Either a string or error to raise.
     * @param {boolean} isFatal? Whether or not the error is fatal.
     * 
     * @returns {void}
     */
    function raise(message: any, type: number, isFatal?: boolean): void {
        var error: Error;

        if (message instanceof Error) {
            setPrototypes(Object.getPrototypeOf(message));
        } else if (PlatError.prototype !== Error.prototype) {
            setPrototypes();
        }
        error = new PlatException(message, '');
        switch (type) {
            case Exception.PARSE:
                error.name = 'ParsingError';
                break;
            case Exception.BIND:
                error.name = 'BindingError';
                break;
            case Exception.COMPILE:
                error.name = 'CompilingError';
                break;
            case Exception.NAME:
                error.name = 'PlatNameError';
                break;
            case Exception.NAVIGATION:
                error.name = 'NavigatingError';
                break;
            case Exception.TEMPLATE:
                error.name = 'TemplatingError';
                break;
            case Exception.CONTEXT:
                error.name = 'ContextError';
                break;
            case Exception.EVENT:
                error.name = 'DispatchEventError';
                break;
            case Exception.INJECTABLE:
                error.name = 'InjectableError';
                break;
            case Exception.COMPAT:
                error.name = 'CompatibilityError';
                break;
            default:
                error = new PlatError(message);
                break;
        }

        if (message instanceof Error) {
            var properties = Object.getOwnPropertyNames(message),
                length = properties.length;

            error.message = '';
            error = Object.create(error);

            for (var i = 0; i < length; ++i) {
                (<any>error)[properties[i]] = message[properties[i]];
            }
        }

        var ErrorEvent: events.IErrorEventStatic = acquire(__ErrorEventStatic);

        ErrorEvent.dispatch('error', Exception, error);

        if (isFatal) {
            throw error;
        }
    }

    /**
     * @name Compat
     * @memberof plat
     * @kind class
     * 
     * @implements {plat.ICompat}
     * 
     * @description
     * A class containing boolean values signifying browser 
     * and/or platform compatibilities.
     */
    export class Compat implements ICompat {
        /**
         * @name $Window
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {Window}
         * 
         * @description
         * The window injectable.
         */
        $Window: Window = acquire(__Window);

        /**
         * @name $Document
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {Document}
         * 
         * @description
         * The document injectable.
         */
        $Document: Document = acquire(__Document);

        /**
         * @name isCompatible
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Determines if the browser is modern enough to correctly 
         * run PlatypusTS.
         */
        isCompatible: boolean;

        /**
         * @name cordova
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether or not Cordova is defined. If it is, 
         * we hook up ALM events to Cordova's functions.
         */
        cordova: boolean;

        /**
         * @name pushState
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether window.history.pushState is defined.
         */
        pushState: boolean;

        /**
         * @name fileSupported
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether the File API is supported.
         */
        fileSupported: boolean;

        /**
         * @name amd
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Require is present. If it is, we assume 
         * it is going to be used and leave the loading of the app up 
         * to the developer.
         */
        amd: boolean;

        /**
         * @name msApp
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether we are in the contet of a Windows 8 app.
         */
        msApp: boolean;

        /**
         * @name indexedDb
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether indexedDB exists on the window.
         */
        indexedDb: boolean;

        /**
         * @name proto
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Object.prototype.__proto__ exists.
         */
        proto: boolean;

        /**
         * @name getProto
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Object.prototype.getPrototypeOf exists.
         */
        getProto: boolean;

        /**
         * @name setProto
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Object.prototype.setPrototypeOf exists.
         */
        setProto: boolean;

        /**
         * @name hasTouchEvents
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the current browser has touch events 
         * like touchstart, touchmove, touchend, etc.
         */
        hasTouchEvents: boolean;

        /**
         * @name hasPointerEvents
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the current browser has pointer events 
         * like pointerdown, MSPointerMove, pointerup, etc.
         */
        hasPointerEvents: boolean;

        /**
         * @name hasMsPointerEvents
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the current browser has touch events 
         * like MSPointerDown, touchmove, MSPointerUp, etc.
         */
        hasMsPointerEvents: boolean;

        /**
         * @name animationSupported
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the browser supports animations.
         */
        animationSupported: boolean;

        /**
         * @name platCss
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether the platypus.css file was included or not.
         */
        platCss: boolean;

        /**
         * @name mappedEvents
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {plat.IMappedEvents}
         * 
         * @description
         * An object containing the correctly mapped touch events for the browser.
         */
        mappedEvents: IMappedEvents;

        /**
         * @name animationEvents
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {plat.IAnimationEvents}
         * 
         * @description
         * An object containing the properly prefixed animation events.
         */
        animationEvents: IAnimationEvents;

        /**
         * @name vendorPrefix
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {plat.IVendorPrefix}
         * 
         * @description
         * An object containing information regarding any potential vendor prefix.
         */
        vendorPrefix: IVendorPrefix;

        /**
         * @name IE
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {number}
         * 
         * @description
         * The version of Internet Explorer being used. If not Internet Explorer, the value is undefined.
         */
        IE: number;

        /**
         * @name ANDROID
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {number}
         * 
         * @description
         * The version of Android being used. If not Android, the value is undefined.
         */
        ANDROID: number;

        /**
         * @name __events
         * @memberof plat.Compat
         * @kind property
         * @access public
         * 
         * @type {plat.IObject<boolean>}
         * 
         * @description
         * An object containing all event lookups.
         */
        private __events: IObject<boolean> = {};

        /**
         * @name constructor
         * @memberof plat.Compat
         * @kind function
         * @access public
         * 
         * @description
         * Define everything.
         * 
         * @returns {void}
         */
        constructor() {
            this.__defineBooleans();
            this.__defineMappedEvents();
            this.__defineAnimationEvents();
            this.__determineCss();
        }
        
        /**
         * @name hasEvent
         * @memberof plat.Compat
         * @kind function
         * @access public
         * 
         * @description
         * Check whether or not an event exists.
         * 
         * @param {string} event The event to check the existence of.
         * 
         * @returns {boolean} Whether or not the event exists.
         */
        hasEvent(event: string): boolean {
            var events = this.__events,
                eventExists = events[event];

            if (isUndefined(eventExists)) {
                var element = this.$Document.createElement('div');
                if (event === 'input' && this.IE === 9) {
                    eventExists = events[event] = false;
                } else {
                    eventExists = events[event] = !isUndefined((<any>element)[('on' + event)]);
                }
            }

            return eventExists;
        }

        /**
         * @name __defineBooleans
         * @memberof plat.Compat
         * @kind function
         * @access private
         * 
         * @description
         * Define booleans.
         * 
         * @returns {void}
         */
        private __defineBooleans(): void {
            var $window = this.$Window,
                navigator = $window.navigator || <Navigator>{},
                userAgent = (navigator.userAgent || '').toLowerCase(),
                history = $window.history,
                def = (<any>$window).define,
                msA = (<any>$window).MSApp,
                android = parseInt((<any>/android (\d+)/.exec(userAgent) || [])[1], 10);

            this.isCompatible = isFunction(Object.defineProperty) && isFunction(this.$Document.querySelector);
            this.cordova = !isNull((<any>$window).cordova);
            this.pushState = !(isNull(history) || isNull(history.pushState));
            this.fileSupported = !(isUndefined((<any>$window).File) || isUndefined((<any>$window).FormData));
            this.amd = isFunction(def) && !isNull(def.amd);
            this.msApp = isObject(msA) && isFunction(msA.execUnsafeLocalFunction);
            this.indexedDb = !isNull($window.indexedDB);
            this.proto = isObject((<any>{}).__proto__);
            this.getProto = isFunction(Object.getPrototypeOf);
            this.setProto = isFunction((<any>Object).setPrototypeOf);
            this.hasTouchEvents = !isUndefined((<any>$window).ontouchstart);
            this.hasPointerEvents = !!navigator.pointerEnabled;
            this.hasMsPointerEvents = !!navigator.msPointerEnabled;

            if (isNumber(android)) {
                this.ANDROID = android;
                return;
            }

            var ie = parseInt((<any>/msie (\d+)/.exec(userAgent) || [])[1], 10) ||
                parseInt((<any>(/trident\/.*; rv:(\d+)/.exec(userAgent) || []))[1], 10);
            if (isNumber(ie)) {
                this.IE = ie;
            }
        }

        /**
         * @name __defineMappedEvents
         * @memberof plat.Compat
         * @kind function
         * @access private
         * 
         * @description
         * Define {@link plat.IMappedEvents|mapped events}
         * 
         * @returns {void}
         */
        private __defineMappedEvents(): void {
            if (this.hasPointerEvents) {
                this.mappedEvents = {
                    $touchstart: 'pointerdown',
                    $touchend: 'pointerup',
                    $touchmove: 'pointermove',
                    $touchcancel: 'pointercancel'
                };
            } else if (this.hasMsPointerEvents) {
                this.mappedEvents = {
                    $touchstart: 'MSPointerDown',
                    $touchend: 'MSPointerUp',
                    $touchmove: 'MSPointerMove',
                    $touchcancel: 'MSPointerCancel'
                };
            } else if (this.hasTouchEvents) {
                this.mappedEvents = {
                    $touchstart: 'touchstart',
                    $touchend: 'touchend',
                    $touchmove: 'touchmove',
                    $touchcancel: 'touchcancel'
                };
            } else {
                this.mappedEvents = {
                    $touchstart: 'mousedown',
                    $touchend: 'mouseup',
                    $touchmove: 'mousemove',
                    $touchcancel: null
                };
            }
        }

        /**
         * @name __defineAnimationEvents
         * @memberof plat.Compat
         * @kind function
         * @access private
         * 
         * @description
         * Define {@link plat.IAnimationEvents|animation events}
         * 
         * @returns {void}
         */
        private __defineAnimationEvents(): void {
            var documentElement = this.$Document.documentElement,
                styles = this.$Window.getComputedStyle(documentElement, ''),
                prefix: string;

            if (!isUndefined((<any>styles).OLink)) {
                prefix = 'o';
            } else {
                var matches = Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/);
                prefix = (isArray(matches) && matches.length > 1) ? matches[1] : '';
            }

            this.vendorPrefix = {
                lowerCase: prefix,
                css: prefix === '' ? '' : '-' + prefix + '-',
                js: prefix[0].toUpperCase() + prefix.slice(1)
            };

            if (prefix === 'webkit') {
                this.animationSupported = !isUndefined((<any>documentElement.style).WebkitAnimation);
                if (!this.animationSupported) {
                    this.animationEvents = {
                        $animation: '',
                        $animationStart: '',
                        $animationEnd: '',
                        $transition: '',
                        $transitionStart: '',
                        $transitionEnd: ''
                    };
                    return;
                }

                this.animationEvents = {
                    $animation: 'webkitAnimation',
                    $animationStart: 'webkitAnimationStart',
                    $animationEnd: 'webkitAnimationEnd',
                    $transition: 'webkitTransition',
                    $transitionStart: 'webkitTransitionStart',
                    $transitionEnd: 'webkitTransitionEnd'
                };
            } else {
                this.animationSupported = !isUndefined((<any>documentElement.style).animation);
                if (!this.animationSupported) {
                    this.animationEvents = {
                        $animation: '',
                        $animationStart: '',
                        $animationEnd: '',
                        $transition: '',
                        $transitionStart: '',
                        $transitionEnd: ''
                    };
                    return;
                }

                this.animationEvents = {
                    $animation: 'animation',
                    $animationStart: 'animationstart',
                    $animationEnd: 'animationend',
                    $transition: 'transition',
                    $transitionStart: 'transitionstart',
                    $transitionEnd: 'transitionend'
                };
            }
        }

        /**
         * @name __determineCss
         * @memberof plat.Compat
         * @kind function
         * @access private
         * 
         * @description
         * Determines whether or not platypus css styles exist.
         * 
         * @returns {void}
         */
        private __determineCss(): void {
            var $document = this.$Document,
                head = $document.head,
                element = $document.createElement('div');

            element.setAttribute(__Hide, '');
            head.insertBefore(element, null);

            var computedStyle = this.$Window.getComputedStyle(element),
                display = computedStyle.display,
                visibility = computedStyle.visibility;

            if (display === 'none' || visibility === 'hidden') {
                this.platCss = true;
            } else {
                this.platCss = false;
            }

            head.removeChild(element);
        }
    }

   /**
    * The Type for referencing the '$Compat' injectable as a dependency.
    */
    export function ICompat(): ICompat {
        return new Compat();
    }

    register.injectable(__Compat, ICompat);

    /**
     * @name ICompat
     * @memberof plat
     * @kind interface
     * 
     * @description
     * An object containing boolean values signifying browser 
     * and/or platform compatibilities.
     */
    export interface ICompat {
        /**
         * @name isCompatible
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Determines if the browser is modern enough to correctly 
         * run PlatypusTS.
         */
        isCompatible: boolean;

        /**
         * @name cordova
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether or not Cordova is defined. If it is, 
         * we hook up ALM events to Cordova's functions.
         */
        cordova: boolean;

        /**
         * @name pushState
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether window.history.pushState is defined.
         */
        pushState: boolean;

        /**
         * @name fileSupported
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether the File API is supported.
         */
        fileSupported: boolean;

        /**
         * @name amd
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Require is present. If it is, we assume 
         * it is going to be used and leave the loading of the app up 
         * to the developer.
         */
        amd: boolean;

        /**
         * @name msApp
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether we are in the contet of a Windows 8 app.
         */
        msApp: boolean;

        /**
         * @name indexedDb
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether indexedDB exists on the window.
         */
        indexedDb: boolean;

        /**
         * @name proto
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Object.prototype.__proto__ exists.
         */
        proto: boolean;

        /**
         * @name getProto
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Object.prototype.getPrototypeOf exists.
         */
        getProto: boolean;

        /**
         * @name setProto
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Signifies whether Object.prototype.setPrototypeOf exists.
         */
        setProto: boolean;

        /**
         * @name hasTouchEvents
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the current browser has touch events 
         * like touchstart, touchmove, touchend, etc.
         */
        hasTouchEvents: boolean;

        /**
         * @name hasPointerEvents
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the current browser has pointer events 
         * like pointerdown, MSPointerMove, pointerup, etc.
         */
        hasPointerEvents: boolean;

        /**
         * @name hasMsPointerEvents
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the current browser has touch events 
         * like MSPointerDown, touchmove, MSPointerUp, etc.
         */
        hasMsPointerEvents: boolean;

        /**
         * @name animationSupported
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether or not the browser supports animations.
         */
        animationSupported: boolean;

        /**
         * @name platCss
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {boolean}
         * 
         * @description
         * Whether the platypus.css file was included or not.
         */
        platCss: boolean;

        /**
         * @name mappedEvents
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {plat.IMappedEvents}
         * 
         * @description
         * An object containing the correctly mapped touch events for the browser.
         */
        mappedEvents: IMappedEvents;

        /**
         * @name animationEvents
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {plat.IAnimationEvents}
         * 
         * @description
         * An object containing the properly prefixed animation events.
         */
        animationEvents: IAnimationEvents;

        /**
         * @name vendorPrefix
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {plat.IVendorPrefix}
         * 
         * @description
         * An object containing information regarding any potential vendor prefix.
         */
        vendorPrefix: IVendorPrefix;

        /**
         * @name IE
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {number}
         * 
         * @description
         * The version of Internet Explorer being used. If not Internet Explorer, the value is undefined.
         */
        IE: number;

        /**
         * @name ANDROID
         * @memberof plat.ICompat
         * @kind property
         * @access public
         * 
         * @type {number}
         * 
         * @description
         * The version of Android being used. If not Android, the value is undefined.
         */
        ANDROID: number;

        /**
         * @name hasEvent
         * @memberof plat.ICompat
         * @kind function
         * @access public
         * 
         * @description
         * Check whether or not an event exists.
         * 
         * @param {string} event The event to check the existence of.
         * 
         * @returns {boolean} Whether or not the event exists.
         */
        hasEvent(event: string): boolean;
    }

    /**
     * @name IMappedEvents
     * @memberof plat
     * @kind interface
     * 
     * @extends {plat.IObject}
     * 
     * @description
     * Describes an object containing the correctly mapped touch events for the browser.
     */
    export interface IMappedEvents extends IObject<string> {
        /**
         * @name $touchstart
         * @memberof plat.IMappedEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * An event type for touch start.
         */
        $touchstart: string;

        /**
         * @name $touchend
         * @memberof plat.IMappedEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * An event type for touch end.
         */
        $touchend: string;

        /**
         * @name $touchmove
         * @memberof plat.IMappedEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * An event type for touch move.
         */
        $touchmove: string;

        /**
         * @name $touchcancel
         * @memberof plat.IMappedEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * An event type for touch cancel.
         */
        $touchcancel: string;
    }

    /**
     * @name IAnimationEvents
     * @memberof plat
     * @kind interface
     * 
     * @extends {plat.IObject}
     * 
     * @description
     * Describes an object containing the properly prefixed animation events.
     */
    export interface IAnimationEvents extends IObject<string> {
        /**
         * @name $animation
         * @memberof plat.IAnimationEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The animation identifier.
         */
        $animation: string;

        /**
         * @name $animationStart
         * @memberof plat.IAnimationEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The animation start event.
         */
        $animationStart: string;

        /**
         * @name $animationEnd
         * @memberof plat.IAnimationEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The animation end event.
         */
        $animationEnd: string;

        /**
         * @name $transition
         * @memberof plat.IAnimationEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The transition identifier.
         */
        $transition: string;

        /**
         * @name $transitionStart
         * @memberof plat.IAnimationEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The transition start event.
         */
        $transitionStart: string;

        /**
         * @name $transitionEnd
         * @memberof plat.IAnimationEvents
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The transition end event.
         */
        $transitionEnd: string;
    }

    /**
     * @name IVendorPrefix
     * @memberof plat
     * @kind interface
     * 
     * @extends {plat.IObject}
     * 
     * @description
     * Describes an object that contains information regarding the browser's 
     * vendor prefix.
     */
    export interface IVendorPrefix extends IObject<string> {
        /**
         * @name lowerCase
         * @memberof plat.IVendorPrefix
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The lowercase representation of the browser's vendor prefix.
         */
        lowerCase: string;

        /**
         * @name css
         * @memberof plat.IVendorPrefix
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The css representation of the browser's vendor prefix 
         * denoted by -{prefix}-.
         */
        css: string;

        /**
         * @name js
         * @memberof plat.IVendorPrefix
         * @kind property
         * @access public
         * 
         * @type {string}
         * 
         * @description
         * The JavaScript representation of the browser's vendor prefix 
         * denoted by it beginning with a capital letter.
         */
        js: string;
    }

    /**
     * @name Utils
     * @memberof plat
     * @kind class
     * 
     * @implements {plat.IUtils}
     * 
     * @description
     * An extensible class defining common utilities and helper functions.
     */
    export class Utils implements IUtils {
        /**
         * @name noop
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * An empty method for quickly creating dummy objects.
         * 
         * @returns {void}
         */
        noop(): void { }

        /**
         * @name extend
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Allows you to extend the properties of an object with any number 
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is only a shallow copy of
         * all the source objects to the destination object.
         * 
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the 
         * destination object.
         * 
         * @returns {any} The extended destination object.
         */
        extend(destination: any, ...sources: any[]): any {
            return extend.apply(null, [destination].concat(sources));
        }

        /**
         * @name deepExtend
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Allows you to extend the properties of an object with any number 
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is a deep copy of
         * all the source objects to the destination object.
         * 
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the 
         * destination object.
         * 
         * @returns {any} The extended destination object.
         */
        deepExtend(destination: any, ...sources: any[]): any {
            return extend.apply(null, [true, destination].concat(sources));
        }

        /**
         * @name clone
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Creates a copy of the passed-in object. If deep is true it will 
         * be a deep copy (duplicate), else nested objects/arrays will be copied by reference
         * and not duplicated.
         * 
         * @typeparam {any} T The type of object being cloned.
         * 
         * @param {T} obj The object to clone.
         * @param {boolean} deep? Whether or not it is a deep clone.
         * 
         * @returns {T} The cloned object.
         */
        clone<T>(obj: T, deep?: boolean): T {
            return _clone(obj, deep);
        }

        /**
         * @name isObject
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a type of Object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is an object, false otherwise.
         */
        isObject(obj: any): boolean {
            return isObject(obj);
        }

        /**
         * @name isWindow
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a window object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is the window, false otherwise.
         */
        isWindow(obj: any): boolean {
            return isWindow(obj);
        }

        /**
         * @name isDocument
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a document object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is the document, false otherwise.
         */
        isDocument(obj: any): boolean {
            return isDocument(obj);
        }

        /**
         * @name isNode
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a Node.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a Node, false otherwise.
         */
        isNode(obj: any): boolean {
            return isNode(obj);
        }

        /**
         * @name isDocumentFragment
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a DocumentFragment.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a DocumentFragment, false otherwise.
         */
        isDocumentFragment(obj: any): boolean {
            return isDocumentFragment(obj);
        }

        /**
         * @name isString
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a string.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a string, false otherwise.
         */
        isString(obj: any): boolean {
            return isString(obj);
        }

        /**
         * @name isRegExp
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a RegExp object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a RegExp object, false otherwise.
         */
        isRegExp(obj: any): boolean {
            return isRegExp(obj);
        }

        /**
         * @name isPromise
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a Promise object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a Promise object, false otherwise.
         */
        isPromise(obj: any): boolean {
            return isPromise(obj);
        }

        /**
         * @name isEmpty
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is empty. Useful for
         * checking for empty strings, arrays, or objects without keys.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if the object isEmpty (or null/undefined), 
         * false otherwise.
         */
        isEmpty(obj: any): boolean {
            return isEmpty(obj);
        }

        /**
         * @name isBoolean
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a boolean.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a boolean, false otherwise.
         */
        isBoolean(obj: any): boolean {
            return isBoolean(obj);
        }

        /**
         * @name isNumber
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a number.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a number, false otherwise.
         */
        isNumber(obj: any): boolean {
            return isNumber(obj);
        }

        /**
         * @name isFunction
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a function.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a function, false otherwise.
         */
        isFunction(obj: any): boolean {
            return isFunction(obj);
        }

        /**
         * @name isNull
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is null or undefined.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is null or undefined, false otherwise.
         */
        isNull(obj: any): boolean {
            return isNull(obj);
        }

        /**
         * @name isUndefined
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is undefined.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is undefined, false otherwise.
         */
        isUndefined(obj: any): boolean {
            return isUndefined(obj);
        }

        /**
         * @name isArray
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is an Array.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is an Array, false otherwise.
         */
        isArray(obj: any): boolean {
            return isArray(obj);
        }

        /**
         * @name isArrayLike
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it has array-like qualities.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj has array-like qualities (i.e. it is an
         * Array, string, arguments, or NodeList), false otherwise.
         */
        isArrayLike(obj: any): boolean {
            return isArrayLike(obj);
        }

        /**
         * @name isDate
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a Date object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a Date object, false otherwise.
         */
        isDate(obj: any): boolean {
            return isDate(obj);
        }

        /**
         * @name filter
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an array and a function to evaluate the properties in the array.
         * Returns a filtered array of objects resulting from evaluating the function.
         * 
         * @typeparam {any} T The type of objects contained in the Array being filtered.
         * 
         * @param {Array<T>} array The Array to filter.
         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties. 
         * Returns true if the property should be kept, false otherwise.
         * @param {any} context? Optional context with which to call the iterator.
         * 
         * @returns {Array<T>} An array of objects which evaluated to true with the iterator.
         */
        filter<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): Array<T>;
        /**
         * @name filter
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an object/array and a function to evaluate the properties in the object/array.
         * Returns a filtered array of objects resulting from evaluating the function.
         * 
         * @typeparam {any} T The type of objects contained in the Object/Array being filtered.
         * 
         * @param {any} obj The object to filter.
         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties. 
         * Returns true if the property should be kept, false otherwise.
         * @param {any} context? Optional context with which to call the iterator.
         * 
         * @returns {Array<T>} An array of objects which evaluated to true with the iterator.
         */
        filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T>;
        filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T> {
            return filter(obj, iterator, context);
        }

        /**
         * @name where
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in a list and object containing key/value pairs to search for in the list.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * 
         * @param {Array<T>} array The list used for searching for properties.
         * @param {any} properties An object containing key/value pairs to match with obj's values.
         * 
         * @returns {Array<T>} The matched values in obj.
         */
        where<T>(array: Array<T>, properties: any): Array<T>;
        /**
         * @name where
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in a list and object containing key/value pairs to search for in the list.
         * 
         * @typeparam {any} T The type of objects contained in the input Object.
         * 
         * @param {any} obj The object used for searching for properties.
         * @param {any} properties An object containing key/value pairs to match with obj's values.
         * 
         * @returns {Array<T>} The matched values in obj.
         */
        where<T>(obj: any, properties: any): Array<T>;
        where(obj: any, properties: any): Array<any> {
            return where(obj, properties);
        }

        /**
         * @name forEach
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an Array and a function to iterate over. Calls the iterator function with every property
         * in the Array, then returns the object.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * 
         * @param {Array<T>} array An Array.
         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {Array<T>} The array.
         */
        forEach<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => void, context?: any): Array<T>;
        /**
         * @name forEach
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an Array and a function to iterate over. Calls the iterator function with every property
         * in the Array, then returns the object.
         * 
         * @typeparam {any} T The type of objects contained in the input Object.
         * 
         * @param {any} obj An object.
         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {any} The input Object.
         */
        forEach<T>(obj: any, iterator: (value: T, key: string, obj: any) => void, context?: any): any;
        forEach<T>(obj: any, iterator: (value: T, key: any, obj: any) => void, context?: any): any {
            return forEach(obj, iterator, context);
        }

        /**
         * @name map
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The 
         * iterator can transform the object and return it. The returned values will be pushed to an Array and 
         * returned.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * @typeparam {any} U The type of objects contained in the transformed output Array.
         * 
         * @param {Array<T>} array An Array.
         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {Array<U>} The accumulated transformed values from the iterator.
         */
        map<T, U>(array: Array<T>, iterator: (value: T, index: number, obj: any) => U, context?: any): Array<U>;
        /**
         * @name map
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The 
         * iterator can transform the object and return it. The returned values will be pushed to an Array and 
         * returned.
         * 
         * @typeparam {any} T The type of objects contained in the input Object/Array.
         * @typeparam {any} U The type of objects contained in the transformed output Array.
         * 
         * @param {Array<T>} obj An Object.
         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {Array<U>} The accumulated transformed values from the iterator.
         */
        map<T, U>(obj: any, iterator: (value: T, key: string, obj: any) => U, context?: any): Array<U>;
        map<T, U>(obj: any, iterator: (value: T, key: any, obj: any) => U, context?: any): Array<U> {
            return map<T, U>(obj, iterator, context);
        }

        /**
         * @name pluck
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in an object and a property to extract from all of the object's values. Returns an array of
         * the 'plucked' values.
         * 
         * @typeparam {any} T The type of objects contained in the input Object/Array.
         * @typeparam {any} U The type of objects contained in the transformed output Array.
         * 
         * @param {any} obj An object.
         * @param {string} key The property to 'pluck' from each value in obj.
         * 
         * @returns {Array<U>} An array of 'plucked' values from obj.
         */
        pluck<T, U>(obj: any, key: string): Array<U> {
            return map<T, U>(obj, (value) => (<any>value)[key]);
        }

        /**
         * @name some
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.
         * Returns true if any of the iterators return true, otherwise returns false.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * 
         * @param {Array<T>} array An array.
         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {boolean} True if any calls to iterator return true, false otherwise.
         */
        some<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): boolean;
        /**
         * @name some
         * @memberof plat.Utils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.
         * Returns true if any of the iterators return true, otherwise returns false.
         * 
         * @typeparam {any} T The type of objects contained in the input Object/Array.
         * 
         * @param {Array<T>} obj An object.
         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {boolean} True if any calls to iterator return true, false otherwise.
         */
        some<T>(obj: any, iterator: (value: T, key: string, obj: any) => boolean, context?: any): boolean;
        some<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): boolean {
            return some<T>(obj, iterator, context);
        }

        /**
         * @name postpone
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until 
         * after the current call stack is clear. Equivalent to a setTimeout with a timeout of 0.
         * 
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         * 
         * @returns {plat.IRemoveListener} A function that will clear the timeout when called.
         */
        postpone(method: (...args: any[]) => void, args?: Array<any>, context?: any) {
            return defer(method, 0, args, context);
        }

        /**
         * @name defer
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until 
         * after the current call stack is clear. Equivalent to a setTimeout with the specified timeout value.
         * 
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {number} timeout The time (in milliseconds) to delay before calling the provided method
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         * 
         * @returns {plat.IRemoveListener} A function that will clear the timeout when called.
         */
        defer(method: (...args: any[]) => void, timeout: number, args?: Array<any>, context?: any) {
            return defer(method, timeout, args, context);
        }

        /**
         * @name uniqueId
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a prefix and returns a unique identifier string with the prefix preprended. If no prefix
         * is specified, none will be prepended.
         * 
         * @param {string} prefix? A string prefix to prepend tothe unique ID.
         * 
         * @returns {string} The prefix-prepended unique ID.
         */
        uniqueId(prefix?: string) {
            return uniqueId(prefix);
        }

        /**
         * @name camelCase
         * @memberof plat.Utils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a spinal-case, dot.case, or snake_case string and returns 
         * a camelCase string. Also can turn a string into camelCase with space 
         * as a delimeter.
         * 
         * @param {string} str The spinal-case, dot.case, or snake_case string.
         * 
         * @returns {string} The camelCase string.
         */
        camelCase(str: string) {
            return camelCase(str);
        }
    }

    /**
     * The Type for referencing the '$Utils' injectable as a dependency.
     */
    export function IUtils(): IUtils {
        return new Utils();
    }

    register.injectable(__Utils, IUtils);

    /**
     * @name IUtils
     * @memberof plat
     * @kind interface
     * 
     * @description
     * An object defining common utilities and helper functions.
     */
    export interface IUtils {
        /**
         * @name noop
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * An empty method for quickly creating dummy objects.
         * 
         * @returns {void}
         */
        noop(): void;

        /**
         * @name extend
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Allows you to extend the properties of an object with any number 
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is only a shallow copy of
         * all the source objects to the destination object.
         * 
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the 
         * destination object.
         * 
         * @returns {any} The extended destination object.
         */
        extend(destination: any, ...sources: any[]): any;

        /**
         * @name deepExtend
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Allows you to extend the properties of an object with any number 
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is a deep copy of
         * all the source objects to the destination object.
         * 
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the 
         * destination object.
         * 
         * @returns {any} The extended destination object.
         */
        deepExtend(destination: any, ...sources: any[]): any;

        /**
         * @name clone
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Creates a copy of the passed-in object. If deep is true it will 
         * be a deep copy (duplicate), else nested objects/arrays will be copied by reference
         * and not duplicated.
         * 
         * @typeparam {any} T The type of object being cloned.
         * 
         * @param {T} obj The object to clone.
         * @param {boolean} deep? Whether or not it is a deep clone.
         * 
         * @returns {T} The cloned object.
         */
        clone<T>(obj: T, deep?: boolean): T;

        /**
         * @name isObject
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a type of Object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is an object, false otherwise.
         */
        isObject(obj: any): boolean;

        /**
         * @name isWindow
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a window object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is the window, false otherwise.
         */
        isWindow(obj: any): boolean;

        /**
         * @name isDocument
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a document object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is the document, false otherwise.
         */
        isDocument(obj: any): boolean;

        /**
         * @name isNode
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a Node.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a Node, false otherwise.
         */
        isNode(obj: any): boolean;

        /**
         * @name isDocumentFragment
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a DocumentFragment.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a DocumentFragment, false otherwise.
         */
        isDocumentFragment(obj: any): boolean;

        /**
         * @name isString
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a string.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a string, false otherwise.
         */
        isString(obj: any): boolean;

        /**
         * @name isRegExp
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a RegExp object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a RegExp object, false otherwise.
         */
        isRegExp(obj: any): boolean;

        /**
         * @name isPromise
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a Promise object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a Promise object, false otherwise.
         */
        isPromise(obj: any): boolean;

        /**
         * @name isEmpty
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is empty. Useful for
         * checking for empty strings, arrays, or objects without keys.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if the object isEmpty (or null/undefined), 
         * false otherwise.
         */
        isEmpty(obj: any): boolean;

        /**
         * @name isBoolean
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a boolean.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a boolean, false otherwise.
         */
        isBoolean(obj: any): boolean;

        /**
         * @name isNumber
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a number.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a number, false otherwise.
         */
        isNumber(obj: any): boolean;

        /**
         * @name isFunction
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a function.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a function, false otherwise.
         */
        isFunction(obj: any): boolean;

        /**
         * @name isNull
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is null or undefined.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is null or undefined, false otherwise.
         */
        isNull(obj: any): boolean;

        /**
         * @name isUndefined
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is undefined.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is undefined, false otherwise.
         */
        isUndefined(obj: any): boolean;

        /**
         * @name isArray
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is an Array.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is an Array, false otherwise.
         */
        isArray(obj: any): boolean;

        /**
         * @name isArrayLike
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it has array-like qualities.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj has array-like qualities (i.e. it is an
         * Array, string, arguments, or NodeList), false otherwise.
         */
        isArrayLike(obj: any): boolean;

        /**
         * @name isDate
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in anything and determines if it is a Date object.
         * 
         * @param {any} obj Anything.
         * 
         * @returns {boolean} True if obj is a Date object, false otherwise.
         */
        isDate(obj: any): boolean;

        /**
         * @name filter
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an array and a function to evaluate the properties in the array.
         * Returns a filtered array of objects resulting from evaluating the function.
         * 
         * @typeparam {any} T The type of objects contained in the Array being filtered.
         * 
         * @param {Array<T>} array The Array to filter.
         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties.
         * Returns true if the property should be kept, false otherwise.
         * @param {any} context? Optional context with which to call the iterator.
         * 
         * @returns {Array<T>} An array of objects which evaluated to true with the iterator.
         */
        filter<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): Array<T>;
        /**
         * @name filter
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an object/array and a function to evaluate the properties in the object/array.
         * Returns a filtered array of objects resulting from evaluating the function.
         * 
         * @typeparam {any} T The type of objects contained in the Object/Array being filtered.
         * 
         * @param {any} obj The object to filter.
         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties. 
         * Returns true if the property should be kept, false otherwise.
         * @param {any} context? Optional context with which to call the iterator.
         * 
         * @returns {Array<T>} An array of objects which evaluated to true with the iterator.
         */
        filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T>;

        /**
         * @name where
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in a list and object containing key/value pairs to search for in the list.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * 
         * @param {Array<T>} array The list used for searching for properties.
         * @param {any} properties An object containing key/value pairs to match with obj's values.
         * 
         * @returns {Array<T>} The matched values in obj.
         */
        where<T>(array: Array<T>, properties: any): Array<T>;
        /**
         * @name where
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in a list and object containing key/value pairs to search for in the list.
         * 
         * @typeparam {any} T The type of objects contained in the input Object.
         * 
         * @param {any} obj The object used for searching for properties.
         * @param {any} properties An object containing key/value pairs to match with obj's values.
         * 
         * @returns {Array<T>} The matched values in obj.
         */
        where<T>(obj: any, properties: any): Array<T>;

        /**
         * @name forEach
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an Array and a function to iterate over. Calls the iterator function with every property
         * in the Array, then returns the object.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * 
         * @param {Array<T>} array An Array.
         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {Array<T>} The array.
         */
        forEach<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => void, context?: any): Array<T>;
        /**
         * @name forEach
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an Array and a function to iterate over. Calls the iterator function with every property
         * in the Array, then returns the object.
         * 
         * @typeparam {any} T The type of objects contained in the input Object.
         * 
         * @param {any} obj An object.
         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {any} The input Object.
         */
        forEach<T>(obj: any, iterator: (value: T, key: string, obj: any) => void, context?: any): any;

        /**
         * @name map
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The 
         * iterator can transform the object and return it. The returned values will be pushed to an Array and 
         * returned.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * @typeparam {any} U The type of objects contained in the transformed output Array.
         * 
         * @param {Array<T>} array An Array.
         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {Array<U>} The accumulated transformed values from the iterator.
         */
        map<T, U>(array: Array<T>, iterator: (value: T, index: number, obj: any) => U, context?: any): Array<U>;
        /**
         * @name map
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The 
         * iterator can transform the object and return it. The returned values will be pushed to an Array and 
         * returned.
         * 
         * @typeparam {any} T The type of objects contained in the input Object/Array.
         * @typeparam {any} U The type of objects contained in the transformed output Array.
         * 
         * @param {Array<T>} obj An Object.
         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {Array<U>} The accumulated transformed values from the iterator.
         */
        map<T, U>(obj: any, iterator: (value: T, key: string, obj: any) => U, context?: any): Array<U>;

        /**
         * @name pluck
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in an object and a property to extract from all of the object's values. Returns an array of
         * the 'plucked' values.
         * 
         * @typeparam {any} T The type of objects contained in the input Object/Array.
         * @typeparam {any} U The type of objects contained in the transformed output Array.
         * 
         * @param {any} obj An object.
         * @param {string} key The property to 'pluck' from each value in obj.
         * 
         * @returns {Array<U>} An array of 'plucked' values from obj.
         */
        pluck<T, U>(obj: any, key: string): Array<U>;

        /**
         * @name some
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.
         * Returns true if any of the iterators return true, otherwise returns false.
         * 
         * @typeparam {any} T The type of objects contained in the input Array.
         * 
         * @param {Array<T>} array An array.
         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {boolean} True if any calls to iterator return true, false otherwise.
         */
        some<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): boolean;
        /**
         * @name some
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.
         * Returns true if any of the iterators return true, otherwise returns false.
         * 
         * @typeparam {any} T The type of objects contained in the input Object/Array.
         * 
         * @param {Array<T>} obj An object.
         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.
         * @param {any} context? An optional context to bind to the iterator.
         * 
         * @returns {boolean} True if any calls to iterator return true, false otherwise.
         */
        some<T>(obj: any, iterator: (value: T, key: string, obj: any) => boolean, context?: any): boolean;

        /**
         * @name postpone
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until 
         * after the current call stack is clear. Equivalent to a setTimeout with a timeout of 0.
         * 
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         * 
         * @returns {plat.IRemoveListener} A function that will clear the timeout when called.
         */
        postpone(method: (...args: any[]) => void, args?: Array<any>, context?: any): IRemoveListener;

        /**
         * @name defer
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until 
         * after the current call stack is clear. Equivalent to a setTimeout with the specified timeout value.
         * 
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {number} timeout The time (in milliseconds) to delay before calling the provided method
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         * 
         * @returns {plat.IRemoveListener} A function that will clear the timeout when called.
         */
        defer(method: (...args: any[]) => void, timeout: number, args?: Array<any>, context?: any): IRemoveListener;

        /**
         * @name uniqueId
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a prefix and returns a unique identifier string with the prefix preprended. If no prefix
         * is specified, none will be prepended.
         * 
         * @param {string} prefix? A string prefix to prepend tothe unique ID.
         * 
         * @returns {string} The prefix-prepended unique ID.
         */
        uniqueId(prefix?: string): string;

        /**
         * @name camelCase
         * @memberof plat.IUtils
         * @kind function
         * @access public
         * 
         * @description
         * Takes in a spinal-case, dot.case, or snake_case string and returns 
         * a camelCase string. Also can turn a string into camelCase with space 
         * as a delimeter.
         * 
         * @param {string} str The spinal-case, dot.case, or snake_case string.
         * 
         * @returns {string} The camelCase string.
         */
        camelCase(str: string): string;
    }

    /**
     * @name IIterator
     * @memberof plat
     * @kind interface
     * 
     * @description
     * The Type for a {@link plat.Utils|Utils} iterator callback method.
     * 
     * @typeparam {any} T The value type used in the iterator callback.
     * @typeparam {any} U The return type of the iterator callback.
     */
    export interface IIterator<T, U> {
        /**
         * @memberof plat.IIterator
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * A method signature for {@link plat.IIterator|IIterator}.
         * 
         * @param {T} value The value for an object during an iteration.
         * @param {number} index The index where the value can be found.
         * @param {any} obj The object passed into the util method.
         * 
         * @returns {U} The returned value.
         */
        (value: T, index: number, obj: any): U;
        /**
         * @memberof plat.IIterator
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * A method signature for {@link plat.IIterator|IIterator}.
         * 
         * @param {T} value The value for an object during an iteration.
         * @param {string} key The key where the value can be found.
         * @param {any} obj The object passed into the util method.
         * 
         * @returns {U} The returned value.
         */
        (value: T, key: string, obj: any): U;
    }

    /**
     * The Type for referencing the '$Window' injectable as a dependency. 
     * Used so that the Window can be mocked.
     */
    export function Window(): Window {
        return window;
    }

    register.injectable(__Window, Window);

    /**
     * The Type for referencing the '$Document' injectable as a dependency. 
     * Used so that the Window can be mocked.
     */
    export function Document($Window?: Window): Document {
        return $Window.document;
    }

    register.injectable(__Document, Document, [__Window]);

    /**
     * @name expressions
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds classes and interfaces related to expression handling in platypus.
     */
    export module expressions {
        /**
         * @name Regex
         * @memberof plat.expressions
         * @kind class
         * 
         * @implements {plat.expressions.IRegex}
         * 
         * @description
         * A class for keeping track of commonly used regular expressions.
         */
        export class Regex implements IRegex {
            /**
             * @name markupRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for finding markup in a string.
             */
            markupRegex: RegExp;
            /**
             * @name argumentRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds the arguments in a method expression.
             * 
             * @example
             * // outputs ["('foo', 'bar', 'baz')", "'foo', 'bar', 'baz'"]
             * exec("myFunction('foo', 'bar', 'baz')");
             */
            argumentRegex = /\((.*)\)/;
            /**
             * @name aliasRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Given a string, finds the root alias name if that string is an
             * alias path.
             * 
             * @example
             *   // outputs ['context']
             *   exec('@context.foo');
             * 
             * @example
             * // outputs null
             * exec('@context');
             */
            aliasRegex = /[^@\.\[\(]+(?=[\.\[\(])/;
            /**
             * @name initialUrlRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds '/*.html' or '/*.htm' in a url. Useful for removing 
             * the html file out of the url.
             * 
             * @example
             * // outputs ['/index.html']
             * exec('http://localhost:8080/index.html');
             */
            initialUrlRegex = /\/[^\/]*\.(?:html|htm)/;
            /**
             * @name protocolRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds a protocol delimeter in a string (e.g. ://).
             */
            protocolRegex = /:\/\//;
            /**
             * @name invalidVariableRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Looks for any invalid variable syntax.
             */
            invalidVariableRegex = /[^a-zA-Z0-9@_$]/;
            /**
             * @name fileNameRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Grabs the file name from a file path.
             */
            fileNameRegex = /.*(?:\/|\\)/;
            /**
             * @name shiftedKeyRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Determines if a character is correlated with a shifted key code.
             */
            shiftedKeyRegex = /[A-Z!@#$%^&*()_+}{":?><|~]/;
        
            /**
             * @name newLineRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for matching or removing all newline characters.
             */
            get newLineRegex(): RegExp {
                return /\r|\n/g;
            }
        
            /**
             * @name optionalRouteRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds optional parameters in a route string.
             * 
             * @example
             * // outputs ['(/foo)', '/foo']
             * exec('(/foo)/bar');
             * 
             * // outputs ['(/foo)', '/foo']
             * exec('(/foo))');
             */
            get optionalRouteRegex(): RegExp {
                return /\((.*?)\)/g;
            }
        
            /**
             * @name namedParameterRouteRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds named parameters in a route string.
             * 
             * @example
             * // outputs [':foo']
             * exec('/:foo/bar')
             * 
             * // outputs [':foo']
             * exec('(/:foo)/bar');
             */
            get namedParameterRouteRegex(): RegExp {
                return /(\(\?)?:\w+/g;
            }
        
            /**
             * @name namedParameterRouteRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds an alphanumeric wildcard match in a route string.
             * 
             * @example
             * // outputs ['*bar']
             * exec('/foo/*bar/baz');
             */
            get wildcardRouteRegex(): RegExp {
                return /\*\w*/g;
            }
        
            /**
             * @name escapeRouteRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds invalid characters in a route string.
             * 
             * @example
             * // outputs ['?']
             * exec('/foo/bar?query=baz');
             */
            get escapeRouteRegex(): RegExp {
                return /[\-{}\[\]+?.,\\\^$|#\s]/g;
            }
        
            /**
             * @name camelCaseRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds delimeters for spinal-case, snake_case, and dot.case.
             * useful for converting to camelCase. Also can turn a string
             * into camelCase with space as a delimeter.
             * 
             * @example
             * // outputs ['-o', '-', 'o']
             * exec('plat-options');
             * 
             * // outputs ['.c', '.', 'c']
             * exec('plat.config');
             * 
             * // outputs ['_v', '_', 'v']
             * exec('plat_var');
             * 
             * // outputs [' W', ' ', 'W']
             * exec('Hello World');
             */
            get camelCaseRegex(): RegExp {
                return /([\-_\.\s])(\w+?)/g;
            }
        
            /**
             * @name whiteSpaceRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds all whitespace and newline characters 
             * not in string literals. Needs to be combined 
             * with string replace function using $1 argument.
             */
            get whiteSpaceRegex(): RegExp {
                return /("[^"]*?"|'[^']*?')|[\s\r\n\t\v]/g;
            }
        
            /**
             * @name quotationRegex
             * @memberof plat.expressions.Regex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds all single and double quotes.
             */
            get quotationRegex(): RegExp {
                return /'|"/g;
            }

            /**
             * @name constructor
             * @memberof plat.expressions.Regex
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.expressions.Regex|Regex}. Creates the markup regular expression.
             * 
             * @returns {plat.expressions.Regex}
             */
            constructor() {
                this.markupRegex = new RegExp(__startSymbol + '[\\S\\s]*' + __endSymbol);
            }
        }

        /**
         * The Type for referencing the '$Regex' injectable as a dependency.
         */
        export function IRegex(): IRegex {
            return new Regex();
        }

        register.injectable(__Regex, IRegex);

        /**
         * @name IRegex
         * @memberof plat.expressions
         * @kind interface
         * 
         * @description
         * An object containing commonly used regular expressions.
         */
        export interface IRegex {
            /**
             * @name newLineRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for matching or removing all newline characters.
             */
            newLineRegex: RegExp;

            /**
             * @name markupRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for finding markup in a string.
             */
            markupRegex: RegExp;

            /**
             * @name argumentRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds the arguments in a method expression.
             * 
             * @example
             * // outputs ["('foo', 'bar', 'baz')", "'foo', 'bar', 'baz'"]
             * exec("myFunction('foo', 'bar', 'baz')");
             */
            argumentRegex: RegExp;

            /**
             * @name aliasRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Given a string, finds the root alias name if that string is an
             * alias path.
             * 
             * @example
             *   // outputs ['context']
             *   exec('@context.foo');
             * 
             * @example
             * // outputs null
             * exec('@context');
             */
            aliasRegex: RegExp;

            /**
             * @name optionalRouteRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds optional parameters in a route string.
             * 
             * @example
             * // outputs ['(/foo)', '/foo']
             * exec('(/foo)/bar');
             * 
             * // outputs ['(/foo)', '/foo']
             * exec('(/foo))');
             */
            optionalRouteRegex: RegExp;

            /**
             * @name namedParameterRouteRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds named parameters in a route string.
             * 
             * @example
             * // outputs [':foo']
             * exec('/:foo/bar')
             * 
             * // outputs [':foo']
             * exec('(/:foo)/bar');
             */
            namedParameterRouteRegex: RegExp;

            /**
             * @name namedParameterRouteRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds an alphanumeric wildcard match in a route string.
             * 
             * @example
             * // outputs ['*bar']
             * exec('/foo/*bar/baz');
             */
            wildcardRouteRegex: RegExp;

            /**
             * @name escapeRouteRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds invalid characters in a route string.
             * 
             * @example
             * // outputs ['?']
             * exec('/foo/bar?query=baz');
             */
            escapeRouteRegex: RegExp;

            /**
             * @name initialUrlRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds '/*.html' or '/*.htm' in a url. Useful for removing 
             * the html file out of the url.
             * 
             * @example
             * // outputs ['/index.html']
             * exec('http://localhost:8080/index.html');
             */
            initialUrlRegex: RegExp;

            /**
             * @name protocolRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds a protocol delimeter in a string (e.g. ://).
             */
            protocolRegex: RegExp;

            /**
             * @name camelCaseRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds delimeters for spinal-case, snake_case, and dot.case.
             * useful for converting to camelCase. Also can turn a string
             * into camelCase with space as a delimeter.
             * 
             * @example
             * // outputs ['-o', '-', 'o']
             * exec('plat-options');
             * 
             * // outputs ['.c', '.', 'c']
             * exec('plat.config');
             * 
             * // outputs ['_v', '_', 'v']
             * exec('plat_var');
             * 
             * // outputs [' W', ' ', 'W']
             * exec('Hello World');
             */
            camelCaseRegex: RegExp;

            /**
             * @name whiteSpaceRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds all whitespace and newline characters 
             * not in string literals. Needs to be combined 
             * with string replace function using $1 argument.
             */
            whiteSpaceRegex: RegExp;

            /**
             * @name quotationRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {RegExp}
             * 
             * @description
             * Finds all single and double quotes.
             */
            quotationRegex: RegExp;

            /**
             * @name invalidVariableRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Looks for any invalid variable syntax.
             */
            invalidVariableRegex: RegExp;

            /**
             * @name fileNameRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Grabs the file name from a file path.
             */
            fileNameRegex: RegExp;

            /**
             * @name shiftedKeyRegex
             * @memberof plat.expressions.IRegex
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * Determines if a character is correlated with a shifted key code.
             */
            shiftedKeyRegex: RegExp;
        }

        /**
         * @name Tokenizer
         * @memberof plat.expressions
         * @kind class
         * 
         * @implements {plat.expressions.ITokenizer}
         * 
         * @description
         * A class that is responsible for taking in a JavaScript expression string and
         * finding all of its tokens (i.e. delimiters, operators, etc).
         */
        export class Tokenizer implements ITokenizer {
            /**
             * @name _input
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access protected
             * 
             * @type {string}
             * 
             * @description
             * The input string to tokenize.
             */
            _input: string;
        
            /**
             * @name __previousChar
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * The previous character during tokenization.
             */
            private __previousChar = '';
            /**
             * @name __variableRegex
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for determining if a potential variable is valid syntax.
             */
            private __variableRegex = (<expressions.IRegex>acquire(__Regex)).invalidVariableRegex;
            /**
             * @name __outputQueue
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {Array<plat.expressions.IToken>}
             * 
             * @description
             * A queue used for determining the output of the tokenization.
             */
            private __outputQueue: Array<IToken> = [];
            /**
             * @name __operatorStack
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {Array<plat.expressions.IToken>}
             * 
             * @description
             * A stack used for determining operator precedence and aiding with the evaluation 
             * operands.
             */
            private __operatorStack: Array<IToken> = [];
            /**
             * @name __argCount
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {Array<any>}
             * 
             * @description
             * A collection used for determining argument count for certain operations.
             */
            private __argCount: Array<any> = [];
            /**
             * @name __objArgCount
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {Array<any>}
             * 
             * @description
             * A collection used for determining argument count for certain object literal operations.
             */
            private __objArgCount: Array<number> = [];
            /**
             * @name __lastColonChar
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {Array<string>}
             * 
             * @description
             * The last character encountered while in an operation dealing with the colon operator. 
             * Needs to be an array due to the possibility of nested colon operations.
             */
            private __lastColonChar: Array<string> = [];
            /**
             * @name __lastCommaChar
             * @memberof plat.expressions.Tokenizer
             * @kind property
             * @access private
             * 
             * @type {Array<string>}
             * 
             * @description
             * The last character encountered while in an operation dealing with commas. 
             * Needs to be an array due to the possibility of nested comma operations.
             */
            private __lastCommaChar: Array<string> = [];
        
            /**
             * @name createTokens
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access public
             * 
             * @description
             * Takes in an expression string and outputs a tokenized collection of 
             * {@link plat.expressions.IToken|ITokens}.
             * 
             * @param {string} input The JavaScript expression string to tokenize.
             * 
             * @returns {Array<plat.expressions.IToken>} The tokenized collection of 
             * {@link plat.expressions.IToken|ITokens}.
             */
            createTokens(input: string): Array<IToken> {
                if (isNull(input)) {
                    return [];
                }

                this._input = input;

                var char: string,
                    length = input.length,
                    ternary = 0,
                    ternaryFound = false,
                    isSpace = this._isSpace,
                    isAlphaNumeric = this._isAlphaNumeric;

                for (var index = 0; index < length; index++) {
                    char = input[index];

                    // space
                    if (isSpace(char)) {
                        continue;
                    } else if (isAlphaNumeric(char)) {
                        index = this.__handleAplhaNumeric(index, char);
                    } else if (isDelimiter(char)) {
                        switch (char) {
                            case '.':
                                index = this.__handlePeriod(index, char);
                                break;
                            case '{':
                                this.__handleLeftBrace(char);
                                break;
                            case '}':
                                this.__handleRightBrace(char);
                                break;
                            case '[':
                                this.__handleLeftBracket(char);
                                break;
                            case ']':
                                this.__handleRightBracket(char);
                                break;
                            case '(':
                                this.__handleLeftParenthesis(char);
                                break;
                            case ')':
                                this.__handleRightParenthesis(char);
                                break;
                            case ',':
                                this.__handleComma(char);
                                break;
                            case '\'':
                            case '"':
                                index = this.__handleStringLiteral(index, char);
                                break;
                        }
                    } else if (isOperator(char)) {
                        switch (char) {
                            case '?':
                                ternaryFound = true;
                                ternary++;
                                this.__handleQuestion(char);
                                break;
                            case ':':
                                ternary = this.__handleColon(char, ternary);
                                break;
                            default:
                                index = this.__handleOtherOperator(index, char);
                        }
                        // semicolon throw error
                    } else if (char === ';') {
                        this._throwError('Unexpected semicolon');
                        return [];
                    }

                    this.__previousChar = char;
                }

                if (ternaryFound && (ternary > 0)) {
                    this._throwError('Improper ternary expression');
                    return [];
                } else if (this.__objArgCount.length > 0) {
                    this._throwError('Improper object literal');
                    return [];
                }

                this.__popRemainingOperators();
                var output = this.__outputQueue;
                this._resetTokenizer();

                return output;
            }

            /**
             * @name _checkType
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Determines character type.
             * 
             * @param {string} char The character to check.
             * @param {boolean} isNumberLike Whether or not the character resembles a number.
             * 
             * @returns {boolean} Whether or not the character corresponds with its type.
             */
            _checkType(char: string, isNumberLike: boolean): boolean {
                if (isNumberLike) {
                    return this._isNumeric(char);
                }

                return this._isAlphaNumeric(char);
            }
        
            /**
             * @name _lookAhead
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Looks ahead in the expression to group similar character types.
             * 
             * @param {string} char The current character in the expression string.
             * @param {number} index The current index in the expression string.
             * @param {boolean} isNumberLike Whether or not the character resembles a number.
             * 
             * @returns {string} The grouped characters.
             */
            _lookAhead(char: string, index: number, isNumberLike: boolean): string {
                var ch: string,
                    input = this._input,
                    maxLength = input.length;

                while (++index < maxLength) {
                    ch = input[index];
                    if (this._checkType(ch, isNumberLike)) {
                        char += ch;
                    } else {
                        break;
                    }
                }

                return char;
            }
        
            /**
             * @name _lookAheadForOperatorFn
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Looks ahead in the expression to try and complete the 
             * current operator.
             * 
             * @param {string} char The operator to find.
             * @param {number} index The current index in the expression string.
             * 
             * @returns {string} The completed current operator.
             */
            _lookAheadForOperatorFn(char: string, index: number): string {
                var ch: string,
                    fn = char,
                    input = this._input,
                    maxLength = input.length;

                while (++index < maxLength) {
                    ch = input[index];
                    fn += ch;

                    if (isOperator(fn)) {
                        char = fn;
                    } else {
                        break;
                    }
                }

                return char;
            }
        
            /**
             * @name _lookAheadForDelimiter
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Looks ahead in the expression until it comes to the ending 
             * character to try and complete a particular sequence 
             * (e.g. - a string literal). Also strips the first and last 
             * characters of the result (i.e. removes the delimiters).
             * 
             * @param {string} endChar The ending character.
             * @param {number} index The current index in the expression string.
             * 
             * @returns {string} The resultant inner character string between 
             * the first character and end character being looked ahead for.
             */
            _lookAheadForDelimiter(endChar: string, index: number): string {
                var char = '',
                    ch: string,
                    input = this._input,
                    maxLength = input.length;

                while ((++index < maxLength) && (ch = input[index]) !== endChar) {
                    char += ch;
                }

                return char;
            }
        
            /**
             * @name _popStackForVal
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Pops the operator stack onto the output queue until a particular 
             * operator value is reached.
             * 
             * @param {plat.expressions.IToken} topOperator The top of the operator stack.
             * @param {string} char The operator value being searched for.
             * @param {string} error The error to throw in the case that the expression 
             * is invalid.
             * 
             * @returns {void}
             */
            _popStackForVal(topOperator: IToken, char: string, error: string): void {
                var outputQueue = this.__outputQueue,
                    operatorStack = this.__operatorStack;

                while (topOperator.val !== char) {
                    outputQueue.push(operatorStack.shift());
                    topOperator = operatorStack[0];
                    if (operatorStack.length === 0) {
                        return this._throwError(error);
                    }
                }
            }
        
            /**
             * @name _isValEqual
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Check if the "val" property on an {@link plat.expressions.IToken|IToken} 
             * is present in a particular character string.
             * 
             * @param {plat.expressions.IToken} obj The {@link plat.expressions.IToken|IToken} 
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             * 
             * @returns {boolean} Whether or not the val is equal to the input character.
             */
            _isValEqual(obj: IToken, char: string): boolean {
                if (isNull(obj) || isNull(obj.val)) {
                    return isNull(char);
                } else if (obj.val === '') {
                    return char === '';
                }
                return char.indexOf(obj.val) !== -1;
            }
        
            /**
             * @name _isValUnequal
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Check if the "val" property on an {@link plat.expressions.IToken|IToken} 
             * is not present in a particular character string.
             * 
             * @param {plat.expressions.IToken} obj The {@link plat.expressions.IToken|IToken} 
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             * 
             * @returns {boolean} Whether or not the val is not equal to the input character.
             */
            _isValUnequal(obj: IToken, char: string): boolean {
                if (isNull(obj) || isNull(obj.val)) {
                    return !isNull(char);
                } else if (obj.val === '') {
                    return char !== '';
                }
                return char.indexOf(obj.val) === -1;
            }
        
            /**
             * @name _resetTokenizer
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Resets all the tokenizer's properties.
             * 
             * @returns {void}
             */
            _resetTokenizer(): void {
                this._input = null;
                this.__previousChar = '';
                this.__outputQueue = [];
                this.__operatorStack = [];
                this.__argCount = [];
                this.__objArgCount = [];
                this.__lastColonChar = [];
                this.__lastCommaChar = [];
            }
        
            /**
             * @name _resetTokenizer
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Throws a fatal exception in the case of an error.
             * 
             * @param {string} error The error message to throw.
             * 
             * @returns {void}
             */
            _throwError(error: string): void {
                var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                $exception.fatal(error + ' in ' + this._input, $exception.PARSE);
            }
        
            /**
             * @name _isNumeric
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Checks if a single character is numeric.
             * 
             * @param {string} char The character to check.
             * 
             * @returns {boolean} Whether or not the character is numeric.
             */
            _isNumeric(char: string): boolean {
                return ('0' <= char && char <= '9');
            }
        
            /**
             * @name _isSpace
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Checks if a single character is a space.
             * 
             * @param {string} char The character to check.
             * 
             * @returns {boolean} Whether or not the character is a space.
             */
            _isSpace(char: string): boolean {
                return (char === ' ' ||
                    char === '\r' ||
                    char === '\n' ||
                    char === '\t' ||
                    char === '\v' ||
                    char === '\u00A0');
            }
        
            /**
             * @name _isAlphaNumeric
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Checks if a single character is alphanumeric.
             * 
             * @param {string} char The character to check.
             * 
             * @returns {boolean} Whether or not the character is alphanumeric.
             */
            _isAlphaNumeric(char: string): boolean {
                return ('a' <= char && char <= 'z' ||
                    'A' <= char && char <= 'Z' ||
                    '0' <= char && char <= '9' ||
                    '@' === char ||
                    '_' === char ||
                    '$' === char);
            }
        
            /**
             * @name _isStringValidVariable
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access protected
             * 
             * @description
             * Checks if a string has proper JavaScript variable syntax.
             * 
             * @param {string} input The string to check.
             * 
             * @returns {boolean} Whether or not the input string could be a valid 
             * JavaScript variable.
             */
            _isStringValidVariable(input: string): boolean {
                return !this.__variableRegex.test(input);
            }

            /**
             * @name __handleAplhaNumeric
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing an alphanumeric character.
             * 
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             * 
             * @returns {number} The new index to pick up tokenization from.
             */
            private __handleAplhaNumeric(index: number, char: string): number {
                var isNumberLike = this._isNumeric(char),
                    lookAhead = this._lookAhead(char, index, isNumberLike);

                this.__outputQueue.push(isNumberLike ? ({ val: Number(lookAhead), args: 0 }) :
                    <IToken>({ val: lookAhead, args: -1 }));

                return index + lookAhead.length - 1;
            }

            /**
             * @name __handlePeriod
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "." character.
             * 
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             * 
             * @returns {number} The new index to pick up tokenization from.
             */
            private __handlePeriod(index: number, char: string): number {
                var outputQueue = this.__outputQueue,
                    operatorStack = this.__operatorStack,
                    topOutputLength = outputQueue.length - 1,
                    previousChar = this.__previousChar,
                    lookAhead: string;

                // if output queue is null OR space or operator or ( or , before .
                if (topOutputLength < 0 ||
                    this._isSpace(previousChar) ||
                    !isNull(OPERATORS[previousChar]) ||
                    previousChar === '(' ||
                    previousChar === ',') {
                    lookAhead = this._lookAhead(char, index, true);
                    index += lookAhead.length - 1;
                    outputQueue.push({ val: parseFloat(lookAhead), args: 0 });
                } else if (!(isNull(outputQueue[topOutputLength]) ||
                    !isNumber(Number(outputQueue[topOutputLength].val)) ||
                    this._isValEqual(outputQueue[topOutputLength - 1], char))) {
                    lookAhead = this._lookAhead(char, index, true);
                    index += lookAhead.length - 1;
                    outputQueue[topOutputLength].val += parseFloat(lookAhead);
                } else if (this._isValEqual(operatorStack[0], char)) {
                    outputQueue.push({ val: char, args: 0 });
                } else {
                    operatorStack.unshift({ val: char, args: 0 });
                }

                return index;
            }
            /**
             * @name __handleLeftBrace
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "{" character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleLeftBrace(char: string): void {
                this.__operatorStack.unshift({ val: char, args: 0 });
                this.__objArgCount.push(0);
                this.__lastColonChar.push(char);
                this.__lastCommaChar.push(char);
            }
            /**
             * @name __handleRightBrace
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "}" character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleRightBrace(char: string): void {
                var operatorStack = this.__operatorStack,
                    topOperator = operatorStack[0],
                    lastArgCount = this.__objArgCount.pop();

                if (isNull(topOperator)) {
                    return this._throwError('Improper object literal');
                }

                this._popStackForVal(topOperator, '{', 'Improper object literal');

                // pop left brace off stack
                operatorStack.shift();

                this.__lastColonChar.pop();
                this.__lastCommaChar.pop();

                this.__outputQueue.push({ val: '{}', args: lastArgCount });
            }
            /**
             * @name __handleLeftBracket
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "[" character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleLeftBracket(char: string): void {
                var previousChar = this.__previousChar,
                    operatorStack = this.__operatorStack;

                if (this._isValEqual(operatorStack[0], '.')) {
                    this.__outputQueue.push(operatorStack.shift());
                }

                operatorStack.unshift({ val: char, args: 0 });

                this.__argCount.push({
                    num: 0,
                    isArray: !(previousChar === ']' ||
                    previousChar === ')' ||
                    this._isAlphaNumeric(previousChar))
                });

                this.__lastCommaChar.push(char);
            }
            /**
             * @name __handleRightBracket
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "]" character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleRightBracket(char: string): void {
                var operatorStack = this.__operatorStack,
                    topOperator = operatorStack[0],
                    lastArgCountObj = this.__argCount.pop();

                if (isNull(topOperator) || isNull(lastArgCountObj)) {
                    return this._throwError('Brackets mismatch');
                }

                if (!lastArgCountObj.isArray) {
                    lastArgCountObj.num--;
                }

                this._popStackForVal(topOperator, '[', 'Brackets mismatch');

                // pop left bracket off stack
                operatorStack.shift();

                this.__lastCommaChar.pop();
                // check if function on top of stack
                this.__outputQueue.push({
                    val: '[]',
                    args: (this.__previousChar === '[') ? -1 : lastArgCountObj.num + 1
                });
            }
            /**
             * @name __handleLeftParenthesis
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "(" character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleLeftParenthesis(char: string): void {
                var previousChar = this.__previousChar,
                    operatorStack = this.__operatorStack;

                if (this._isAlphaNumeric(previousChar) || previousChar === ']' || previousChar === ')') {
                    var outputQueue = this.__outputQueue,
                        topOutput = outputQueue[outputQueue.length - 1];

                    if (this._isValEqual(topOutput, '[]')) {
                        operatorStack.unshift(outputQueue.pop());
                        operatorStack.unshift(outputQueue.pop());
                    } else if (!(this._isValEqual(topOutput, '()') || this._isNumeric(topOutput.val))) {
                        operatorStack.unshift(outputQueue.pop());
                    }

                    this.__argCount.push({ num: 0 });
                }

                operatorStack.unshift({ val: char, args: 0 });
                this.__lastCommaChar.push(char);
            }
            /**
             * @name __handleRightParenthesis
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a ")" character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleRightParenthesis(char: string): void {
                var operatorStack = this.__operatorStack,
                    topOperator = operatorStack[0],
                    localArgCountObj = this.__argCount.pop();

                if (isNull(topOperator)) {
                    return this._throwError('Parentheses mismatch');
                }

                this._popStackForVal(topOperator, '(', 'Parentheses mismatch');

                // pop left parenthesis off stack
                operatorStack.shift();

                this.__lastCommaChar.pop();

                // check if function on top of stack
                if (!isNull(localArgCountObj)) {
                    var localArgNum = localArgCountObj.num;
                    if (this.__previousChar === '(') {
                        if (this.__removeFnFromStack(localArgNum)) {
                            this.__outputQueue.push({
                                val: '()',
                                args: 0
                            });
                        }
                        return;
                    } else if (this.__removeFnFromStack(localArgNum + 1)) {
                        this.__outputQueue.push({
                            val: '()',
                            args: (localArgNum + 1)
                        });
                    }
                }
            }
            /**
             * @name __handleComma
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "," character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleComma(char: string): void {
                var lastCommaArray = this.__lastCommaChar,
                    lastCommaArg = lastCommaArray[lastCommaArray.length - 1];

                if (lastCommaArg === '(' || lastCommaArg === '[') {
                    var argCountArray = this.__argCount,
                        length = argCountArray.length;

                    if (length > 0) {
                        // increment deepest fn count (don't need to increment obj count because we increment with colon)
                        argCountArray[length - 1].num++;
                    } else {
                        return this._throwError('Mismatch with ' + lastCommaArg);
                    }
                }

                var topOperator = this.__operatorStack[0];
                if (isNull(topOperator)) {
                    return this._throwError('Unexpected comma');
                }

                this._popStackForVal(topOperator, lastCommaArg, 'Unexpected comma');
            }
            /**
             * @name __handleStringLiteral
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a string literal.
             * 
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             * 
             * @returns {number} The new index to pick up tokenization from.
             */
            private __handleStringLiteral(index: number, char: string): number {
                var lookAhead = this._lookAheadForDelimiter(char, index),
                    operatorStack = this.__operatorStack;

                if (this._isValEqual(operatorStack[0], '([')) {
                    operatorStack.unshift({ val: lookAhead, args: 0 });
                } else {
                    this.__outputQueue.push({ val: lookAhead, args: 0 });
                }
                return index + lookAhead.length + 1;
            }

            /**
             * @name __handleQuestion
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a "?" character.
             * 
             * @param {string} char The current char.
             * 
             * @returns {void}
             */
            private __handleQuestion(char: string): void {
                this.__lastColonChar.push(char);
                this.__determinePrecedence(char);
            }
            /**
             * @name __handleColon
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing a ":" character.
             * 
             * @param {string} char The current char.
             * @param {number} ternary The current ternary counter. Increments when a ternary is found, 
             * decrements when a ternary is completed. It can be very useful when there is nested ternaries.
             * 
             * @returns {number} The potentially modified ternary counter.
             */
            private __handleColon(char: string, ternary: number): number {
                var lastColonCharArray = this.__lastColonChar,
                    lastColonCharacter = lastColonCharArray[lastColonCharArray.length - 1],
                    outputQueue = this.__outputQueue;

                if (lastColonCharacter === '?') {
                    var operatorStack = this.__operatorStack,
                        topOperator = operatorStack[0];

                    if (isNull(topOperator)) {
                        this._throwError('Ternary mismatch');
                        return;
                    }

                    ternary--;
                    // pop latest colon char off queue
                    lastColonCharArray.pop();

                    this._popStackForVal(topOperator, '?', 'Ternary mismatch');

                    outputQueue.push(operatorStack.shift());
                    operatorStack.unshift({ val: char, args: 0 });
                } else if (lastColonCharacter === '{') {
                    var objArgCount = this.__objArgCount,
                        outputLast = outputQueue.length - 1;

                    objArgCount[objArgCount.length - 1]++;

                    if (outputLast < 0) {
                        this._throwError('Unexpected colon');
                        return;
                    }

                    outputQueue[outputLast].args = 1;
                } else {
                    this._throwError('Unexpected colon');
                    return;
                }

                return ternary;
            }
            /**
             * @name __handleOtherOperator
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Handles tokenizing all other operators.
             * 
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             * 
             * @returns {number} The new index to pick up tokenization from.
             */
            private __handleOtherOperator(index: number, char: string): number {
                var lookAhead = this._lookAheadForOperatorFn(char, index);
                this.__determinePrecedence(lookAhead);

                return index + lookAhead.length - 1;
            }
            /**
             * @name __popRemainingOperators
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Pops operators left on the operator stack onto the output queue 
             * checking for mismatches.
             * 
             * @returns {void}
             */
            private __popRemainingOperators(): void {
                var outputQueue = this.__outputQueue,
                    operatorStack = this.__operatorStack,
                    topOperator: IToken,
                    topOperatorVal: any;

                while (operatorStack.length > 0) {
                    topOperator = operatorStack.shift();
                    topOperatorVal = topOperator.val;
                    if (topOperatorVal === '(' || topOperatorVal === ')') {
                        return this._throwError('Parentheses mismatch');
                    }

                    outputQueue.push(topOperator);
                }
            }

            /**
             * @name __determineOperator
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Grabs essential token details for a given operator.
             * 
             * @param {string} operator The operator whose details are being requested.
             * 
             * @returns {plat.expressions.ITokenDetails} Essential information regarding the 
             * operator including precedence, associativity, and an evaluation function denoted as 
             * an {@link plat.expressions.ITokenDetails|ITokenDetails} object.
             */
            private __determineOperator(operator: string): ITokenDetails {
                switch (operator) {
                    case '+':
                    case '-':
                        if (this.__outputQueue.length === 0 || isOperator(this.__previousChar)) {
                            return OPERATORS['u' + operator];
                        }
                    default:
                        return OPERATORS[operator];
                }
            }
            /**
             * @name __determinePrecedence
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Determines the precedence of a given operator in relation to other operators 
             * in the operator stack and places it in the operator stack.
             * 
             * @param {string} operator The operator whose precedence is being determined.
             * 
             * @returns {void}
             */
            private __determinePrecedence(operator: string): void {
                var determined = false,
                    operatorFn = this.__determineOperator(operator),
                    operatorPrecedence = operatorFn.precedence,
                    isLtR = operatorFn.associativity === 'ltr',
                    operatorStack = this.__operatorStack,
                    outputQueue = this.__outputQueue,
                    firstArrayOperator: ITokenDetails,
                    firstArrayVal: any;

                if (operatorStack.length === 0) {
                    operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
                    return;
                }

                do {
                    firstArrayVal = operatorStack[0].val;
                    if (firstArrayVal === '.') {
                        outputQueue.push(operatorStack.shift());
                        continue;
                    }

                    firstArrayOperator = OPERATORS[firstArrayVal];
                    if (!(isNull(firstArrayOperator) ||
                        !(firstArrayOperator.precedence < operatorPrecedence ||
                        (isLtR && firstArrayOperator.precedence === operatorPrecedence)))) {
                        outputQueue.push(operatorStack.shift());
                    } else {
                        operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
                        return;
                    }
                } while (operatorStack.length > 0);

                operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
            }
            /**
             * @name __removeFnFromStack
             * @memberof plat.expressions.Tokenizer
             * @kind function
             * @access private
             * 
             * @description
             * Removes a reference to a function that is present in the operator stack and places 
             * it in the output queue.
             * 
             * @param {number} argCount The current local argument count used with functions, 
             * arrays, and object literals.
             * 
             * @returns {boolean} Whether or not the function had at least one argument.
             */
            private __removeFnFromStack(argCount: number): boolean {
                var outputQueue = this.__outputQueue,
                    operatorStack = this.__operatorStack,
                    topOperator = operatorStack[0],
                    isValEqual = this._isValEqual,
                    isValUnequal = this._isValUnequal,
                    fnToken: IToken,
                    atLeastOne = false;

                while (!isNull(topOperator) &&
                    isValUnequal(topOperator, '([') &&
                    (this._isStringValidVariable(topOperator.val) ||
                    isValEqual(topOperator.val, '.[]') ||
                    isAccessor(topOperator.val))) {
                    fnToken = operatorStack.shift();
                    if (!(fnToken.args !== -1 || isValEqual(fnToken, '.[]'))) {
                        fnToken.args = -2;
                    }
                    outputQueue.push(fnToken);
                    topOperator = operatorStack[0];
                    atLeastOne = true;
                }

                if (!(atLeastOne || isValUnequal(outputQueue[outputQueue.length - argCount - 1], '()'))) {
                    atLeastOne = true;
                }

                return atLeastOne;
            }
        }

        /**
         * The Type for referencing the '$Tokenizer' injectable as a dependency.
         */
        export function ITokenizer(): ITokenizer {
            return new Tokenizer();
        }

        register.injectable(__Tokenizer, ITokenizer);

        /**
         * @name ITokenizer
         * @memberof plat.expressions
         * @kind interface
         * 
         * @description
         * Describes an object used to find tokens for an expression and create 
         * {@link plat.expressions.ITokens|ITokens}.
         */
        export interface ITokenizer {
            /**
             * @name createTokens
             * @memberof plat.expressions.ITokenizer
             * @kind function
             * @access public
             * 
             * @description
             * Takes in an expression string and outputs a tokenized collection of 
             * {@link plat.expressions.IToken|ITokens}.
             * 
             * @param {string} input The JavaScript expression string to tokenize.
             * 
             * @returns {Array<plat.expressions.IToken>} The tokenized collection of 
             * {@link plat.expressions.IToken|ITokens}.
             */
            createTokens(input: string): Array<IToken>;
        }
    
        /**
         * @name IToken
         * @memberof plat.expressions
         * @kind interface
         * 
         * @description
         * Describes a single token in a string expression.
         */
        export interface IToken {
            /**
             * @name val
             * @memberof plat.expressions.IToken
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The string or number value of the token.
             */
            val: any;
        
            /**
             * @name val
             * @memberof plat.expressions.IToken
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * Denotes the type of token, as well as the number
             * of arguments for a function if it is the token.
             * 
             * @remarks
             * If -2: Denotes a function name unless indexed into with [].
             * If -1: Denotes a variable or empty array literal.
             * If 0: Denotes a number, keyword, object indexer (.[]), string literal,
             *  function with 0 arguments, ternary expression, or empty object literal
             * If 1: Denotes a function type with 1 argument, a property on an object literal,
             *  an object literal with 1 property, or an array literal with 1 entry.
             * If > 1: Denotes a function type with args arguments, an object literal with
             *  args properties, or an array literal with args entries.
             */
            args: number;
        }
    
        /**
         * @name ITokenDetails
         * @memberof plat.expressions
         * @kind interface
         * 
         * @description
         * Provides all the necessary details on how to evaluate a token.
         */
        export interface ITokenDetails {
            /**
             * @name precedence
             * @memberof plat.expressions.ITokenDetails
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The precedence that this token takes with respect to the 
             * evaluation order.
             */
            precedence: number;
        
            /**
             * @name associativity
             * @memberof plat.expressions.ITokenDetails
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Whether or not the token associates with the expression on
             * their left or right.
             */
            associativity: string;
        
            /**
             * @name fn
             * @memberof plat.expressions.ITokenDetails
             * @kind property
             * @access public
             * 
             * @type {Function}
             * 
             * @description
             * A function used to evaluate an operator expression.
             */
            fn: Function;
        }

        /**
         * @name Parser
         * @memberof plat.expressions
         * @kind class
         * 
         * @implements {plat.expressions.IParser}
         * 
         * @description
         * A class for parsing JavaScript expression strings and creating 
         * {@link plat.expressions.IParsedExpression|IParsedExpressions}.
         */
        export class Parser implements IParser {
            /**
             * @name $Tokenizer
             * @memberof plat.expressions.Parser
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.ITokenizer}
             * 
             * @description
             * Reference to the {@link plat.expressions.ITokenizer|ITokenizer} injectable.
             */
            $Tokenizer: ITokenizer = acquire(__Tokenizer);

            /**
             * @name _tokens
             * @memberof plat.expressions.Parser
             * @kind property
             * @access protected
             * 
             * @type {Array<plat.expressions.IToken>}
             * 
             * @description
             * A single expression's token representation created by a {@link plat.expressions.ITokenizer|ITokenizer}.
             */
            _tokens: Array<IToken> = [];
        
            /**
             * @name __cache
             * @memberof plat.expressions.Parser
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<plat.expressions.IParsedExpression>}
             * 
             * @description
             * An expression cache. Used so that a JavaScript expression is only ever parsed once.
             */
            private __cache: IObject<IParsedExpression> = {};
            /**
             * @name __codeArray
             * @memberof plat.expressions.Parser
             * @kind property
             * @access private
             * 
             * @type {Array<string>}
             * 
             * @description
             * A dynamically built string array that represents the evaluation function.
             */
            private __codeArray: Array<string> = [];
            /**
             * @name __identifiers
             * @memberof plat.expressions.Parser
             * @kind property
             * @access private
             * 
             * @type {Array<string>}
             * 
             * @description
             * A list of all the identifiers discovered in the JavaScript expression string.
             */
            private __identifiers: Array<string> = [];
            /**
             * @name __tempIdentifiers
             * @memberof plat.expressions.Parser
             * @kind property
             * @access private
             * 
             * @type {Array<string>}
             * 
             * @description
             * A temporary list of identifiers found used to build and evaluate each actual identifier.
             */
            private __tempIdentifiers: Array<string> = [];
            /**
             * @name __aliases
             * @memberof plat.expressions.Parser
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<boolean>}
             * 
             * @description
             * An object whose keys represent a list of all unique aliases found in the JavaScript expression string.
             */
            private __aliases: IObject<boolean> = {};

            /**
             * @name parse
             * @memberof plat.expressions.Parser
             * @kind function
             * @access public
             * 
             * @description
             * Parses a JavaScript expression string.
             * 
             * @param {string} expression The JavaScript expression string to parse.
             * 
             * @returns {plat.expressions.IParsedExpression} The parsed expression containing detailed 
             * information about the expression as well as a way to evaluate its value.
             */
            parse(expression: string): IParsedExpression {
                var parsedObject = this.__cache[expression];

                if (!isNull(parsedObject)) {
                    return parsedObject;
                }

                this._tokens = this.$Tokenizer.createTokens(expression);

                parsedObject = this._evaluate(expression);

                var identifiers = parsedObject.identifiers;
                if (identifiers.length === 0) {
                    var noModel = parsedObject.evaluate(null);
                    parsedObject.evaluate = () => noModel;
                }

                this.__cache[expression] = parsedObject;

                return parsedObject;
            }
        
            /**
             * @name clearCache
             * @memberof plat.expressions.Parser
             * @kind function
             * @access public
             * 
             * @description
             * If a key is passed in, it clears that single value in the expression cache. If no 
             * key is present, the entire expression cache will be cleared.
             * 
             * @param {string} key? An optional key that will clear its stored value in the expression 
             * cache if passed in.
             * 
             * @returns {void}
             */
            clearCache(key?: string): void {
                if (isString(key)) {
                    deleteProperty(this.__cache, key);
                    return;
                }

                this.__cache = {};
            }
        
            /**
             * @name _evaluate
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Evaluate the current {@link plat.expressions.IToken|IToken} array.
             * 
             * @param {string} expression The JavaScript expression to evaluate.
             * 
             * @returns {plat.expressions.IParsedExpression} The parsed expression containing detailed 
             * information about the expression as well as a way to evaluate its value.
             */
            _evaluate(expression: string): IParsedExpression {
                var tokens = this._tokens,
                    length = tokens.length,
                    tempIdentifiers = this.__tempIdentifiers,
                    codeArray = this.__codeArray,
                    codeStr = '',
                    useLocalContext = false,
                    tokenObj: IToken,
                    token: any,
                    args: number;

                for (var index = 0; index < length; index++) {
                    tokenObj = tokens[index];
                    token = tokenObj.val;
                    args = tokenObj.args;

                    // check if its an accessor
                    if (isAccessor(token)) {
                        switch (token) {
                            case '()':
                                useLocalContext = this.__handleFunction(index, args, useLocalContext);
                                break;
                            case '{}':
                                codeArray.push(this.__convertObject(args));
                                tempIdentifiers.push('.');
                                break;
                            default:
                                // handle empty array
                                if (args < 0) {
                                    codeArray.push('[]');
                                    tempIdentifiers.push('.');
                                // handle array literal
                                } else if (args > 0) {
                                    codeArray.push(this.__convertArrayLiteral(args));
                                    tempIdentifiers.push('.');
                                } else {
                                    useLocalContext = this.__indexIntoObject(index, token, useLocalContext);
                                }
                                break;
                        }
                    // check if its an operator
                    } else if (isOperator(token)) {
                        switch (token) {
                            case '?':
                                this.__handleQuestion();
                                break;
                            case ':':
                                this.__handleColon();
                                break;
                            case '+':
                            case '-':
                                if (args === 1) {
                                    this.__handleOperator('u' + token, args);
                                    break;
                                }
                            default:
                                // check if string literal
                                if (args === 0) {
                                    codeStr = this.__convertPrimitive(index, token, args);
                                    codeArray.push(codeStr);
                                    break;
                                }

                                this.__handleOperator(token, args);
                                break;
                        }
                    // its either function, object, or primitive
                    } else {
                        // potential function or object to index into
                        if (args < 0) {
                            codeStr = this.__convertFunction(index, token, useLocalContext);
                        // primitive
                        } else {
                            codeStr = this.__convertPrimitive(index, token, args);
                        }
                        codeArray.push(codeStr);
                    }
                }

                // move the rest of the tempIdentifiers to the identifiers
                this._popRemainingIdentifiers();
                // make the identifiers array unqiue entries only
                this._makeIdentifiersUnique();

                var parsedExpression: IParsedExpression = {
                    evaluate: <(context: any, aliases?: any) => any>new Function('context', 'aliases',
                        'var initialContext;' +
                        'return ' + (codeArray.length === 0 ? ('"' + expression + '"') : codeArray.join('')) + ';'),
                    expression: expression,
                    identifiers: this.__identifiers.slice(0),
                    aliases: Object.keys(this.__aliases)
                };

                // reset parser's properties
                this._resetParser();

                return parsedExpression;
            }
        
            /**
             * @name __convertPrimitive
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles a token that is a primitive value.
             * 
             * @param {number} index The current index in the {@link plat.expressions.IToken|IToken} array.
             * @param {string} token The current {@link plat.expressions.IToken|IToken} value.
             * @param {number} args The current {@link plat.expressions.IToken|IToken} args.
             * 
             * @returns {string} The correctly evaluated primitive.
             */
            private __convertPrimitive(index: number, token: string, args: number): string {
                if (args > 0) {
                    this.__tempIdentifiers.push('.');
                    return token;
                }

                var castTokenIsNumberLike = isNumber(Number(token)),
                    peek = this._peek(index),
                    isPeekIndexer = !(isNull(peek) || peek.args >= 1),
                    isValEqual = this._isValEqual;

                if (isKeyword(token) ||
                    (isString(token) &&
                    (castTokenIsNumberLike ||
                    this._isValUnequal(peek, '[]()') ||
                    (isValEqual(peek, '[]') &&
                    !isPeekIndexer)))) {
                    this.__tempIdentifiers.push('.');
                    return '"' + token + '"';
                } else {
                    if (!castTokenIsNumberLike ||
                        (isValEqual(peek, '.[]') &&
                        isPeekIndexer)) {
                        this.__tempIdentifiers.push(token);
                    } else {
                        this.__tempIdentifiers.push('.');
                    }
                    return token;
                }
            }
            /**
             * @name __convertFunction
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles a potential function or object that needs to be indexed into.
             * 
             * @param {number} index The current index in the {@link plat.expressions.IToken|IToken} array.
             * @param {string} token The current {@link plat.expressions.IToken|IToken} value.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             * 
             * @returns {string} The correctly evaluated object or function represented as a string.
             */
            private __convertFunction(index: number, token: string, useLocalContext: boolean): string {
                if (token[0] === '@') {
                    this.__aliases[token.slice(1)] = true;
                } else if (isKeyword(token)) {
                    this.__tempIdentifiers.push('.');
                    return token;
                }

                var nextToken = this._peek(index),
                    isValEqual = this._isValEqual;

                if (isValEqual(this._tokens[index - 1], '()') && isValEqual(nextToken, '.[]')) {
                    this.__tempIdentifiers.push('.');
                } else {
                    this.__tempIdentifiers.push(token);
                }

                if (!isNull(nextToken)) {
                    switch (nextToken.val) {
                        case '.':
                        case '()':
                            return token;
                        default:
                            if (!useLocalContext) {
                                return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';
                            }
                            break;
                    }
                } else {
                    return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';
                }
            }
            /**
             * @name __convertObject
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles an object literal.
             * 
             * @param {number} args The current {@link plat.expressions.IToken|IToken} args.
             * 
             * @returns {string} The correctly evaluated object literal represented as a string.
             */
            private __convertObject(args: number): string {
                var identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    codeArray = this.__codeArray,
                    j = 0,
                    key: string,
                    codeStr = '{',
                    tempIdentifier: string,
                    temp: string;

                while (j++ < args) {
                    temp = codeArray.pop();
                    key = codeArray.pop();
                    codeStr += ',"' + key + '":' + temp;

                    if (tempIdentifiers.length > 1) {
                        tempIdentifier = tempIdentifiers.pop();
                        // pop the key's tempIdentifier
                        tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }

                return codeStr.replace(',', '') + '}';
            }
            /**
             * @name __convertArrayLiteral
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles an Array literal.
             * 
             * @param {number} args The current {@link plat.expressions.IToken|IToken} args.
             * 
             * @returns {string} The correctly evaluated Array literal represented as a string.
             */
            private __convertArrayLiteral(args: number): string {
                var identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    codeArray = this.__codeArray,
                    j = 0,
                    tempStr = '',
                    tempIdentifier: string;

                while (j++ < args) {
                    tempStr = codeArray.pop() + ',' + tempStr;

                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }

                return '[' + tempStr.slice(0, -1) + ']';
            }

            /**
             * @name __handleFunction
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles an accessor type function token "()".
             * 
             * @param {number} index The current index in the {@link plat.expressions.IToken|IToken} array.
             * @param {number} args The current {@link plat.expressions.IToken|IToken} args.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             * 
             * @returns {boolean} Whether we need to use the current parsed object as the new current context.
             */
            private __handleFunction(index: number, args: number, useLocalContext: boolean): boolean {
                var identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    codeArray = this.__codeArray,
                    j = 0,
                    previousToken = this._lookBack(index),
                    grabFnName = !isNull(previousToken) && (previousToken.args === -2 || this._isValEqual(previousToken, '.[]')),
                    tempStr = '',
                    tempIdentifier: string,
                    fnName = '',
                    identifierFnName = '',
                    codeStr: string,
                    pushedIdentifier = false;

                if (grabFnName) {
                    fnName = codeArray.pop();
                    identifierFnName = tempIdentifiers.pop();
                }

                while (j++ < args) {
                    tempStr = codeArray.pop() + ',' + tempStr;

                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                            pushedIdentifier = true;
                        }
                    }
                }

                if (args > 0) {
                    codeStr = '.call(initialContext || context,' + tempStr.slice(0, tempStr.length - 1) + ')';
                } else {
                    codeStr = '.call(initialContext || context)';
                }

                if (useLocalContext) {
                    useLocalContext = false;
                    if (codeArray.length > 0) {
                        var context = codeArray.pop(),
                            lastIndex = tempIdentifiers.length - 1;

                        if (!(lastIndex < 0 || tempIdentifiers[lastIndex] === '.' || identifierFnName === '')) {
                            tempIdentifiers[lastIndex] += '.' + identifierFnName;
                            identifiers.push(tempIdentifiers.pop());
                        // check fn name is not null, pushed an identifier, and the context is not an array literal
                        } else if (!(identifierFnName === '' ||
                            !pushedIdentifier ||
                            context[0] === '[' ||
                            context[context.length - 1] === ']')) {
                            identifiers[identifiers.length - 1] += '.' + identifierFnName;
                        }

                        if (isEmpty(fnName)) {
                            codeStr = context + codeStr;
                        } else {
                            codeStr = '((' + this.__indexIntoContext.toString() + ')(' + context + ',"' +
                            fnName + '") || (function () {}))' + codeStr;
                        }
                    } else {
                        this._throwError('Improper expression or context');
                    }
                } else {
                    if (grabFnName) {
                        codeStr = '(initialContext = ((' + this.__findInitialContext.toString() + ')(context,aliases,"' +
                        fnName + '") || (function () {}))' + codeStr + ')';

                        identifiers.push(fnName);
                    } else {
                        codeStr = codeArray.pop() + codeStr;
                    }
                }

                codeArray.push(codeStr);

                var length = tempIdentifiers.length;
                if (this._isValEqual(this._peek(index), '[]') && length > 0 && tempIdentifiers[length - 1] !== '.') {
                    identifiers.push(tempIdentifiers.pop());
                }

                return useLocalContext;
            }
            /**
             * @name __indexIntoObject
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles an accessor type token that is for indexing (i.e. "." or "[]").
             * 
             * @param {number} index The current index in the {@link plat.expressions.IToken|IToken} array.
             * @param {string} token The current {@link plat.expressions.IToken|IToken} value.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             * 
             * @returns {boolean} Whether we need to use the current parsed object as the new current context.
             */
            private __indexIntoObject(index: number, token: string, useLocalContext: boolean): boolean {
                var isValEqual = this._isValEqual;

                if (isValEqual(this._peek(index), '()')) {
                    return true;
                }

                var codeArray = this.__codeArray,
                    codeStr = codeArray.pop(),
                    identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    previousToken = this._lookBack(index),
                    identifierIndexer = tempIdentifiers.pop(),
                    hasIdentifierIndexer = !isNull(identifierIndexer),
                    lastIndex: number;

                if (hasIdentifierIndexer && identifierIndexer[0] === '@') {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    identifiers.push(identifierIndexer);
                    if (tempIdentifiers.length > 0) {
                        identifiers.push(tempIdentifiers.pop());
                    }
                } else if (isValEqual(previousToken, '++--()[]*/%?:>=<=&&||!===')) {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    tempIdentifiers.push('.');
                } else if (token === '[]' && !(isNull(previousToken) || previousToken.args >= 0)) {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';

                    lastIndex = tempIdentifiers.length - 1;
                    if (lastIndex >= 0) {
                        if (tempIdentifiers[lastIndex] !== '.') {
                            identifiers.push(tempIdentifiers.pop());
                        }
                    }

                    identifiers.push(identifierIndexer);
                } else {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',"' + codeStr + '")';

                    lastIndex = tempIdentifiers.length - 1;
                    if (lastIndex >= 0) {
                        if (tempIdentifiers[lastIndex] !== '.') {
                            tempIdentifiers[lastIndex] += '.' + identifierIndexer;
                        }
                    } else if (hasIdentifierIndexer && identifierIndexer !== '.' && token !== '.') {
                        identifiers.push(identifierIndexer);
                    }
                }

                codeArray.push(codeStr);

                return useLocalContext;
            }
        
            /**
             * @name __handleQuestion
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles the "?" operator.
             * 
             * @returns {void}
             */
            private __handleQuestion(): void {
                var identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    codeArray = this.__codeArray,
                    temp = codeArray.pop(),
                    tempIdentifier: string;

                for (var i = 0; i < 2; i++) {
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    } else {
                        break;
                    }
                }

                codeArray.push(codeArray.pop() + '?' + temp);
            }
            /**
             * @name __handleColon
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles the ":" operator.
             * 
             * @returns {void}
             */
            private __handleColon(): void {
                var identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    codeArray = this.__codeArray,
                    temp = codeArray.pop(),
                    tempIdentifier: string;

                for (var i = 0; i < 2; i++) {
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    } else {
                        break;
                    }
                }

                codeArray.push(codeArray.pop() + ':' + temp);
            }
            /**
             * @name __handleOperator
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Handles all other operators.
             * 
             * @param {string} token The current {@link plat.expressions.IToken|IToken} value.
             * @param {number} args The current {@link plat.expressions.IToken|IToken} args.
             * 
             * @returns {void}
             */
            private __handleOperator(token: string, args: number): void {
                var identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    codeArray = this.__codeArray,
                    j = 0,
                    tempStr = '',
                    tempIdentifier: string;

                while (j++ < args) {
                    tempStr = 'function (context, aliases) { return ' + codeArray.pop() + '; }' + ',' + tempStr;

                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }

                codeArray.push(
                    '(' + OPERATORS[token].fn.toString() + ')(context, aliases,' + tempStr.slice(0, tempStr.length - 1) + ')'
                );
            }
        
            /**
             * @name __findInitialContext
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Safely finds an initial context.
             * 
             * @param {any} context The context object.
             * @param {any} aliases Any aliases that may exist.
             * @param {string} token The property used to find the initial context.
             * @param {any} undefined An undefined argument.
             * 
             * @returns {any} The correct initial context.
             */
            private __findInitialContext(context: any, aliases: any, token: string, undefined?: any): any {
                if (token[0] === '@' && aliases !== null && typeof aliases === 'object') {
                    return aliases[token];
                } else if (context !== null && typeof context === 'object') {
                    return context[token];
                }
                return undefined;
            }
            /**
             * @name __indexIntoContext
             * @memberof plat.expressions.Parser
             * @kind function
             * @access private
             * 
             * @description
             * Safely drills down into a specified context with a given token.
             * 
             * @param {any} context The context object.
             * @param {string} token The property used to drill into the context.
             * @param {any} undefined An undefined argument.
             * 
             * @returns {any} The property of the context denoted by the token.
             */
            private __indexIntoContext(context: any, token: string, undefined?: any): any {
                if (context !== null && typeof context === 'object') {
                    return context[token];
                }
                return undefined;
            }

            /**
             * @name _peek
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Peek at the next {@link plat.expressions.IToken|IToken}.
             * 
             * @param {number} index The index before the desired {@link plat.expressions.IToken|IToken} 
             * in the array.
             * 
             * @returns {plat.expressions.IToken} The next {@link plat.expressions.IToken|IToken} 
             * in the {@link plat.expressions.IToken|IToken} array.
             */
            _peek(index: number): IToken {
                return this._tokens[index + 1];
            }
        
            /**
             * @name _lookBack
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Look back at the previous {@link plat.expressions.IToken|IToken}.
             * 
             * @param {number} index The index after the desired {@link plat.expressions.IToken|IToken} 
             * in the array.
             * 
             * @returns {plat.expressions.IToken} The previous {@link plat.expressions.IToken|IToken} 
             * in the {@link plat.expressions.IToken|IToken} array.
             */
            _lookBack(index: number): IToken {
                return this._tokens[index - 1];
            }
        
            /**
             * @name _popRemainingIdentifiers
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Evaluate and remove the leftover identifiers.
             * 
             * @returns {void}
             */
            _popRemainingIdentifiers(): void {
                var identifiers = this.__identifiers,
                    tempIdentifiers = this.__tempIdentifiers,
                    last: string;

                while (tempIdentifiers.length > 0) {
                    last = tempIdentifiers.pop();
                    if (last !== '.') {
                        identifiers.push(last);
                    }
                }
            }
        
            /**
             * @name _makeIdentifiersUnique
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Remove duplicate identifiers.
             * 
             * @returns {void}
             */
            _makeIdentifiersUnique(): void {
                var identifiers = this.__identifiers,
                    uniqueIdentifiers: Array<string> = [],
                    uniqueIdentifierObject: IObject<boolean> = {},
                    identifier: string;

                while (identifiers.length > 0) {
                    identifier = identifiers.pop();
                    if (!uniqueIdentifierObject[identifier]) {
                        uniqueIdentifierObject[identifier] = true;
                        uniqueIdentifiers.push(identifier);
                    }
                }

                this.__identifiers = uniqueIdentifiers;
            }
        
            /**
             * @name _isValEqual
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Check if the "val" property on an {@link plat.expressions.IToken|IToken} 
             * is present in a particular character string.
             * 
             * @param {plat.expressions.IToken} obj The {@link plat.expressions.IToken|IToken} 
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             * 
             * @returns {boolean} Whether or not the val is equal to the input character.
             */
            _isValEqual(obj: IToken, char: string): boolean {
                if (isNull(obj) || isNull(obj.val)) {
                    return isNull(char);
                } else if (obj.val === '') {
                    return char === '';
                }
                return char.indexOf(obj.val) !== -1;
            }
        
            /**
             * @name _isValUnequal
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Check if the "val" property on an {@link plat.expressions.IToken|IToken} 
             * is not present in a particular character string.
             * 
             * @param {plat.expressions.IToken} obj The {@link plat.expressions.IToken|IToken} 
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             * 
             * @returns {boolean} Whether or not the val is not equal to the input character.
             */
            _isValUnequal(obj: any, char: string): boolean {
                if (isNull(obj) || isNull(obj.val)) {
                    return !isNull(char);
                } else if (obj.val === '') {
                    return char !== '';
                }
                return char.indexOf(obj.val) === -1;
            }
        
            /**
             * @name _resetParser
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Resets all the parser's properties.
             * 
             * @returns {void}
             */
            _resetParser(): void {
                this._tokens = [];
                this.__codeArray = [];
                this.__identifiers = [];
                this.__tempIdentifiers = [];
                this.__aliases = {};
            }
        
            /**
             * @name _throwError
             * @memberof plat.expressions.Parser
             * @kind function
             * @access protected
             * 
             * @description
             * Throws a fatal exception in the case of an error.
             * 
             * @param {string} error The error message to throw.
             * 
             * @returns {void}
             */
            _throwError(error: string): void {
                var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                $exception.fatal(error, $exception.PARSE);
            }
        }

        /**
         * The Type for referencing the '$Parser' injectable as a dependency.
         */
        export function IParser(): IParser {
            return new Parser();
        }

        register.injectable(__Parser, IParser);
    
        /**
         * @name IParser
         * @memberof plat.expressions
         * @kind interface
         * 
         * @description
         * Describes an object that can parse a JavaScript expression string and turn it into an
         * {@link plat.expressions.IParsedExpression|IParsedExpression}.
         */
        export interface IParser {
            /**
             * @name parse
             * @memberof plat.expressions.IParser
             * @kind function
             * @access public
             * 
             * @description
             * Parses a JavaScript expression string.
             * 
             * @param {string} expression The JavaScript expression string to parse.
             * 
             * @returns {plat.expressions.IParsedExpression} The parsed expression containing detailed 
             * information about the expression as well as a way to evaluate its value.
             */
            parse(expression: string): IParsedExpression;

            /**
             * @name clearCache
             * @memberof plat.expressions.IParser
             * @kind function
             * @access public
             * 
             * @description
             * If a key is passed in, it clears that single value in the expression cache. If no 
             * key is present, the entire expression cache will be cleared.
             * 
             * @param {string} key? An optional key that will clear its stored value in the expression 
             * cache if passed in.
             * 
             * @returns {void}
             */
            clearCache(key?: string): void;
        }
    
        /**
         * @name IParsedExpression
         * @memberof plat.expressions
         * @kind interface
         * 
         * @description
         * Describes an object that is the result of parsing a JavaScript expression string. It contains detailed 
         * information about the expression as well as a way to evaluate the expression with a context.
         */
        export interface IParsedExpression {
            /**
             * @name evaluate
             * @memberof plat.expressions.IParsedExpression
             * @kind function
             * @access public
             * 
             * @description
             * A method for evaluating an expression with a context.
             * 
             * @param {any} context? The primary context for evaluation.
             * @param {any} aliases? An object containing resource alias values. All keys must begin with '@'.
             * 
             * @returns {any} The evaluated object or primitive.
             */
            evaluate(context?: any, aliases?: any): any;

            /**
             * @name expression
             * @memberof plat.expressions.IParsedExpression
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The original expression string.
             */
            expression: string;
        
            /**
             * @name identifiers
             * @memberof plat.expressions.IParsedExpression
             * @kind property
             * @access public
             * 
             * @type {Array<string>}
             * 
             * @description
             * Contains all the identifiers found in an expression. Useful for determining
             * properties to watch on a context.
             */
            identifiers: Array<string>;
        
            /**
             * @name aliases
             * @memberof plat.expressions.IParsedExpression
             * @kind property
             * @access public
             * 
             * @type {Array<string>}
             * 
             * @description
             * Contains all the aliases (denoted by an identifier with '@' as the first character) for this 
             * {@link plat.expressions.IParsedExpression|IParsedExpression}.
             */
            aliases: Array<string>;
        
            /**
             * @name oneTime
             * @memberof plat.expressions.IParsedExpression
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Specifies whether or not you want to do a one-time binding on identifiers 
             * for this expression. Typically this is added to a clone of this 
             * {@link plat.expressions.IParsedExpression|IParsedExpression}.
             */
            oneTime?: boolean;
        }
    }
    /**
     * @name web
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds classes and interfaces related to web components in platypus.
     */
    export module web {
        /**
         * @name Browser
         * @memberof plat.web
         * @kind class
         * 
         * @implements {plat.web.IBrowser}
         * 
         * @description
         * The class that handles all interaction with the browser.
         */
        export class Browser implements IBrowser {
            /**
             * @name config
             * @memberof plat.web.Browser
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.web.IBrowserConfig}
             * 
             * @description
             * The {@link plat.web.IBrowserConfig|IBrowserConfig} injectable object.
             */
            static config: IBrowserConfig = {
                NONE: 'none',
                HASH: 'hash',
                STATE: 'state',
                routingType: 'none',
                hashPrefix: '',
                baseUrl: ''
            };

            /**
             * @name $EventManagerStatic
             * @memberof plat.web.Browser
             * @kind property
             * @access public
             * 
             * @type {plat.events.IEventManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.
             */
            $EventManagerStatic: events.IEventManagerStatic = acquire(__EventManagerStatic);
            /**
             * @name $Compat
             * @memberof plat.web.Browser
             * @kind property
             * @access public
             * 
             * @type {plat.ICompat}
             * 
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            $Compat: ICompat = acquire(__Compat);
            /**
             * @name $Regex
             * @memberof plat.web.Browser
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.IRegex}
             * 
             * @description
             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.
             */
            $Regex: expressions.IRegex = acquire(__Regex);
            /**
             * @name $Window
             * @memberof plat.web.Browser
             * @kind property
             * @access public
             * 
             * @type {Window}
             * 
             * @description
             * Reference to the Window injectable.
             */
            $Window: Window = acquire(__Window);
            /**
             * @name $Dom
             * @memberof plat.web.Browser
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IDom}
             * 
             * @description
             * Reference to the {@link plat.ui.IDom|IDom} injectable.
             */
            $Dom: ui.IDom = acquire(__Dom);

            /**
             * @name uid
             * @memberof plat.web.Browser
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * A unique string identifier.
             */
            uid: string;

            /**
             * @name __currentUrl
             * @memberof plat.web.Browser
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * The browser's current URL.
             */
            private __currentUrl: string;
            /**
             * @name __lastUrl
             * @memberof plat.web.Browser
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * The browser's last URL.
             */
            private __lastUrl = this.$Window.location.href;
            /**
             * @name __initializing
             * @memberof plat.web.Browser
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the browser is in an initialization state.
             */
            private __initializing = false;

            /**
             * @name constructor
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.web.Browser|Browser}. Assigns a uid and subscribes to the 'beforeLoad' event.
             * 
             * @returns {plat.web.Browser}
             */
            constructor() {
                var ContextManager: observable.IContextManagerStatic = acquire(__ContextManagerStatic);
                ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));
                this.$EventManagerStatic.on(this.uid, 'beforeLoad', this.initialize, this);
            }

            /**
             * @name initialize
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the {@link plat.web.Browser|Browser} instance, trims the url, and 
             * adds events for popstate and hashchange.
             * 
             * @returns {void}
             */
            initialize(): void {
                var $config = Browser.config,
                    $compat = this.$Compat;

                this.$EventManagerStatic.dispose(this.uid);

                if ($config.routingType === $config.NONE) {
                    return;
                }

                this.__initializing = true;

                var url = this.url(),
                    trimmedUrl = url.replace(this.$Regex.initialUrlRegex, '/'),
                    changed = this._urlChanged.bind(this),
                    $dom = this.$Dom,
                    $window = this.$Window;

                if (isEmpty($config.baseUrl)) {
                    acquire(__UrlUtilsInstance);
                }

                if (trimmedUrl !== url) {
                    this.url(trimmedUrl, true);
                }

                if ($compat.pushState) {
                    if ($config.routingType === $config.STATE) {
                        this.url($config.baseUrl, true);
                    }

                    $dom.addEventListener($window, 'popstate', changed, false);
                }

                $dom.addEventListener($window, 'hashchange', changed, false);

                this.__initializing = false;
            }

            /**
             * @name url
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * Sets or gets the current $Window.location
             * 
             * @param {string} url? The URL to set the location to.
             * @param {boolean} replace? Whether or not to replace the current URL in 
             * the history.
             * 
             * @returns {string} The current URL or current location.
             */
            url(url?: string, replace?: boolean): string {
                var location = this.$Window.location;

                if (isString(url) && this.__lastUrl !== url) {
                    this.__lastUrl = url;
                    this._setUrl(url, replace);
                }
                return this.__currentUrl || location.href;
            }

            /**
             * @name urlUtils
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * Creates a new {@link plat.web.IUrlUtils|IUrlUtils} object.
             * 
             * @param url? The URL to associate with the new {@link plat.web.UrlUtils|UrlUtils} 
             * instance.
             * 
             * @returns {@link plat.web.IUrlUtils|IUrlUtils} The new {@link plat.web.IUrlUtils|IUrlUtils} object.
             */
            urlUtils(url?: string): IUrlUtilsInstance {
                url = url || this.url();

                var $urlUtils: IUrlUtilsInstance = acquire(__UrlUtilsInstance),
                    $config = Browser.config;

                if ($config.routingType === $config.HASH) {
                    url = url.replace(new RegExp('#' + ($config.hashPrefix || '') + '/?'), '');
                }

                $urlUtils.initialize(url);

                return $urlUtils;
            }

            /**
             * @name isCrossDomain
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * Checks to see if the requested URL is cross domain.
             * 
             * @param url The URL to verify whether or not it's cross domain.
             * 
             * @returns {boolean} Whether or not the URL argument is cross domain.
             */
            isCrossDomain(url: string): boolean {
                if (!isString(url)) {
                    return false;
                }

                var urlUtils = this.urlUtils(url),
                    locationUtils = this.urlUtils();

                // check for protocol:host:port mismatch
                return urlUtils.protocol !== locationUtils.protocol ||
                    urlUtils.hostname !== locationUtils.hostname ||
                    urlUtils.port !== locationUtils.port;
            }

            /**
             * @name _urlChanged
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * The event to fire in the case of a URL change. It kicks 
             * off a 'urlChanged' direct event notification.
             * 
             * @param url The URL to verify whether or not it's cross domain.
             * 
             * @returns {void}
             */
            _urlChanged(): void {
                if (this.__initializing) {
                    return;
                }

                this.__currentUrl = null;
                var url = this.url();

                if (this.__lastUrl === url) {
                    return;
                }

                this.__lastUrl = url;

                var $manager = this.$EventManagerStatic;
                $manager.dispatch('urlChanged',
                    this,
                    $manager.DIRECT,
                    [this.urlUtils()]);
            }

            /**
             * @name _setUrl
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * Checks for the existence of pushState and 
             * sets the browser URL accordingly.
             * 
             * @param {string} url The URL to set.
             * @param {boolean} replace? Whether or not to replace the 
             * current URL in the history.
             * 
             * @returns {void}
             */
            _setUrl(url: string, replace?: boolean): void {
                url = this._formatUrl(url);
                if (this.$Compat.pushState) {
                    if (replace) {
                        history.replaceState(null, '', url);
                    } else {
                        history.pushState(null, '', url);
                    }

                    if (!this.__initializing) {
                        this._urlChanged();
                    }
                } else {
                    this.__currentUrl = url;
                    if (replace) {
                        location.replace(url);
                    } else {
                        location.href = url;
                    }
                }
            }

            /**
             * @name _formatUrl
             * @memberof plat.web.Browser
             * @kind function
             * @access public
             * 
             * @description
             * Formats the URL in the case of HASH routing.
             * 
             * @param url The URL to format.
             * 
             * @returns {string} The formatted URL.
             */
            _formatUrl(url: string): string {
                var $config = Browser.config;
                if ($config.routingType === $config.HASH) {
                    var hasProtocol = url.indexOf(this.urlUtils().protocol) !== -1,
                        prefix = $config.hashPrefix || '',
                        hashRegex = new RegExp('#' + prefix + '|#/');

                    if (hasProtocol && !hashRegex.test(url)) {
                        url = url + '#' + prefix + '/';
                    } else if (!hashRegex.test(url)) {
                        url = '#' + prefix + '/' + url;
                    }
                }

                return url;
            }
        }

        /**
         * The Type for referencing the '$Browser' injectable as a dependency.
         */
        export function IBrowser(): IBrowser {
            return new Browser();
        }

        register.injectable(__Browser, IBrowser);

        /**
         * @name IBrowser
         * @memberof plat.web
         * @kind interface
         * 
         * @description
         * Defines an object that handles interaction with the browser.
         */
        export interface IBrowser {
            /**
             * @name uid
             * @memberof plat.web.IBrowser
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * A unique string identifier.
             */
            uid: string;

            /**
             * @name initialize
             * @memberof plat.web.IBrowser
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the {@link plat.web.Browser|Browser} instance, trims the url, and 
             * adds events for popstate and hashchange.
             * 
             * @returns {void}
             */
            initialize(): void;

            /**
             * @name url
             * @memberof plat.web.IBrowser
             * @kind function
             * @access public
             * 
             * @description
             * Sets or gets the current $Window.location
             * 
             * @param {string} url? The URL to set the location to.
             * @param {boolean} replace? Whether or not to replace the current URL in 
             * the history.
             * 
             * @returns {string} The current URL or current location.
             */
            url(url?: string, replace?: boolean): string;

            /**
             * @name urlUtils
             * @memberof plat.web.IBrowser
             * @kind function
             * @access public
             * 
             * @description
             * Creates a new {@link plat.web.IUrlUtils|IUrlUtils} object.
             * 
             * @param url? The URL to associate with the new {@link plat.web.UrlUtils|UrlUtils} 
             * instance.
             * 
             * @returns {@link plat.web.IUrlUtils|IUrlUtils} The new {@link plat.web.IUrlUtils|IUrlUtils} object.
             */
            urlUtils(url?: string): IUrlUtilsInstance;

            /**
             * @name isCrossDomain
             * @memberof plat.web.IBrowser
             * @kind function
             * @access public
             * 
             * @description
             * Checks to see if the requested URL is cross domain.
             * 
             * @param url The URL to verify whether or not it's cross domain.
             * 
             * @returns {boolean} Whether or not the URL argument is cross domain.
             */
            isCrossDomain(url: string): boolean;
        }

        /**
         * The Type for referencing the '$BrowserConfig' injectable as a dependency.
         */
        export function IBrowserConfig(): IBrowserConfig {
            return Browser.config;
        }

        register.injectable(__BrowserConfig, IBrowserConfig);

        /**
         * @name IBrowserConfig
         * @memberof plat.web
         * @kind interface
         * 
         * @description
         * Specifies configuration properties for the {@link plat.web.IBrowser|IBrowser}  
         * injectable.
         */
        export interface IBrowserConfig {
            /**
             * @name NONE
             * @memberof plat.web.IBrowserConfig
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies that the application will not be doing 
             * url-based routing.
             */
            NONE: string;

            /**
             * @name HASH
             * @memberof plat.web.IBrowserConfig
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies that the application wants to use hash-based 
             * routing.
             */
            HASH: string;

            /**
             * @name STATE
             * @memberof plat.web.IBrowserConfig
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies that the application wants to use the HTML5 
             * popstate method for managing routing. If the browser 
             * does not support HTML5 popstate events, hash routing 
             * will be used instead.
             * 
             * Note: In 'state' mode, the web server must be configured to 
             * route every url to the root url.
             */
            STATE: string;

            /**
             * @name routingType
             * @memberof plat.web.IBrowserConfig
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Allows you to define how your app will route. There are
             * three modes, NONE ('none'), HASH ('hash'), and STATE ('state'). 
             * 
             * In NONE, the application will not be responding to 
             * url changes.
             * 
             * In HASH, the application will use a hash prefix and 
             * all navigation will be managed with hash changes.
             * 
             * In STATE mode, the application will use the 'popstate' 
             * event and will be able to manage routes. The web server 
             * must be configured to route every URL to the root URL if 
             * using STATE mode.
             * 
             * The default mode is NONE.
             */
            routingType: string;

            /**
             * @name hashPrefix
             * @memberof plat.web.IBrowserConfig
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * If routingType is set to HASH ('hash'), this value will be 
             * appended to the '#' at the beginning of every route. The 
             * default prefix is '!', meaning each path will be '#!/<path>'.
             */
            hashPrefix: string;

            /**
             * @name baseUrl
             * @memberof plat.web.IBrowserConfig
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies the base URL used to normalize URL routing.
             */
            baseUrl: string;
        }

        /**
         * @name UrlUtils
         * @memberof plat.web
         * @kind class
         * 
         * @implements {plat.web.IUrlUtilsInstance}
         * 
         * @description
         * Deals with obtaining detailed information about an 
         * associated URL.
         */
        export class UrlUtils implements IUrlUtilsInstance {
            /**
             * @name __urlUtilsElement
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access private
             * @static
             * 
             * @type {HTMLAnchorElement}
             * 
             * @description
             * Helps with URL initialization through it's href attribute.
             */
            private static __urlUtilsElement: HTMLAnchorElement;
            /**
             * @name __getQuery
             * @memberof plat.web.UrlUtils
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Creates a query object out of the URL's query search string.
             * 
             * @param {string} search The URL's query search string.
             * 
             * @returns {plat.IObject<string>} An object consisting of key-value pairs 
             * representing the query string.
             */
            private static __getQuery(search: string): IObject<string> {
                if (isEmpty(search)) {
                    return;
                }

                var split = search.split('&'),
                    query: IObject<string> = {},
                    length = split.length,
                    item: Array<string>;

                for (var i = 0; i < length; ++i) {
                    item = split[i].split('=');

                    query[item[0]] = item[1];
                }

                return query;
            }

            /**
             * @name __getBaseUrl
             * @memberof plat.web.UrlUtils
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Obtains the base URL for the app/site for doing STATE type routing.
             * 
             * @param {string} url The initial URL passed into the Browser.
             * 
             * @returns {string} The base URL.
             */
            private static __getBaseUrl(url: string): string {
                var colon = url.slice(url.indexOf(':')),
                    next = colon.slice(colon.search(/\w+/));

                return url.slice(0, url.indexOf('/', url.indexOf(next))) + '/';
            }

            /**
             * @name $ContextManagerStatic
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {plat.observable.IContextManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
             */
            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);
            /**
             * @name $Document
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {Document}
             * 
             * @description
             * Reference to the Document injectable.
             */
            $Document: Document = acquire(__Document);
            /**
             * @name $Window
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {Window}
             * 
             * @description
             * Reference to the Window injectable.
             */
            $Window: Window = acquire(__Window);
            /**
             * @name $Compat
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {plat.ICompat}
             * 
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            $Compat: ICompat = acquire(__Compat);
            /**
             * @name $Regex
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.IRegex}
             * 
             * @description
             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.
             */
            $Regex: expressions.IRegex = acquire(__Regex);
            /**
             * @name $BrowserConfig
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {plat.web.IBrowserConfig}
             * 
             * @description
             * Reference to the {@link plat.web.IBrowserConfig|IBrowserConfig} injectable.
             */
            $BrowserConfig: IBrowserConfig = acquire(__BrowserConfig);

            /**
             * @name href
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The whole associated URL.
             */
            href: string;
            /**
             * @name protocol
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The protocol scheme of the URL, including the final ':' of the associated URL.
             */
            protocol: string;
            /**
             * @name host
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The hostname and port of the associated URL.
             */
            host: string;
            /**
             * @name hostname
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The domain of the associated URL.
             */
            hostname: string;
            /**
             * @name port
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The port number of the associated URL.
             */
            port: string;
            /**
             * @name pathname
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The additional path value in the associated URL preceded by a '/'. 
             * Removes the query string.
             */
            pathname: string;
            /**
             * @name search
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A '?' followed by the included parameters in the associated URL.
             */
            search: string;
            /**
             * @name hash
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A '#' followed by the included hash fragments in the associated URL.
             */
            hash: string;
            /**
             * @name username
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The username specified before the domain name in the associated URL.
             */
            username: string;
            /**
             * @name password
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The password specified before the domain name in the associated URL.
             */
            password: string;
            /**
             * @name origin
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The origin of the associated URL (its protocol, domain, and port).
             */
            origin: string;
            /**
             * @name query
             * @memberof plat.web.UrlUtils
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * An object containing keyed query arguments from the associated URL.
             */
            query: any;

            /**
             * @name constructor
             * @memberof plat.web.UrlUtils
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.web.UrlUtils|UrlUtils} instance. 
             * Handles parsing the initial URL and obtain the base URL if necessary.
             * 
             * @returns {plat.web.UrlUtils}
             */
            constructor() {
                var $config = this.$BrowserConfig;
                if (isEmpty($config.baseUrl)) {
                    var url = this.$Window.location.href,
                        trimmedUrl = url.replace(this.$Regex.initialUrlRegex, '/');

                    if ($config.routingType === $config.HASH) {
                        $config.baseUrl = trimmedUrl.replace(/#.*/, '');
                    } else {
                        $config.baseUrl = UrlUtils.__getBaseUrl(trimmedUrl);
                    }
                }
            }

            /**
             * @name initialize
             * @memberof plat.web.UrlUtils
             * @kind function
             * @access public
             * 
             * @description
             * Initializes and defines properties using 
             * the input url.
             * 
             * @param {string} url The input to associate with this {@link plat.web.UrlUtils|UrlUtils} instance.
             * 
             * @returns {void}
             */
            initialize(url: string): void {
                url = url || '';

                var element = UrlUtils.__urlUtilsElement ||
                    (UrlUtils.__urlUtilsElement = this.$Document.createElement('a')),
                    define = this.$ContextManagerStatic.defineGetter;

                // always make local urls relative to start page.
                if (url[0] === '/') {
                    url = url.slice(1);
                }

                element.setAttribute('href', url);
                url = element.href;

                // we need to do this twice for cerain browsers (e.g. win8)
                element.setAttribute('href', url);
                url = element.href;

                var protocol = element.protocol ? element.protocol.replace(/:$/, '') : '';

                // cordova adds //www for some urls, so we want to take those out.
                if (protocol.indexOf('http') === -1 && protocol.indexOf('ms-appx') === -1) {
                    url = url.replace('//', '');
                }

                define(this, 'href', url, true, true);
                define(this, 'protocol', element.protocol ? element.protocol.replace(/:$/, '') : '', true, true);
                define(this, 'host', element.host, true, true);
                define(this, 'search', element.search ? element.search.replace(/^\?/, '') : '', true, true);
                define(this, 'hash', element.hash ? element.hash.replace(/^#/, '') : '', true, true);
                define(this, 'hostname', element.hostname, true, true);
                define(this, 'port', element.port, true, true);

                var path: string;

                if (!isEmpty(this.$BrowserConfig.baseUrl)) {
                    path = url.replace(this.$BrowserConfig.baseUrl, '/');
                } else {
                    path = (element.pathname.charAt(0) === '/')
                    ? element.pathname
                    : '/' + element.pathname;
                }

                define(this, 'pathname', path.split('?')[0], true, true);
                define(this, 'query', UrlUtils.__getQuery(this.search), true, true);
            }

            /**
             * @name toString
             * @memberof plat.web.UrlUtils
             * @kind function
             * @access public
             * 
             * @description
             * A toString function implementation for the {@link plat.web.UrlUtils|UrlUtils} class.
             * 
             * @returns {string} The href associated with this {@link plat.web.UrlUtils|UrlUtils} instance.
             */
            toString(): string {
                return this.href;
            }
        }

        /**
         * The Type for referencing the '$UrlUtilsInstance' injectable as a dependency.
         */
        export function IUrlUtilsInstance(): IUrlUtilsInstance {
            return new UrlUtils();
        }

        register.injectable(__UrlUtilsInstance, IUrlUtilsInstance, null, __INSTANCE);

        /**
         * @name IUrlUtilsInstance
         * @memberof plat.web
         * @kind interface
         * 
         * @description
         * Defines an object that deals with obtaining detailed information about an 
         * associated URL.
         */
        export interface IUrlUtilsInstance {
            /**
             * @name href
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The whole associated URL.
             */
            href: string;

            /**
             * @name protocol
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The protocol scheme of the URL, including the final ':' of the associated URL.
             */
            protocol: string;

            /**
             * @name host
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The hostname and port of the associated URL.
             */
            host: string;

            /**
             * @name hostname
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The domain of the associated URL.
             */
            hostname: string;

            /**
             * @name port
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The port number of the associated URL.
             */
            port: string;

            /**
             * @name pathname
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The additional path value in the associated URL preceded by a '/'. 
             * Removes the query string.
             */
            pathname: string;

            /**
             * @name search
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A '?' followed by the included parameters in the associated URL.
             */
            search: string;

            /**
             * @name hash
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A '#' followed by the included hash fragments in the associated URL.
             */
            hash: string;

            /**
             * @name username
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The username specified before the domain name in the associated URL.
             */
            username?: string;

            /**
             * @name password
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The password specified before the domain name in the associated URL.
             */
            password?: string;

            /**
             * @name origin
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The origin of the associated URL (its protocol, domain, and port).
             */
            origin?: string;

            /**
             * @name query
             * @memberof plat.web.IUrlUtilsInstance
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * An object containing keyed query arguments from the associated URL.
             */
            query?: any;

            /**
             * @name initialize
             * @memberof plat.web.IUrlUtilsInstance
             * @kind function
             * @access public
             * 
             * @description
             * Initializes and defines properties using 
             * the input url.
             * 
             * @param {string} url The input to associate with this {@link plat.web.IUrlUtilsInstance|IUrlUtilsInstance}.
             * 
             * @returns {void}
             */
            initialize(url: string): void;

            /**
             * @name toString
             * @memberof plat.web.IUrlUtilsInstance
             * @kind function
             * @access public
             * 
             * @description
             * A toString function implementation for the {@link plat.web.IUrlUtilsInstance|IUrlUtilsInstance}.
             * 
             * @returns {string} The href associated with this {@link plat.web.IUrlUtilsInstance|IUrlUtilsInstance}.
             */
            toString(): string;
        }

        /**
         * @name Router
         * @memberof plat.web
         * @kind class
         * 
         * @implements {plat.web.IRouter}
         * 
         * @description
         * The class that handles route registration and navigation 
         * to and from {@link plat.ui.IViewControl|IViewControls} within the 
         * {@link plat.ui.controls.Routeport|Routeport}.
         */
        export class Router implements IRouter {
            /**
             * @name $Browser
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * 
             * @type {plat.web.IBrowser}
             * 
             * @description
             * Reference to the {@link plat.web.IBrowser|IBrowser} injectable.
             */
            $Browser: IBrowser = acquire(__Browser);
            /**
             * @name $BrowserConfig
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * 
             * @type {plat.web.IBrowserConfig}
             * 
             * @description
             * Reference to the {@link plat.web.IBrowserConfig|IBrowserConfig} injectable.
             */
            $BrowserConfig: IBrowserConfig = acquire(__BrowserConfig);
            /**
             * @name $EventManagerStatic
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * 
             * @type {plat.events.IEventManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.
             */
            $EventManagerStatic: events.IEventManagerStatic = acquire(__EventManagerStatic);
            /**
             * @name $NavigationEventStatic
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * 
             * @type {plat.events.INavigationEventStatic}
             * 
             * @description
             * Reference to the {@link plat.events.INavigationEventStatic|INavigationEventStatic} injectable.
             */
            $NavigationEventStatic: events.INavigationEventStatic = acquire(__NavigationEventStatic);
            /**
             * @name $Compat
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * 
             * @type {plat.ICompat}
             * 
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            $Compat: ICompat = acquire(__Compat);
            /**
             * @name $Regex
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.IRegex}
             * 
             * @description
             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.
             */
            $Regex: expressions.IRegex = acquire(__Regex);
            /**
             * @name $Window
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * 
             * @type {Window}
             * 
             * @description
             * Reference to the Window injectable.
             */
            $Window: Window = acquire(__Window);

            /**
             * @name uid
             * @memberof plat.web.Router
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * A unique string identifier.
             */
            uid: string;

            /**
             * @name _routes
             * @memberof plat.web.Router
             * @kind property
             * @access protected
             * 
             * @type {Array<plat.web.IRouteMatcher>}
             * 
             * @description
             * The registered routes (as {@link plat.web.IRouteMatcher|IRouteMatchers}) for matching 
             * on route change.
             */
            _routes: Array<IRouteMatcher> = [];

            /**
             * @name _removeListener
             * @memberof plat.web.Router
             * @kind property
             * @access protected
             * 
             * @type {plat.IRemoveListener}
             * 
             * @description
             * The function to stop listening to the 'urlChanged' event.
             */
            _removeListener: IRemoveListener;

            /**
             * @name _defaultRoute
             * @memberof plat.web.Router
             * @kind property
             * @access protected
             * 
             * @type {plat.web.IMatchedRoute}
             * 
             * @description
             * The registered default route ('') converted into an {@link plat.web.IMatchedRoute|IMatchedRoute}. 
             * The default route is used whenever a specified route/url is not matched.
             */
            _defaultRoute: IMatchedRoute;

            /**
             * @name _baseRoute
             * @memberof plat.web.Router
             * @kind property
             * @access protected
             * 
             * @type {plat.web.IMatchedRoute}
             * 
             * @description
             * The registered base route ('/') converted into an {@link plat.web.IMatchedRoute|IMatchedRoute}. 
             * The base route is the first route navigated to in the {@link plat.ui.controls.Routeport|Routeport} if a 
             * default route is not specified in its plat-options.
             */
            _baseRoute: IMatchedRoute;

            /**
             * @name __escapeRegex
             * @memberof plat.web.Router
             * @kind property
             * @access private
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for finding invalid characters in a route string.
             */
            private __escapeRegex = this.$Regex.escapeRouteRegex;
            /**
             * @name __optionalRegex
             * @memberof plat.web.Router
             * @kind property
             * @access private
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for finding optional parameters in a route string.
             */
            private __optionalRegex = this.$Regex.optionalRouteRegex;
            /**
             * @name __pathSlashRegex
             * @memberof plat.web.Router
             * @kind property
             * @access private
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for finding forward slashes at the beginning or end of 
             * an expression.
             */
            private __pathSlashRegex = /^\/|\/$/g;
            /**
             * @name __firstRoute
             * @memberof plat.web.Router
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * States whether the specified route is the first attempt at routing.
             */
            private __firstRoute = true;
            /**
             * @name __history
             * @memberof plat.web.Router
             * @kind property
             * @access private
             * 
             * @type {Array<string>}
             * 
             * @description
             * A virtual history stack used in IE based MS apps.
             */
            private __history: Array<string>;

            /**
             * @name constructor
             * @memberof plat.web.Router
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.web.Router|Router}. Assigns a uid and subscribes to the 'urlChanged' event.
             * 
             * @returns {plat.web.Router}
             */
            constructor() {
                var ContextManager: observable.IContextManagerStatic = acquire(__ContextManagerStatic);
                ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));

                this._removeListener = this.$EventManagerStatic.on(this.uid, 'urlChanged',
                    (ev: events.IDispatchEventInstance, utils: web.IUrlUtilsInstance) => {
                    postpone(() => {
                        this._routeChanged(ev, utils);
                    });
                }, this);

                var $browserConfig = this.$BrowserConfig;
                if ($browserConfig.routingType === $browserConfig.NONE) {
                    $browserConfig.routingType = $browserConfig.HASH;
                    $browserConfig.hashPrefix = $browserConfig.hashPrefix || '';
                }

                if (this.$Compat.msApp) {
                    this.__history = [];
                }
            }

            /**
             * @name registerRoutes
             * @memberof plat.web.Router
             * @kind function
             * @access public
             * 
             * @description
             * Registers route strings/RegExps and associates them with a control type.
             * 
             * @param {string} type The control type with which to associate the routes.
             * @param {Array<any>} routes An array of strings or RegExp expressions to associate with 
             * the control type.
             * 
             * @returns {void}
             */
            registerRoutes(type: string, routes: Array<any>): void {
                if (!isArray(routes)) {
                    return;
                }

                var injector = viewControlInjectors[type],
                    length = routes.length;

                for (var i = 0; i < length; ++i) {
                    this._registerRoute(routes[i], injector, type);
                }
            }

            /**
             * @name route
             * @memberof plat.web.Router
             * @kind function
             * @access public
             * 
             * @description
             * Formats a url path given the parameters and query string, then changes the 
             * url to that path.
             * 
             * @param {string} path The route path to navigate to.
             * @param {plat.web.IRouteNavigationOptions} options? The {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}  
             * included with this route.
             * 
             * @returns {boolean} Whether or not the route operation was a success.
             */
            route(path: string, options?: IRouteNavigationOptions): boolean {
                options = options || <IRouteNavigationOptions>{};

                var replace = options.replace,
                    route: string,
                    match: IMatchedRoute,
                    $browser = this.$Browser,
                    currentUtils: IUrlUtilsInstance = $browser.urlUtils();

                if (this.__firstRoute) {
                    this.__firstRoute = false;
                    if (isEmpty(path)) {
                        this._routeChanged(null, currentUtils);
                        return true;
                    }
                }

                var build = this._buildRoute(path, options.query);

                if (isNull(build)) {
                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                    $exception.warn('Route: ' + path + ' is not a matched route.', $exception.NAVIGATION);
                    return false;
                }

                route = build.route;
                match = build.match;

                var event = this.$NavigationEventStatic.dispatch('beforeRouteChange', this, {
                    parameter: match.route,
                    target: match.injector,
                    type: match.type,
                    options: null,
                    cancelable: true
                });

                if (event.cancelled) {
                    return false;
                }

                var nextUtils = $browser.urlUtils(route);

                if (currentUtils.href === nextUtils.href) {
                    replace = true;
                }

                $browser.url(route, replace);
                return true;
            }

            /**
             * @name goBack
             * @memberof plat.web.Router
             * @kind function
             * @access public
             * 
             * @description
             * Navigates back in the history.
             * 
             * @param {number} length? The number of entries to go back in the history.
             * 
             * @returns {void}
             */
            goBack(length?: number): void {
                this.$Window.history.go(-length);

                var history = this.__history;
                if (isArray(history) && history.length > 1) {
                    this.__history = history.slice(0, history.length - length);
                    this.$Browser.url(this.__history.pop() || '');
                }
            }

            /**
             * @name _buildRoute
             * @memberof plat.web.Router
             * @kind function
             * @access protected
             * 
             * @description
             * Builds a valid route with a valid query string to use for navigation.
             * 
             * @param {string} routeParameter The route portion of the navigation path. Used to 
             * match with a registered {@link plat.ui.WebViewControl|WebViewControl}.
             * @param {plat.IObject<string>} query The route query object if passed into the 
             * {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}.
             * 
             * @returns {{ route: string; match: plat.web.IMatchedRoute; }} An object containing 
             * both the fully evaluated route and the corresponding {@link plat.web.IMatchedRoute|IMatchedRoute}.
             */
            _buildRoute(routeParameter: string, query: IObject<string>): { route: string; match: IMatchedRoute; } {
                var queryStr = this._buildQueryString(query);

                if (!isString(routeParameter)) {
                    return;
                }

                var route = routeParameter + queryStr,
                    utils = this.$Browser.urlUtils(route),
                    match = this._match(utils);

                if (isNull(match)) {
                    return;
                }

                return {
                    route: route,
                    match: match
                };
            }

            /**
             * @name _buildQueryString
             * @memberof plat.web.Router
             * @kind function
             * @access protected
             * 
             * @description
             * Builds the query string if a query object was passed into 
             * the {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}.
             * 
             * @param {plat.IObject<string>} query The query object passed in.
             * 
             * @returns {string} The built query string.
             */
            _buildQueryString(query: IObject<string>): string {
                var queryStr: Array<string> = [];

                if (!isObject(query)) {
                    return queryStr.join();
                }

                var keys = Object.keys(query),
                    length = keys.length,
                    key: string;

                for (var i = 0; i < length; ++i) {
                    key = keys[i];

                    queryStr.push(key + '=' + query[key]);
                }

                return '?' + queryStr.join('&');
            }

            /**
             * @name _routeChanged
             * @memberof plat.web.Router
             * @kind function
             * @access protected
             * 
             * @description
             * The method called when the route function is invoked 
             * or on a 'urlChanged' event.
             * 
             * @param {plat.events.IDispatchEventInstance} ev The 'urlChanged' event object.
             * @param {plat.web.IUrlUtilsInstance} utils The {@link plat.web.IUrlUtils|IUrlUtils} 
             * created for the invoked route function.
             * 
             * @returns {void}
             */
            _routeChanged(ev: events.IDispatchEventInstance, utils: web.IUrlUtilsInstance): void {
                var matchedRoute = this._match(utils);

                if (isNull(matchedRoute)) {
                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                    $exception.warn('Could not match route: ' + utils.pathname,
                        $exception.NAVIGATION);
                    return;
                }

                if (this.__history) {
                    this.__history.push(matchedRoute.route.path);
                }

                this.$NavigationEventStatic.dispatch('routeChanged', this, {
                    parameter: matchedRoute.route,
                    target: matchedRoute.injector,
                    type: matchedRoute.type,
                    options: null,
                    cancelable: false
                });
            }

            /**
             * @name _registerRoute
             * @memberof plat.web.Router
             * @kind function
             * @access protected
             * 
             * @description
             * Registers a {@link plat.ui.WebViewControl|WebViewControl's} route.
             * 
             * @param {any} route Can be either a string or RegExp.
             * @param {plat.dependency.IInjector<plat.ui.IBaseViewControl>} injector The injector for the 
             * {@link plat.ui.WebViewControl|WebViewControl} defined by the type.
             * @param {string} type The control type.
             * 
             * @returns {void}
             */
            _registerRoute(route: any, injector: dependency.IInjector<ui.IBaseViewControl>, type: string): void {
                var regexp = isRegExp(route),
                    routeParameters: IRouteMatcher;

                if (!(regexp || isString(route))) {
                    return;
                } else if (regexp) {
                    routeParameters = {
                        regex: route,
                        type: type,
                        injector: injector,
                        args: []
                    };
                } else if (isEmpty(route)) {
                    this._defaultRoute = {
                        injector: injector,
                        type: type
                    };
                    return;
                } else if (route.trim() === '/') {
                    this._baseRoute = {
                        injector: injector,
                        type: type
                    };
                    return;
                } else {
                    if (route[0] === '/') {
                        route = (<string>route).slice(1);
                    }
                    routeParameters = this._getRouteParameters(route);
                    routeParameters.injector = injector;
                    routeParameters.type = type;
                }

                this._routes.push(routeParameters);
            }

            /**
             * @name _getRouteParameters
             * @memberof plat.web.Router
             * @kind function
             * @access protected
             * 
             * @description
             * Parses the route and pulls out route parameters. Then 
             * converts them to regular expressions to match for 
             * routing.
             * 
             * @param {string} route The route to parse.
             * 
             * @returns {plat.web.IRouteMatcher} The object used to match a 
             * route with a {@link plat.ui.BaseViewControl|BaseViewControl's} injector.
             */
            _getRouteParameters(route: string): IRouteMatcher {
                var $regex = this.$Regex,
                    namedRegex = $regex.namedParameterRouteRegex,
                    escapeRegex = this.__escapeRegex,
                    optionalRegex = this.__optionalRegex,
                    wildcardRegex = $regex.wildcardRouteRegex,
                    regexArgs = route.match(namedRegex),
                    wildcard = wildcardRegex.exec(route),
                    args: Array<string> = [];

                route = route.replace(escapeRegex, '\\$')
                    .replace(optionalRegex, '(?:$1)?')
                    .replace(namedRegex, (match, optional)
                        => optional ? match : '([^/?]+)')
                    .replace(wildcardRegex, '([^?]*?)');

                if (!isNull(regexArgs)) {
                    var length = regexArgs.length;

                    for (var i = 0; i < length; ++i) {
                        args.push(regexArgs[i].slice(1));
                    }
                }

                if (!isNull(wildcard)) {
                    var wildCardName = wildcard[0].slice(1);

                    if (isEmpty(wildCardName)) {
                        wildCardName = 'wildcard';
                    }

                    args.push(wildCardName);
                }

                return {
                    regex: new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$'),
                    args: args
                };
            }

            /**
             * @name _match
             * @memberof plat.web.Router
             * @kind function
             * @access protected
             * 
             * @description
             * Matches a route to a registered route using the 
             * registered route's regular expression.
             * 
             * @param {plat.web.IUrlUtilsInstance} utils The utility used to obtain 
             * the url fragment and the url query.
             * 
             * @returns {plat.web.IMatchedRoute} The matched route with the matched control 
             * injector.
             */
            _match(utils: web.IUrlUtilsInstance): IMatchedRoute {
                var routes = this._routes,
                    url = this._getUrlFragment(utils),
                    route: IRouteMatcher,
                    exec: RegExpExecArray,
                    args: Array<string>,
                    routeParams: IObject<string> = {},
                    path: string,
                    argsLength: number,
                    length = routes.length;

                if (isEmpty(url)) {
                    var base = this._baseRoute || this._defaultRoute;

                    if (isNull(base)) {
                        return;
                    }

                    return {
                        injector: base.injector,
                        type: base.type,
                        route: {
                            path: url,
                            parameters: {},
                            query: utils.query
                        }
                    };
                }

                for (var i = 0; i < length; ++i) {
                    route = routes[i];
                    exec = route.regex.exec(url);

                    if (isNull(exec)) {
                        continue;
                    }

                    args = route.args;
                    argsLength = args.length;
                    path = exec.input;

                    if (argsLength === 0) {
                        args = Object.keys(exec.slice());
                        exec.unshift('');
                        argsLength = args.length;
                    }

                    for (var j = 0; j < argsLength; ++j) {
                        routeParams[args[j]] = exec[j + 1];
                    }

                    return {
                        injector: route.injector,
                        type: route.type,
                        route: {
                            path: path,
                            parameters: routeParams,
                            query: utils.query
                        }
                    };
                }

                var defaultRoute = this._defaultRoute;
                if (isNull(defaultRoute)) {
                    return;
                }

                return {
                    injector: defaultRoute.injector,
                    type: defaultRoute.type,
                    route: {
                        path: url,
                        parameters: {},
                        query: utils.query
                    }
                };
            }

            /**
             * @name _getUrlFragment
             * @memberof plat.web.Router
             * @kind function
             * @access protected
             * 
             * @description
             * Trims the first and last slash on the URL pathname and returns it.
             * 
             * @param {plat.web.IUrlUtilsInstance} utils The utility used to obtain 
             * the url fragment.
             * 
             * @returns {string} The trimmed URL pathname.
             */
            _getUrlFragment(utils: web.IUrlUtilsInstance): string {
                return utils.pathname.replace(this.__pathSlashRegex, '');
            }
        }

        /**
         * The Type for referencing the '$Router' injectable as a dependency.
         */
        export function IRouter(): IRouter {
            return new Router();
        }

        register.injectable(__Router, IRouter);

        /**
         * @name IRouter
         * @memberof plat.web
         * @kind interface
         * 
         * @description
         * Describes the object that handles route registration and navigation 
         * to and from {@link plat.ui.IWebViewControl|IWebViewControls} within a 
         * {@link plat.ui.controls.Routeport|Routeport}.
         */
        export interface IRouter {
            /**
             * @name uid
             * @memberof plat.web.IRouter
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A unique string identifier.
             */
            uid: string;

            /**
             * @name registerRoutes
             * @memberof plat.web.IRouter
             * @kind function
             * @access public
             * 
             * @description
             * Registers route strings/RegExps and associates them with a control type.
             * 
             * @param {string} type The control type with which to associate the routes.
             * @param {Array<any>} routes An array of strings or RegExp expressions to associate with 
             * the control type.
             * 
             * @returns {void}
             */
            registerRoutes(type: string, routes: Array<any>): void;

            /**
             * @name route
             * @memberof plat.web.IRouter
             * @kind function
             * @access public
             * 
             * @description
             * Formats a url path given the parameters and query string, then changes the 
             * url to that path.
             * 
             * @param {string} path The route path to navigate to.
             * @param {plat.web.IRouteNavigationOptions} options? The {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}  
             * included with this route.
             * 
             * @returns {boolean} Whether or not the route operation was a success.
             */
            route(path: string, options?: web.IRouteNavigationOptions): boolean;

            /**
             * @name goBack
             * @memberof plat.web.IRouter
             * @kind function
             * @access public
             * 
             * @description
             * Navigates back in the history.
             * 
             * @param {number} length? The number of entries to go back in the history.
             * 
             * @returns {void}
             */
            goBack(length?: number): void;
        }

        /**
         * @name IRouteNavigationOptions
         * @memberof plat.web
         * @kind interface
         * 
         * @extends {plat.navigation.IBaseNavigationOptions}
         * 
         * @description
         * Options that you can submit to the router in order
         * to customize navigation.
         */
        export interface IRouteNavigationOptions extends navigation.IBaseNavigationOptions {
            /**
             * @name query
             * @memberof plat.web.IRouteNavigationOptions
             * @kind property
             * @access public
             * 
             * @type {plat.IObject<string>}
             * 
             * @description
             * An object that includes the query parameters to be inserted into the route 
             * as the query string.
             */
            query?: IObject<string>;
        }

        /**
         * @name IRouteMatcher
         * @memberof plat.web
         * @kind interface
         * 
         * @description
         * Used by the navigator for matching a route with 
         * a {@link plat.ui.IBaseViewControl|IBaseViewControl's} injector.
         */
        export interface IRouteMatcher {
            /**
             * @name injector
             * @memberof plat.web.IRouteMatcher
             * @kind property
             * @access public
             * 
             * @type {plat.dependency.IInjector<plat.ui.IBaseViewControl>}
             * 
             * @description
             * The {@link plat.ui.IBaseViewControl|IBaseViewControl} injector.
             */
            injector?: dependency.IInjector<ui.IBaseViewControl>;

            /**
             * @name type
             * @memberof plat.web.IRouteMatcher
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             */
            type?: string;

            /**
             * @name regex
             * @memberof plat.web.IRouteMatcher
             * @kind property
             * @access public
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression to match with the url.
             */
            regex: RegExp;

            /**
             * @name args
             * @memberof plat.web.IRouteMatcher
             * @kind property
             * @access public
             * 
             * @type {Array<string>}
             * 
             * @description
             * Route arguments used to create route parameters  
             * in the event of a url match.
             */
            args: Array<string>;
        }

        /**
         * @name IMatchedRoute
         * @memberof plat.web
         * @kind interface
         * 
         * @description
         * Provides a {@link plat.dependency.IInjector<plat.ui.IBaseViewControl>|IInjector<IBaseViewControl>} that matches 
         * the given {@link plat.web.IRoute|IRoute}.
         */
        export interface IMatchedRoute {
            /**
             * @name injector
             * @memberof plat.web.IMatchedRoute
             * @kind property
             * @access public
             * 
             * @type {plat.dependency.IInjector<plat.ui.IBaseViewControl>}
             * 
             * @description
             * The associated {@link plat.dependency.IInjector<plat.ui.IBaseViewControl>|IInjector<IBaseViewControl>} for the route.
             */
            injector: dependency.IInjector<ui.IBaseViewControl>;

            /**
             * @name type
             * @memberof plat.web.IMatchedRoute
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             */
            type: string;

            /**
             * @name route
             * @memberof plat.web.IMatchedRoute
             * @kind property
             * @access public
             * 
             * @type {plat.web.IRoute<any>}
             * 
             * @description
             * The route associated with this object's injector.
             */
            route?: IRoute<any>;
        }

        /**
         * @name IRoute
         * @memberof plat.web
         * @kind interface
         * 
         * @typeparam {{}} T The type of the defined parameters matched with this route.
         * 
         * @description
         * Contains the parsed properties of a url.
         */
        export interface IRoute<T extends {}> {
            /**
             * @name parameters
             * @memberof plat.web.IRoute
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The defined parameters that were matched with the route. 
             * When a route is registered, the registrant can specify named 
             * route parameters. Those parameters will appear in this object 
             * as key/value pairs.
             */
            parameters: T;

            /**
             * @name path
             * @memberof plat.web.IRoute
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * This property will always exist and will be equal to the full
             * route for navigation (only the path from root, not including 
             * the query string).
             */
            path: string;

            /**
             * @name query
             * @memberof plat.web.IRoute
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * An object containing query string key/value pairs.
             */
            query?: any;
        }
    }
    /**
     * @name async
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds all classes and interfaces related to async components in platypus.
     */
    export module async {
        /**
         * @name Promise
         * @memberof plat.async
         * @kind class
         * 
         * @implements {plat.async.IThenable}
         * 
         * @description
         * Takes in a generic type corresponding to the fullfilled success type. 
         * 
         * @typeparam {any} R The return type of the promise.
         */
        export class Promise<R> implements IThenable<R> {
            /**
             * @name __subscribers
             * @memberof plat.async.Promise
             * @kind property
             * @access private
             * 
             * @type {Array<any>}
             * 
             * @description
             * Holds all the subscriber promises
             */
            private __subscribers: Array<any>;

            /**
             * @name __state
             * @memberof plat.async.Promise
             * @kind property
             * @access private
             * 
             * @type {plat.async.State}
             * 
             * @description
             * The state of the promise (fulfilled/rejected)
             */
            private __state: State;

            /**
             * @name __detail
             * @memberof plat.async.Promise
             * @kind property
             * @access private
             * 
             * @type {any}
             * 
             * @description
             * The return detail of a promise.
             */
            private __detail: any;

            /**
             * @name config
             * @memberof plat.async.Promise
             * @kind property
             * @access public
             * @static
             * 
             * @type {any}
             * 
             * @description
             * The configuration for creating asynchronous promise flushing.
             */
            static config = {
                /**
                 * Handles asynchronous flushing of callbacks. If the callback queue is of 
                 * length 1, then we need to schedule a flush. Afterward, any additional 
                 * callbacks added to the queue will be flushed accordingly.
                 */
                async: (callback: (arg?: IThenable<any>) => void, arg?: IThenable<any>) => {
                    var length = queue.push([callback, arg]);
                    if (length === 1) {
                        scheduleFlush();
                    }
                }
            };

            /**
             * @name all
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Returns a promise that fulfills when every item in the array is fulfilled.
             * Casts arguments to promises if necessary. The result argument of the 
             * returned promise is an array containing the fulfillment result arguments 
             * in-order. The rejection argument is the rejection argument of the 
             * first-rejected promise.
             * 
             * @typeparam {any} R The return type of the promises.
             * 
             * @param {Array<plat.async.IThenable<R>>} promises An array of promises, although every argument is potentially
             * cast to a promise meaning not every item in the array needs to be a promise.
             * 
             * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.
             */
            static all<R>(promises: Array<IThenable<R>>): IThenable<Array<R>>;
            /**
             * @name all
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Returns a promise that fulfills when every item in the array is fulfilled.
             * Casts arguments to promises if necessary. The result argument of the 
             * returned promise is an array containing the fulfillment result arguments 
             * in-order. The rejection argument is the rejection argument of the 
             * first-rejected promise.
             * 
             * @typeparam {any} R The type of the promises.
             * 
             * @param {Array<R>} promises An array of objects, if an object is not a promise, it will be cast.
             * 
             * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.
             */
            static all<R>(promises: Array<R>): IThenable<Array<R>>;
            static all(promises: Array<any>): IThenable<Array<any>> {
                if (!isArray(promises)) {
                    return Promise.all([promises]);
                }

                return new Promise<Array<any>>((resolve: (value?: Array<any>) => void, reject: (reason?: any) => void) => {
                    var results: Array<any> = [],
                        remaining = promises.length,
                        promise: Promise<any>;

                    if (remaining === 0) {
                        resolve(<any>[]);
                    }

                    function resolver(index: number) {
                        return (value: any) => resolveAll(index, value);
                    }

                    function resolveAll(index: number, value: any) {
                        results[index] = value;
                        if (--remaining === 0) {
                            resolve(<any>results);
                        }
                    }

                    for (var i = 0; i < promises.length; i++) {
                        promise = promises[i];

                        if (isPromise(promise)) {
                            promise.then(resolver(i), reject);
                        } else {
                            resolveAll(i, promise);
                        }
                    }
                });
            }

            /**
             * @name cast
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a promise that fulfills to the passed in object. If the
             * passed-in object is a promise it returns the promise.
             * 
             * @typeparam {any} R The type of the input object to cast to a promise.
             * 
             * @param object The object to cast to a Promise.
             */
            static cast<R>(object?: R): Promise<R> {
                if (isObject(object) && (<any>object).constructor === Promise) {
                    return <Promise<R>>(<any>object);
                }

                return new Promise<R>((resolve: (value: R) => any) => resolve(object));
            }

            /**
             * @name race
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Returns a promise that fulfills as soon as any of the promises fulfill,
             * or rejects as soon as any of the promises reject (whichever happens first).
             * 
             * @typeparam {any} R The return type of the input promises.
             * 
             * @param {Array<plat.async.IThenable<R>>} promises An Array of promises to 'race'.
             * 
             * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input 
             * promises fulfilled.
             */
            static race<R>(promises: Array<IThenable<R>>): IThenable<R>;
            /**
             * @name race
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Returns a promise that fulfills as soon as any of the promises fulfill,
             * or rejects as soon as any of the promises reject (whichever happens first).
             * 
             * @typeparam {any} R The type of the input objects.
             * 
             * @param {Array<R>} promises An Array of anything to 'race'. Objects that aren't promises will
             * be cast.
             * 
             * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input 
             * promises fulfilled.
             */
            static race<R>(promises: Array<R>): IThenable<R>;
            static race(promises: Array<any>): IThenable<any> {
                if (!isArray(promises)) {
                    return Promise.race([promises]);
                }

                return new Promise<any>((resolve: (value: any) => any, reject: (error: any) => any) => {
                    var promise: Promise<any>;

                    for (var i = 0; i < promises.length; i++) {
                        promise = promises[i];

                        if (promise && typeof promise.then === 'function') {
                            promise.then(resolve, reject);
                        } else {
                            resolve(<any>promise);
                        }
                    }
                });
            }

            /**
             * @name resolve
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a promise that resolves with the input value.
             * 
             * @typeparam {any} R The value with which to resolve the promise.
             * 
             * @param {R} value The value to resolve.
             * 
             * @returns {plat.async.IThenable<R>} A promise that will resolve with the associated value.
             */
            static resolve<R>(value?: R): IThenable<R> {
                return new Promise<R>((resolve: (value: R) => any, reject: (reason: any) => any) => {
                    resolve(value);
                });
            }

            /**
             * @name reject
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a promise that rejects with the input value.
             * 
             * @param {any} error The value to reject.
             * 
             * @returns {plat.async.IThenable<any>} A promise that will reject with the error.
             */
            static reject(error?: any): IThenable<any> {
                return new Promise<any>((resolve: (value: any) => any, reject: (error: any) => any) => {
                    reject(error);
                });
            }

            /**
             * @name __invokeResolveFunction
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Invokes the resolve function for a promise. Handles error catching.
             * 
             * @typeparam {any} R The return type of the input {@link plat.async.Promise|Promise}.
             * 
             * @param {plat.async.IResolveFunction<R>} resolveFunction The resolve function to invoke.
             * @param {plat.async.Promise<R>} promise The promise on which to invoke the resolve function.
             * 
             * @returns {void}
             */
            private static __invokeResolveFunction<R>(resolveFunction: IResolveFunction<R>,
                promise: Promise<R>): void {
                function resolvePromise(value?: any) {
                    Promise.__resolve<R>(promise, value);
                }

                function rejectPromise(reason?: any) {
                    Promise.__reject(promise, reason);
                }

                try {
                    resolveFunction(resolvePromise, rejectPromise);
                } catch (e) {
                    rejectPromise(e);
                }
            }

            /**
             * @name __invokeCallback
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Invokes a callback for a promise with the specified detail.
             * 
             * @param {plat.async.State} settled The state of the promise.
             * @param {any} promise The promise object.
             * @param {(response: any) => void} callback The callback to invoke.
             * @param {any} detail The details to pass to the callback.
             * 
             * @returns {void}
             */
            private static __invokeCallback(settled: State, promise: any, callback: (response: any) => void, detail: any): void {
                var hasCallback = isFunction(callback),
                    value: any,
                    error: Error,
                    succeeded: boolean,
                    failed: boolean;

                if (hasCallback) {
                    try {
                        value = callback(detail);
                        succeeded = true;
                    } catch (e) {
                        failed = true;
                        error = e;
                    }
                } else {
                    value = detail;
                    succeeded = true;
                }

                if (Promise.__handleThenable<any>(promise, value)) {
                    return;
                } else if (hasCallback && succeeded) {
                    Promise.__resolve<any>(promise, value);
                } else if (failed) {
                    Promise.__reject(promise, error);
                } else if (settled === State.FULFILLED) {
                    Promise.__resolve<any>(promise, value);
                } else if (settled === State.REJECTED) {
                    Promise.__reject(promise, value);
                }
            }

            /**
             * @name __publish
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Publishes the promise details to all the subscribers for a promise.
             * 
             * @param {any} promise The promise object.
             * @param {plat.async.State} settled The state of the promise.
             * 
             * @returns {void}
             */
            private static __publish(promise: Promise<any>, settled: State): void {
                var subscribers = promise.__subscribers,
                    detail = promise.__detail,
                    child: any,
                    callback: () => void;

                for (var i = 0; i < subscribers.length; i += 3) {
                    child = subscribers[i];
                    callback = subscribers[i + settled];

                    Promise.__invokeCallback(settled, child, callback, detail);
                }

                promise.__subscribers = null;
            }

            /**
             * @name __publishFulfillment
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Publishes a promises that has been fulfilled.
             * 
             * @param {any} promise The promise object.
             * 
             * @returns {void}
             */
            private static __publishFulfillment(promise: any): void {
                Promise.__publish(promise, promise.__state = State.FULFILLED);
            }

            /**
             * @name __publishRejection
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Publishes a promises that has been rejected.
             * 
             * @param {any} promise The promise object.
             * 
             * @returns {void}
             */
            private static __publishRejection(promise: any): void {
                Promise.__publish(promise, promise.__state = State.REJECTED);
            }

            /**
             * @name __reject
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Asynchronously rejects a promise
             * 
             * @param {any} promise The promise object.
             * @param {any} reason The detail of the rejected promise.
             * 
             * @returns {void}
             */
            private static __reject(promise: any, reason: any): void {
                if (promise.__state !== State.PENDING) {
                    return;
                }
                promise.__state = State.SEALED;
                promise.__detail = reason;

                Promise.config.async(Promise.__publishRejection, promise);
            }

            /**
             * @name __fulfill
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Asynchronously fulfills a promise
             * 
             * @typeparam {any} R The return type of the promise.
             * 
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {any} value The detail of the fulfilled promise.
             * 
             * @returns {void}
             */
            private static __fulfill<R>(promise: Promise<R>, value: any): void {
                if (promise.__state !== State.PENDING) {
                    return;
                }
                promise.__state = State.SEALED;
                promise.__detail = value;

                Promise.config.async(Promise.__publishFulfillment, promise);
            }

            /**
             * @name __resolve
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Asynchronously fulfills a promise, allowing for promise chaining.
             * 
             * @typeparam {any} R The return type of the promise.
             * 
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {any} value The detail of the fulfilled promise.
             * 
             * @returns {void}
             */
            private static __resolve<R>(promise: Promise<R>, value: any): void {
                if (promise === value) {
                    Promise.__fulfill(promise, value);
                } else if (!Promise.__handleThenable<R>(promise, value)) {
                    Promise.__fulfill(promise, value);
                }
            }

            /**
             * @name __handleThenable
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Handles chaining promises together, when a promise is returned from within a then handler.
             * 
             * @typeparam {any} R The return type of the promise.
             * 
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {plat.async.Promise<R>} value The next promise to await.
             * 
             * @returns {boolean} Whether or not the value passed in is a promise.
             */
            private static __handleThenable<R>(promise: Promise<R>, value: Promise<R>): boolean {
                var resolved: boolean;

                try {
                    if (promise === value) {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.fatal(new TypeError('A promises callback cannot return the same promise.'),
                            $exception.PROMISE);
                    }

                    if (isPromise(value)) {
                        value.then.call(value, (val: any) => {
                            if (resolved) {
                                return true;
                            }
                            resolved = true;

                            if (value !== val) {
                                Promise.__resolve<R>(promise, val);
                            } else {
                                Promise.__fulfill<R>(promise, val);
                            }
                        }, (val: any) => {
                            if (resolved) {
                                return true;
                            }
                            resolved = true;

                            Promise.__reject(promise, val);
                        });

                        return true;
                    }
                } catch (error) {
                    if (resolved) {
                        return true;
                    }
                    Promise.__reject(promise, error);
                    return true;
                }

                return false;
            }

            /**
             * @name __subscribe
             * @memberof plat.async.Promise
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Adds a child promise to the parent's subscribers.
             * 
             * @typeparam {any} R The return type of the promise.
             * 
             * @param {plat.async.Promise<any>} parent The parent promise.
             * @param {plat.async.Promise<any>} value The child promise.
             * @param {(success: any) => any} onFullfilled The fulfilled method for the child.
             * @param {(error: any) => any} onRejected The rejected method for the child.
             * 
             * @returns {void}
             */
            private static __subscribe(parent: Promise<any>, child: IThenable<any>,
                onFulfilled: (success: any) => any, onRejected: (error: any) => any): void {
                var subscribers = parent.__subscribers;
                var length = subscribers.length;

                subscribers[length] = child;
                subscribers[length + State.FULFILLED] = onFulfilled;
                subscribers[length + State.REJECTED] = onRejected;
            }

            /**
             * @name constructor
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * 
             * @description
             * An ES6 implementation of the Promise API. Useful for asynchronous programming.
             * Takes in 2 generic types corresponding to the fullfilled success and error types. 
             * The error type (U) should extend Error in order to get proper stack tracing.
             * 
             * @typeparam {any} R The return type of the promise.
             * 
             * @param {plat.async.IResolveFunction<R>} resolveFunction A IResolveFunction for fulfilling/rejecting the Promise.
             * 
             * @returns {plat.async.Promise<R>} A promise object.
             */
            constructor(resolveFunction: IResolveFunction<R>) {
                var $exception: IExceptionStatic;
                if (!isFunction(resolveFunction)) {
                    $exception = acquire(__ExceptionStatic);
                    $exception.fatal(new TypeError('You must pass a resolver function as the first argument to the promise constructor'),
                        $exception.PROMISE);
                }

                if (!(this instanceof Promise)) {
                    $exception = acquire(__ExceptionStatic);
                    $exception.fatal(new TypeError('Failed to construct "Promise": ' +
                        'Please use the "new" operator, this object constructor cannot be called as a function.'),
                        $exception.PROMISE);
                }

                this.__subscribers = [];

                Promise.__invokeResolveFunction<R>(resolveFunction, this);
            }

            /**
             * @name then
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => IThenable<U>): IThenable<U>;
            /**
             * @name then
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => U): IThenable<U>;
            /**
             * @name then
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IThenable<U>): IThenable<U>;
            /**
             * @name then
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IThenable<U>;
            then<U>(onFulfilled: (success: R) => any, onRejected?: (error: any) => any): IThenable<U> {
                var promise = this;

                var thenPromise = <IThenable<U>>new (<any>this).constructor(() => { }, this);

                if (this.__state) {
                    var callbacks = arguments;
                    Promise.config.async(() => {
                        Promise.__invokeCallback(promise.__state, thenPromise, callbacks[promise.__state - 1], promise.__detail);
                    });
                } else {
                    Promise.__subscribe(this, thenPromise, onFulfilled, onRejected);
                }

                return thenPromise;
            }

            /**
             * @name catch
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            catch<U>(onRejected: (error: any) => IThenable<U>): IThenable<U>;
            /**
             * @name catch
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            catch<U>(onRejected: (error: any) => U): IThenable<U>;
            catch<U>(onRejected: (error: any) => any): IThenable<U> {
                return this.then(null, onRejected);
            }

            /**
             * @name toString
             * @memberof plat.async.Promise
             * @kind function
             * @access public
             * 
             * @description
             * Outputs the Promise as a readable string.
             */
            toString() {
                return '[object Promise]';
            }
        }

        /**
         * @name IThenable
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * Describes a chaining function that fulfills when the previous link is complete and is 
         * able to be caught in the case of an error.
         * 
         * @typeparam {any} R The return type of the thenable.
         */
        export interface IThenable<R> {
            /**
             * @name then
             * @memberof plat.async.IThenable
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => plat.async.IThenable<U>} onRejected? A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => IThenable<U>): IThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IThenable
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => U} onRejected? A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => U): IThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IThenable
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => plat.async.IThenable<U>} onRejected? A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IThenable<U>): IThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IThenable
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next
             * onFulfilled method in the promise chain will be called.
             * @param {(error: any) => U} onRejected? A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IThenable<U>;

            /**
             * @name catch
             * @memberof plat.async.IThenable
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            catch<U>(onRejected: (error: any) => IThenable<U>): IThenable<U>;
            /**
             * @name catch
             * @memberof plat.async.IThenable
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.
             */
            catch<U>(onRejected: (error: any) => U): IThenable<U>;
        }

        enum State {
            PENDING = <any>(void 0),
            SEALED = 0,
            FULFILLED = 1,
            REJECTED = 2
        };

        var browserGlobal: any = (typeof window !== 'undefined') ? window : {},
            BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;

        // node
        function useNextTick(): () => void {
            return () => {
                process.nextTick(flush);
            };
        }

        function useMutationObserver(): () => void {
            var observer = new BrowserMutationObserver(flush),
                $document = acquire(__Document),
                $window = acquire(__Window),
                element = $document.createElement('div');

            observer.observe(element, { attributes: true });

            $window.addEventListener('unload', () => {
                observer.disconnect();
                observer = null;
            }, false);

            return () => {
                element.setAttribute('drainQueue', 'drainQueue');
            };
        }

        function useSetTimeout(): () => void {
            var global: any = global,
                local = (typeof global !== 'undefined') ? global : this;

            return () => {
                local.setTimeout(flush, 1);
            };
        }

        var queue: Array<any> = [];
        function flush(): void {
            var tuple: Array<(response: any) => void>,
                callback: (response: any) => void,
                arg: any;

            for (var i = 0; i < queue.length; i++) {
                tuple = queue[i];
                callback = tuple[0];
                arg = tuple[1];
                callback(arg);
            }
            queue = [];
        }

        var process: any = process,
            scheduleFlush: () => void;

        // decide what async method to use to triggering processing of queued callbacks:
        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
            scheduleFlush = useNextTick();
        } else if (BrowserMutationObserver) {
            scheduleFlush = useMutationObserver();
        } else {
            scheduleFlush = useSetTimeout();
        }

        /**
         * Describes a function passed into the constructor for a Promise. The function allows you to
         * resolve/reject the Promise.
         */
        export interface IResolveFunction<R> {
            /**
             * A function which allows you to resolve/reject a Promise.
             * 
             * @param resolve A method for resolving a Promise. If you pass in a 'thenable' argument 
             * (meaning if you pass in a Promise-like object), then the promise will resolve with the 
             * outcome of the object. Else the promise will resolve with the argument.
             * @param reject A method for rejecting a promise. The argument should be an instancof Error
             * to assist with debugging. If a method in the constructor for a Promise throws an error, 
             * the promise will reject with the error.
             */
            (resolve: (value?: R) => void, reject: (reason?: any) => void): void;
        }

        /**
         * The Type for referencing the '$Promise' injectable as a dependency.
         */
        export function IPromise($Window?: any): IPromise {
            if (!isNull($Window.Promise) &&
                isFunction($Window.Promise.all) &&
                isFunction($Window.Promise.cast) &&
                isFunction($Window.Promise.race) &&
                isFunction($Window.Promise.resolve) &&
                isFunction($Window.Promise.reject)) {
                return $Window.Promise;
            }
            return Promise;
        }

        register.injectable(__Promise, IPromise, [__Window], __CLASS);

        /**
         * @name IPromise
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * The injectable reference for the ES6 Promise implementation.
         */
        export interface IPromise {
            /**
             * @name constructor
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * 
             * @description
             * An ES6 implementation of the Promise API. Useful for asynchronous programming.
             * Takes in 2 generic types corresponding to the fullfilled success and error types. 
             * The error type (U) should extend Error in order to get proper stack tracing.
             * 
             * @typeparam {any} R The return type of the promise.
             * 
             * @param {plat.async.IResolveFunction<R>} resolveFunction A IResolveFunction for fulfilling/rejecting the Promise.
             * 
             * @returns {plat.async.IThenable<R>} A promise object.
             */
            new <R>(resolveFunction: IResolveFunction<R>): IThenable<R>;

            /**
             * @name all
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Returns a promise that fulfills when every item in the array is fulfilled.
             * Casts arguments to promises if necessary. The result argument of the
             * returned promise is an array containing the fulfillment result arguments
             * in-order. The rejection argument is the rejection argument of the
             * first-rejected promise.
             * 
             * @typeparam {any} R The return type of the promises.
             * 
             * @param {Array<plat.async.IThenable<R>>} promises An array of promises, although every argument is potentially
             * cast to a promise meaning not every item in the array needs to be a promise.
             * 
             * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.
             */
            all<R>(promises: Array<IThenable<R>>): IThenable<Array<R>>;
            /**
             * @name all
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Returns a promise that fulfills when every item in the array is fulfilled.
             * Casts arguments to promises if necessary. The result argument of the 
             * returned promise is an array containing the fulfillment result arguments 
             * in-order. The rejection argument is the rejection argument of the 
             * first-rejected promise.
             * 
             * @typeparam {any} R The type of the promises.
             * 
             * @param {Array<R>} promises An array of objects, if an object is not a promise, it will be cast.
             * 
             * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.
             */
            all<R>(promises: Array<R>): IThenable<Array<R>>;

            /**
             * @name cast
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a promise that fulfills to the passed in object. If the
             * passed-in object is a promise it returns the promise.
             * 
             * @typeparam {any} R The type of the input object to cast to a promise.
             * 
             * @param {R} object The object to cast to a Promise.
             * 
             * @returns {plat.async.IThenable<R>} The cast promise.
             */
            cast<R>(object?: R): IThenable<R>;

            /**
             * @name race
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Returns a promise that fulfills as soon as any of the promises fulfill,
             * or rejects as soon as any of the promises reject (whichever happens first).
             * 
             * @typeparam {any} R The return type of the input promises.
             * 
             * @param {Array<plat.async.IThenable<R>>} promises An Array of promises to 'race'.
             * 
             * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input 
             * promises fulfilled.
             */
            race<R>(promises: Array<IThenable<R>>): IThenable<R>;
            /**
             * @name race
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Returns a promise that fulfills as soon as any of the promises fulfill,
             * or rejects as soon as any of the promises reject (whichever happens first).
             * 
             * @typeparam {any} R The type of the input objects.
             * 
             * @param {Array<R>} promises An Array of anything to 'race'. Objects that aren't promises will
             * be cast.
             * 
             * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input 
             * promises fulfilled.
             */
            race<R>(promises: Array<R>): IThenable<R>;

            /**
             * @name resolve
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a promise that resolves with the input value.
             * 
             * @typeparam {any} R The value with which to resolve the promise.
             * 
             * @param {R} value The value to resolve.
             * 
             * @returns {plat.async.IThenable<R>} A promise that will resolve with the associated value.
             */
            resolve<R>(value: R): IThenable<R>;

            /**
             * @name reject
             * @memberof plat.async.IPromise
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a promise that rejects with the input value.
             * 
             * @param {any} value The value to reject.
             * 
             * @returns {plat.async.IThenable<any>} A promise that will reject with the error.
             */
            reject(error: any): IThenable<any>;
        }

        /**
         * @name HttpRequest
         * @memberof plat.async
         * @kind class
         * @exported false
         * 
         * @implements {plat.async.IHttpRequest}
         * 
         * @description
         * HttpRequest provides a wrapper for the XMLHttpRequest object. Allows for
         * sending AJAX requests to a server. This class does not support 
         * synchronous requests.
         */
        class HttpRequest implements IHttpRequest {
            /**
             * @name clearTimeout
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {plat.IRemoveListener}
             * 
             * @description
             * The timeout ID associated with the specified timeout
             */
            clearTimeout: plat.IRemoveListener;

            /**
             * @name xhr
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {XMLHttpRequest}
             * 
             * @description
             * The created XMLHttpRequest
             */
            xhr: XMLHttpRequest;

            /**
             * @name jsonpCallback
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The JSONP callback name
             */
            jsonpCallback: string;

            /**
             * @name $Browser
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {web.IBrowser}
             * 
             * @description
             * The plat.IBrowser injectable instance
             */
            $Browser: web.IBrowser = acquire(__Browser);

            /**
             * @name $Window
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {Window}
             * 
             * @description
             * The injectable instance of type Window
             */
            $Window: Window = acquire(__Window);

            /**
             * @name $Document
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {Document}
             * 
             * @description
             * The injectable instance of type Document
             */
            $Document: Document = acquire(__Document);

            /**
             * @name $config
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {plat.async.IHttpConfig}
             * 
             * @description
             * The configuration for an HTTP Request
             */
            $config: IHttpConfig = acquire(__HttpConfig);

            /**
             * @name __fileSupported
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the browser supports the File API.
             */
            private __fileSupported = (<ICompat>acquire(__Compat)).fileSupported;

            /**
             * @name __options
             * @memberof plat.async.HttpRequest
             * @kind property
             * @access public
             * 
             * @type {plat.async.IHttpConfig}
             * 
             * @description
             * The configuration for the specific HTTP Request
             */
            private __options: IHttpConfig;

            /**
             * @name constructor
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.async.HttpRequest|HttpRequest}.
             * 
             * @param {plat.async.IHttpConfig} options The IHttpConfigStatic used to customize this HttpRequest.
             * 
             * @returns {plat.async.HttpRequest}
             */
            constructor(options: IHttpConfig) {
                this.__options = extend({}, this.$config, options);
            }

            /**
             * @name execute
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access public
             * 
             * @description
             * Executes an XMLHttpRequest and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.
             * 
             * @typeparam {any} R The response type for the XMLHttpRequest object.
             * 
             * @returns {plat.async.IAjaxPromise} A promise that fulfills when the XMLHttpRequest is done. 
             */
            execute<R>(): IAjaxPromise<R> {
                var options = this.__options,
                    url = options.url;

                if (!isString(url) || isEmpty(url.trim())) {
                    return this._invalidOptions();
                }

                options.url = this.$Browser.urlUtils(url).toString();

                var isCrossDomain = options.isCrossDomain || false,
                    xDomain = false;

                // check if forced cross domain call or cors is not supported (IE9)
                if (isCrossDomain) {
                    xDomain = true;
                } else {
                    this.xhr = new XMLHttpRequest();
                    if (isUndefined(this.xhr.withCredentials)) {
                        xDomain = this.$Browser.isCrossDomain(url);
                    }
                }

                if (xDomain) {
                    this.xhr = null;
                    this.jsonpCallback = options.jsonpCallback || uniqueId('plat_callback');
                    return this.executeJsonp();
                }

                return this._sendXhrRequest();
            }

            /**
             * @name executeJsonp
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access public
             * 
             * @description
             * Executes an JSONP request and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.
             * 
             * @typeparam {any} R The response type for the JSONP callback parameter.
             * 
             * @returns {plat.async.IAjaxPromise} A promise that fulfills when the JSONP request is done. 
             */
            executeJsonp<R>(): IAjaxPromise<R> {
                var options = this.__options,
                    url = options.url;

                if (!isString(url) || isEmpty(url.trim())) {
                    return this._invalidOptions();
                }

                options.url = this.$Browser.urlUtils(url).toString();
                if (isNull(this.jsonpCallback)) {
                    this.jsonpCallback = options.jsonpCallback || uniqueId('plat_callback');
                }

                return new AjaxPromise((resolve, reject) => {
                    var $window = <any>this.$Window,
                        $document = this.$Document,
                        scriptTag = $document.createElement('script'),
                        jsonpCallback = this.jsonpCallback,
                        jsonpIdentifier = options.jsonpIdentifier || 'callback';

                    scriptTag.src = url + '?' + jsonpIdentifier + '=' + jsonpCallback;

                    var oldValue = $window[jsonpCallback];
                    $window[jsonpCallback] = (response: any) => {
                        // clean up
                        if (isFunction(this.clearTimeout)) {
                            this.clearTimeout();
                        }

                        $document.head.removeChild(scriptTag);
                        if (isUndefined(oldValue)) {
                            deleteProperty($window, jsonpCallback);
                        } else {
                            $window[jsonpCallback] = oldValue;
                        }

                        // call callback
                        resolve({
                            response: response,
                            // ok
                            status: 200
                        });
                    };

                    $document.head.appendChild(scriptTag);

                    var timeout = options.timeout;
                    if (isNumber(timeout) && timeout > 0) {
                        // we first postpone to avoid always timing out when debugging, though this is not
                        // a foolproof method.
                        this.clearTimeout = postpone(() => {
                            this.clearTimeout = defer(() => {
                                reject(new AjaxError({
                                    response: 'Request timed out in ' + timeout + 'ms for ' + url,
                                    // request timeout
                                    status: 408
                                }));
                                $window[jsonpCallback] = noop;
                            }, timeout - 1);
                        });
                    }
                }, { __http: this });
            }

            /**
             * @name _xhrOnReadyStateChange
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access protected
             * 
             * @description
             * A wrapper for the XMLHttpRequest's onReadyStateChanged callback.
             * 
             * @returns {boolean} Waits for the readyState to be complete and then 
             * return true in the case of a success and false in the case of 
             * an error.
             */
            _xhrOnReadyStateChange(): boolean {
                var xhr = this.xhr;
                if (xhr.readyState === 4) {
                    var status = xhr.status;

                    if (status === 0) {
                        var response = xhr.response;
                        if (isNull(response)) {
                            try {
                                response = xhr.responseText;
                            } catch (e) { }
                        }

                        // file protocol issue **Needs to be tested more thoroughly**
                        // ok if response is not empty, Not Found otherwise
                        if (!isEmpty(response)) {
                            return true;
                        }

                        return false;
                    }

                    // 304 is not modified
                    if ((status >= 200 && status < 300) || status === 304) {
                        return true;
                    } else {
                        return false;
                    }
                }
                // else {} TODO: add progress for xhr if we choose to add progress to AjaxPromise
            }

            /**
             * @name _sendXhrRequest
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access protected
             * 
             * @description
             * The function that initializes and sends the XMLHttpRequest.
             * 
             * @returns {plat.async.IAjaxPromise} A promise that fulfills with the 
             * formatted {@link plat.async.IAjaxResponse|IAjaxResponse} and rejects if there is a problem with an 
             * {@link plat.async.IAjaxError|IAjaxError}.
             */
            _sendXhrRequest(): IAjaxPromise<any> {
                var xhr = this.xhr,
                    options = this.__options,
                    method = options.method,
                    url = options.url;

                return new AjaxPromise((resolve, reject) => {
                    xhr.onreadystatechange = () => {
                        var success = this._xhrOnReadyStateChange();

                        if (isNull(success)) {
                            return;
                        }

                        var response = this._formatResponse(options.responseType, success);

                        if (success) {
                            resolve(response);
                        } else {
                            reject(new AjaxError(response));
                        }

                        this.xhr = options = null;
                    };

                    if (!isString(method)) {
                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);
                        Exception.warn('AjaxOptions method was not of type string. Defaulting to "GET".', Exception.AJAX);
                        method = 'GET';
                    }

                    xhr.open(
                        method.toUpperCase(),
                        url,
                        // synchronous XHR not supported
                        true,
                        options.user,
                        options.password
                        );

                    var responseType = options.responseType;
                    if (!(this.__fileSupported || responseType === '' || responseType === 'text')) {
                        responseType = '';
                    }

                    xhr.responseType = responseType;
                    xhr.withCredentials = options.withCredentials;

                    var mimeType = options.overrideMimeType,
                        data = options.data;

                    if (isString(mimeType) && !isEmpty(mimeType)) {
                        xhr.overrideMimeType(mimeType);
                    }

                    if (isNull(data) || data === '') {
                        // no data exists so set headers and send request
                        this.__setHeaders();
                        xhr.send();
                    } else {
                        var transforms = options.transforms || [],
                            length = transforms.length,
                            contentType = options.contentType,
                            contentTypeExists = isString(contentType) && !isEmpty(contentType);

                        if (length > 0) {
                            // if data transforms defined, assume they're going to take care of 
                            // any and all transformations.
                            for (var i = 0; i < length; ++i) {
                                data = transforms[i](data, xhr);
                            }

                            // if contentType exists, assume they did not set it in 
                            // their headers as well
                            if (contentTypeExists) {
                                xhr.setRequestHeader('Content-Type', contentType);
                            }

                            this.__setHeaders();
                            xhr.send(data);
                        } else if (isObject(data)) {
                            // if isObject and contentType exists we want to transform the data
                            if (contentTypeExists) {
                                var contentTypeLower = contentType.toLowerCase();
                                if (contentTypeLower.indexOf('x-www-form-urlencoded') !== -1) {
                                    // perform an encoded form transformation
                                    data = this.__serializeFormData();
                                    // set Content-Type header because we're assuming they didn't set it 
                                    // in their headers object
                                    xhr.setRequestHeader('Content-Type', contentType);
                                    this.__setHeaders();
                                    xhr.send(data);
                                } else if (contentTypeLower.indexOf('multipart/form-data') !== -1) {
                                    // need to check if File is a supported object
                                    if (this.__fileSupported) {
                                        // use FormData
                                        data = this.__appendFormData();
                                        // do not set the Content-Type header due to modern browsers 
                                        // setting special headers for multipart/form-data
                                        this.__setHeaders();
                                        xhr.send(data);
                                    } else {
                                        // use iframe trick for older browsers (do not send a request)
                                        // this case is the reason for this giant, terrible, nested if-else statement
                                        this.__submitFramedFormData().then((response) => {
                                            resolve(response);
                                        }, () => {
                                            this.xhr = null;
                                        });
                                    }
                                } else {
                                    // assume stringification is possible
                                    data = JSON.stringify(data);
                                    // set Content-Type header because we're assuming they didn't set it 
                                    // in their headers object
                                    xhr.setRequestHeader('Content-Type', contentType);
                                    this.__setHeaders();
                                    xhr.send(data);
                                }
                            } else {
                                // contentType does not exist so simply set defined headers and send raw data
                                this.__setHeaders();
                                xhr.send(data);
                            }
                        } else {
                            // if contentType exists set Content-Type header because we're assuming they didn't set it 
                            // in their headers object
                            if (contentTypeExists) {
                                xhr.setRequestHeader('Content-Type', contentType);
                            }

                            this.__setHeaders();
                            xhr.send(data);
                        }
                    }

                    var timeout = options.timeout;
                    if (isNumber(timeout) && timeout > 0) {
                        // we first postpone to avoid always timing out when debugging, though this is not
                        // a foolproof method.
                        this.clearTimeout = postpone(() => {
                            this.clearTimeout = defer(() => {
                                reject(new AjaxError({
                                    response: 'Request timed out in ' + timeout + 'ms for ' + options.url,
                                    status: xhr.status,
                                    getAllResponseHeaders: xhr.getAllResponseHeaders,
                                    xhr: xhr
                                }));

                                xhr.onreadystatechange = null;
                                xhr.abort();
                                this.xhr = null;
                            }, timeout - 1);
                        });
                    }
                }, { __http: this });
            }

            /**
             * @name _invalidOptions
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access protected
             * 
             * @description
             * Returns a promise that is immediately rejected due to an error.
             * 
             * @returns {plat.async.IAjaxPromise} A promise that immediately rejects 
             * with an {@link plat.async.IAjaxError|IAjaxError}
             */
            _invalidOptions(): IAjaxPromise<any> {
                return new AjaxPromise((resolve, reject) => {
                    var exceptionFactory: IExceptionStatic = acquire(__ExceptionStatic);
                    exceptionFactory.warn('Attempting a request without specifying a url', exceptionFactory.AJAX);
                    reject(new AjaxError({
                        response: 'Attempting a request without specifying a url',
                        status: null,
                        getAllResponseHeaders: null,
                        xhr: null
                    }));
                });
            }

            /**
             * @name _formatResponse
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access protected
             * 
             * @description
             * The function that formats the response from the XMLHttpRequest.
             * 
             * @param {string} responseType The user designated responseType
             * @param {boolean} success Signifies if the response was a success
             * 
             * @returns {IAjaxResponse<any>} The {@link plat.async.IAjaxResponse|IAjaxResponse} to be returned to 
             * the requester.
             */
            _formatResponse(responseType: string, success: boolean): IAjaxResponse<any> {
                var xhr = this.xhr,
                    status = xhr.status,
                    response = xhr.response;

                // need to try, catch instead of boolean short circuit because chrome doesn't like checking 
                // responseText when the responseType is anything other than empty or 'text'
                if (isNull(response)) {
                    try {
                        response = xhr.responseText;
                    } catch (e) { }
                }

                if (status === 0) {
                    // file protocol issue **Needs to be tested more thoroughly**
                    // ok if response empty, Not Found otherwise
                    status = success ? 200 : 404;
                }

                xhr.onreadystatechange = null;

                if (isFunction(this.clearTimeout)) {
                    this.clearTimeout();
                }

                if (responseType === 'json' && isString(response)) {
                    try {
                        response = JSON.parse(response);
                    } catch (e) { }
                }

                return {
                    response: response,
                    status: status,
                    getAllResponseHeaders: xhr.getAllResponseHeaders,
                    xhr: xhr
                };
            }

            /**
             * @name __setHeaders
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access private
             * 
             * @description
             * Sets the headers for an XMLHttpRequest
             * 
             * @returns {void}
             */
            private __setHeaders(): void {
                var headers = this.__options.headers,
                    keys = Object.keys(headers || {}),
                    xhr = this.xhr,
                    length = keys.length,
                    key: string,
                    i: number;

                for (i = 0; i < length; ++i) {
                    key = keys[i];
                    xhr.setRequestHeader(key, headers[key]);
                }
            }

            /**
             * @name __serializeFormData
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access private
             * 
             * @description
             * Serializes multipart form data in an XMLHttpRequest as a string.
             * 
             * @returns {string}
             */
            private __serializeFormData(): string {
                var data = this.__options.data,
                    keys = Object.keys(data),
                    key: string,
                    val: any,
                    formBuffer: Array<string> = [];

                while (keys.length > 0) {
                    key = keys.pop();
                    val = data[key];
                    if (isNull(val)) {
                        val = '';
                    } else if (isObject(val)) {
                        // may throw a fatal error but this is an invalid case
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.warn('Invalid form entry with key "' + key + '" and value "' + val, $exception.AJAX);
                        val = JSON.stringify(val);
                    }

                    formBuffer.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                }

                return formBuffer.join('&').replace(/%20/g, '+');
            }

            /**
             * @name __appendFormData
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access private
             * 
             * @description
             * Creates FormData to add to the XMLHttpRequest.
             * 
             * @returns {FormData}
             */
            private __appendFormData(): FormData {
                var data = this.__options.data,
                    formData = new FormData(),
                    keys = Object.keys(data),
                    key: string,
                    val: any;

                while (keys.length > 0) {
                    key = keys.pop();
                    val = data[key];
                    if (isNull(val)) {
                        formData.append(key, '');
                    } else if (isObject(val)) {
                        if (isFile(val)) {
                            formData.append(key, val, val.name || val.fileName || 'blob');
                        } else {
                            // may throw a fatal error but this is an invalid case
                            var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                            $exception.warn('Invalid form entry with key "' + key + '" and value "' + val, $exception.AJAX);
                            formData.append(key, JSON.stringify(val));
                        }
                    } else {
                        formData.append(key, val);
                    }
                }

                return formData;
            }

            /**
             * @name __submitFramedFormData
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access private
             * 
             * @description
             * Handles submitting multipart form data using an iframe.
             * 
             * @returns {plat.async.IThenable} A promise that fulfills after the form data is submitted.
             */
            private __submitFramedFormData(): IThenable<IAjaxResponse<any>> {
                var options = this.__options,
                    data = options.data,
                    url = options.url,
                    $document = this.$Document,
                    $body = $document.body,
                    Promise: IPromise = acquire(__Promise),
                    form = $document.createElement('form'),
                    iframe = $document.createElement('iframe'),
                    iframeName = uniqueId('iframe_target'),
                    keys = Object.keys(data),
                    key: string;

                iframe.name = form.target = iframeName;
                iframe.src = 'javascript:false;';
                form.enctype = form.encoding = 'multipart/form-data';
                form.action = url;
                form.method = 'POST';
                form.style.display = 'none';

                while (keys.length > 0) {
                    key = keys.pop();
                    form.insertBefore(this.__createInput(key, data[key]), null);
                }

                return new Promise<IAjaxResponse<any>>((resolve, reject) => {
                    this.xhr.abort = () => {
                        iframe.onload = null;
                        $body.removeChild(form);
                        $body.removeChild(iframe);
                        reject();
                    };

                    iframe.onload = () => {
                        var content = iframe.contentDocument.body.innerHTML;

                        $body.removeChild(form);
                        $body.removeChild(iframe);

                        resolve({
                            response: content,
                            status: 200,
                            getAllResponseHeaders: () => ''
                        });

                        this.xhr = iframe.onload = null;
                    };

                    $body.insertBefore(form, null);
                    $body.insertBefore(iframe, null);
                    form.submit();
                });
            }

            /**
             * @name __createInput
             * @memberof plat.async.HttpRequest
             * @kind function
             * @access private
             * 
             * @description
             * Creates input for form data submissions.
             * 
             * @returns {HTMLInputElement}
             */
            private __createInput(key: string, val: any): HTMLInputElement {
                var $document = this.$Document,
                    $exception: IExceptionStatic,
                    input = <HTMLInputElement>$document.createElement('input');

                input.type = 'hidden';
                input.name = key;

                if (isNull(val)) {
                    input.value = '';
                } else if (isObject(val)) {
                    // check if val is an pseudo File
                    if (isFunction(val.slice) && !(isUndefined(val.name) || isUndefined(val.path))) {
                        var fileList = $document.querySelectorAll('input[type="file"][name="' + key + '"]'),
                            length = fileList.length;
                        // if no inputs found, stringify the data
                        if (length === 0) {
                            $exception = acquire(__ExceptionStatic);
                            $exception.warn('Could not find input[type="file"] with [name="' + key +
                                '"]. Stringifying data instead.', $exception.AJAX);
                            input.value = JSON.stringify(val);
                        } else if (length === 1) {
                            input = <HTMLInputElement>fileList[0];
                            // swap nodes
                            var clone = input.cloneNode(true);
                            input.parentNode.insertBefore(clone, input);
                        } else {
                            // rare case but may have multiple forms with file inputs 
                            // that have the same name
                            var fileInput: HTMLInputElement,
                                path = val.path;
                            while (length-- > 0) {
                                fileInput = <HTMLInputElement>fileList[length];
                                if (fileInput.value === path) {
                                    input = fileInput;
                                    // swap nodes
                                    var inputClone = input.cloneNode(true);
                                    input.parentNode.insertBefore(inputClone, input);
                                    break;
                                }
                            }

                            // could not find the right file
                            if (length === -1) {
                                $exception = acquire(__ExceptionStatic);
                                $exception.warn('Could not find input[type="file"] with [name="' + key + '"] and [value="' +
                                    val.path + '"]. Stringifying data instead.', $exception.AJAX);
                                input.value = JSON.stringify(val);
                            }
                        }
                    } else {
                        // may throw a fatal error but this is an invalid case
                        $exception = acquire(__ExceptionStatic);
                        $exception.warn('Invalid form entry with key "' + key + '" and value "' + val, $exception.AJAX);
                        input.value = JSON.stringify(val);
                    }
                } else {
                    input.value = val;
                }

                return input;
            }
        }

        /**
         * @name IHttpRequest
         * @memberof plat.async
         * @kind interface
         * @exported false
         * 
         * @description
         * IHttpRequest provides a wrapper for the XMLHttpRequest object. Allows for
         * sending AJAX requests to a server.
         */
        interface IHttpRequest {
            /**
             * @name execute
             * @memberof plat.async.IHttpRequest
             * @kind function
             * @access public
             * 
             * @description
             * Executes an XMLHttpRequest and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.
             * 
             * @typeparam {any} R The response type for the XMLHttpRequest object.
             * 
             * @returns {plat.async.IAjaxPromise} A promise that fulfills when the XMLHttpRequest is done. 
             */
            execute<R>(): IAjaxPromise<R>;

            /**
             * @name executeJsonp
             * @memberof plat.async.IHttpRequest
             * @kind function
             * @access public
             * 
             * @description
             * Executes an JSONP request and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.
             * 
             * @typeparam {any} R The response type for the JSONP callback parameter.
             * 
             * @returns {plat.async.IAjaxPromise} A promise that fulfills when the JSONP request is done. 
             */
            executeJsonp<R>(): IAjaxPromise<R>;
        }

        /**
         * @name IHttpConfig
         * @memberof plat.async
         * @kind interface
         * 
         * @extends {plat.async.IJsonpConfig}
         * 
         * @description
         * Describes an object which contains Ajax configuration properties.
         */
        export interface IHttpConfig extends IJsonpConfig {
            /**
             * @name method
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * The HTTP method type of XmlHttpRequest such as 'GET', 'POST', 'PUT', 
             * 'DELETE', etc. Ignored for non-HTTP urls. Defaults to 'GET'.
             */
            method?: string;

            /**
             * @name timeout
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {number}
             * 
             * @description
             * The number of milliseconds a request can take before 
             * automatically being terminated. A value of 0 
             * means there is no timeout.
             */
            timeout?: number;

            /**
             * @name user
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * An optional user string for the XmlHttpRequest
             */
            user?: string;

            /**
             * @name password
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * An optional password string for the XmlHttpRequest
             */
            password?: string;

            /**
             * @name responseType
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * The XMLHttpRequestResponseType. The response should 
             * still be checked when received due to browser 
             * incompatibilities. If a browser does not support a 
             * response type it will return the value as a string. 
             * The response type does not affect JSONP callback 
             * arguments.
             * 
             * @see config.XMLHttpRequestResponseType
             */
            responseType?: string;

            /**
             * @name contentType
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * The Content-Type header for XMLHttpRequest when 
             * data is being sent. The default is 
             * 'application/json;charset=utf-8;'.
             */
            contentType?: string;

            /**
             * @name overrideMimeType
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * A string to override the MIME type returned by the server.
             */
            overrideMimeType?: string;

            /**
             * @name headers
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {any}
             * 
             * @description
             * A key/value pair object where the key is a DOMString header key
             * and the value is the DOMString header value.
             */
            headers?: any;

            /**
             * @name withCredentials
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {boolean}
             * 
             * @description
             * Indicates whether or not cross-site Access-Control requests 
             * should be made using credentials such as cookies or 
             * authorization headers. The default is false.
             */
            withCredentials?: boolean;

            /**
             * @name data
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {any}
             * 
             * @description
             * The request payload
             */
            data?: any;

            /**
             * @name transforms
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {plat.async.IHttpTransformFunction}
             * 
             * @description
             * An array of data transform functions that fire in order and consecutively 
             * pass the returned result from one function to the next.
             */
            transforms?: Array<IHttpTransformFunction>;

            /**
             * @name isCrossDomain
             * @memberof plat.async.IHttpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {boolean}
             * 
             * @description
             * Forces a JSONP, cross-domain request when set to true.
             * The default is false.
             */
            isCrossDomain?: boolean;
        }

        /**
         * @name IHttpTransformFunction
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * A function that is used to transform XMLHttpRequest data.
         */
        export interface IHttpTransformFunction {
            /**
             * @memberof plat.async.IHttpTransformFunction
             * @kind function
             * @access public
             * 
             * @description
             * The method signature for {@link plat.async.IHttpTransformFunction|IHttpTransformFunction}.
             * 
             * @param {any} data The data for the XMLHttpRequest.
             * @param {XMLHttpRequest} xhr The XMLHttpRequest for the data.
             * 
             * @returns {any} The transformed data.
             */
            (data: any, xhr: XMLHttpRequest): any;
        }

        /**
         * @name IJsonpConfig
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * Describes an object which contains JSONP configuration properties.
         */
        export interface IJsonpConfig {
            /**
             * @name url
             * @memberof plat.async.IJsonpConfig
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The url for the JSONP callback 
             * (without the `?{callback}={callback_name}` parameter in the url) 
             * or for the XmlHttpRequest.
             */
            url: string;

            /**
             * @name jsonpIdentifier
             * @memberof plat.async.IJsonpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * The identifier the server uses to get the name of the JSONP
             * callback. The default is 'callback' as seen in 
             * http://www.platyfi.com/data?callback=plat_fnName.
             */
            jsonpIdentifier?: string;

            /**
             * @name jsonpCallback
             * @memberof plat.async.IJsonpConfig
             * @kind property
             * @access public
             * @optional
             * 
             * @type {string}
             * 
             * @description
             * A specified name for the JSONP callback (in case the server has 
             * it hardcoded and/or does not get it from the given url). The 
             * default is a unique plat id generated separately for 
             * each JSONP callback seen as 'plat_callback00' in
             * http://www.platyfi.com/data?callback=plat_callback00.
             */
            jsonpCallback?: string;
        }

        /**
         * @name IAjaxResponse
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * Describes an object that is the response to an AJAX request.
         * 
         * @typeparam {any} R The type of the AJAX response.
         */
        export interface IAjaxResponse<R> {
            /**
             * @name response
             * @memberof plat.async.IAjaxResponse
             * @kind property
             * @access public
             * 
             * @type {R}
             * 
             * @description
             * The AJAX response or responseText. The response should 
             * be checked when received due to browser 
             * incompatibilities with responseType. If a browser does 
             * not support a response type it will return the value as 
             * a string.
             */
            response: R;

            /**
             * @name status
             * @memberof plat.async.IAjaxResponse
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The XHR status. Resolves as 200 for JSONP.
             */
            status: number;

            /**
             * @name getAllResponseHeaders
             * @memberof plat.async.IAjaxResponse
             * @kind function
             * @access public
             * 
             * @description
             * A method for getting the XHR response headers.
             * 
             * @returns {void}
             */
            getAllResponseHeaders?: () => string;

            /**
             * @name xhr
             * @memberof plat.async.IAjaxResponse
             * @kind property
             * @access public
             * @optional
             * 
             * @type {XMLHttpRequest}
             * 
             * @description
             * The XMLHttpRequest object associated with the AJAX call
             */
            xhr?: XMLHttpRequest;
        }

        /**
         * @name IAjaxResolveFunction
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * Describes the AjaxPromise's resolve function
         * 
         * @typeparam {any} R The type of the {@link plat.async.IAjaxResponse|IAjaxResponse} object.
         */
        export interface IAjaxResolveFunction<R> {
            /**
             * @memberof plat.async.IAjaxResolveFunction
             * @kind function
             * @access public
             * 
             * @description
             * The method signature for an {@link plat.async.IAjaxResolveFunction|IAjaxResolveFunction}.
             * 
             * @param {(value?: plat.async.IAjaxResponse<R>) => any} resolve The function to call when the 
             * AJAX call has successfully fulfilled.
             * @param {(reason?: plat.async.IAjaxError) => any} reject The function to call when the 
             * AJAX call fails.
             * 
             * @returns {void}
             */
            (resolve: (value?: IAjaxResponse<R>) => any, reject: (reason?: IAjaxError) => any): void;
        }

        /**
         * @name AjaxError
         * @memberof plat.async
         * @kind class
         * @exported false
         * 
         * @implements {plat.async.IAjaxError}
         * 
         * @description
         * A class that forms an Error object with an {@link plat.async.IAjaxResponse|IAjaxResponse}.
         */
        class AjaxError implements IAjaxError {
            /**
             * @name name
             * @memberof plat.async.AjaxError
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The name of the Error ('AjaxError')
             */
            name: string = 'AjaxError';

            /**
             * @name message
             * @memberof plat.async.AjaxError
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The Error message
             */
            message: string;

            /**
             * @name response
             * @memberof plat.async.AjaxError
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The response from the XMLHttpRequest
             */
            response: any;

            /**
             * @name status
             * @memberof plat.async.AjaxError
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The status code from the XMLHttpRequest
             */
            status: number;

            /**
             * @name getAllResponseHeaders
             * @memberof plat.async.AjaxError
             * @kind function
             * @access public
             * 
             * @description
             * A method for getting the XHR response headers.
             * 
             * @returns {void}
             */
            getAllResponseHeaders: () => string;

            /**
             * @name xhr
             * @memberof plat.async.AjaxError
             * @kind property
             * @access public
             * 
             * @type {XMLHttpRequest}
             * 
             * @description
             * The XMLHttpRequest object associated with the AJAX call
             */
            xhr: XMLHttpRequest;

            /**
             * @name constructor
             * @memberof plat.async.AjaxError
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for an {@link plat.async.AjaxError|AjaxError}.
             * 
             * @param {plat.async.IAjaxResponse} response The {@link plat.async.IAjaxResponse|IAjaxResponse} object.
             * 
             * @returns {plat.async.AjaxError}
             */
            constructor(response: IAjaxResponse<any>) {
                Error.apply(this);
                this.response = this.message = response.response;
                this.status = response.status;
                this.getAllResponseHeaders = response.getAllResponseHeaders;
                this.xhr = response.xhr;
            }

            /**
             * @name toString
             * @memberof plat.async.AjaxError
             * @kind function
             * @access public
             * 
             * @description
             * Outputs a formatted string describing the {@link plat.async.AjaxError|AjaxError}.
             * 
             * @returns {string}
             */
            toString(): string {
                var response = this.response,
                    responseText = response;

                if (isObject(response) && !response.hasOwnProperty('toString')) {
                    responseText = JSON.stringify(response);
                }

                return 'Request failed with status: ' + this.status + ' and response: ' + responseText;
            }
        }

        // have to bypass TS flags in order to properly extend Error
        (<any>AjaxError).prototype = Error.prototype;

        /**
         * @name IAjaxError
         * @memberof plat.async
         * @kind interface
         * 
         * @implements {plat.async.IAjaxResponse}
         * 
         * @description
         * Describes an object that forms an Error object with an {@link plat.async.IAjaxResponse|IAjaxResponse}.
         */
        export interface IAjaxError extends Error, IAjaxResponse<any> { }

        /**
         * @name AjaxPromise
         * @memberof plat.async
         * @kind class
         * 
         * @extends {plat.async.Promise}
         * @implements {plat.async.IAjaxPromise}
         * 
         * @description
         * Describes a type of {@link plat.async.Promise|Promise} that fulfills with an {@link plat.async.IAjaxResponse|IAjaxResponse} and can be optionally cancelled.
         * 
         * @typeparam {any} R The type of the response object in the {@link plat.async.IAjaxResponse|IAjaxResponse}.
         */
        export class AjaxPromise<R> extends Promise<IAjaxResponse<R>> implements IAjaxPromise<R> {
            /**
             * @name $Window
             * @memberof plat.async.AjaxPromise
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {Window}
             * 
             * @description
             * The Window object.
             */
            $Window: Window = acquire(__Window);

            /**
             * @name __http
             * @memberof plat.async.AjaxPromise
             * @kind property
             * @access private
             * @readonly
             * 
             * @type {plat.async.HttpRequest}
             * 
             * @description
             * The {@link plat.async.HttpRequest|HttpRequest} object.
             */
            private __http: HttpRequest;

            /**
             * @name constructor
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * The constructor method for the {@link plat.async.AjaxPromise}.
             * 
             * @param {plat.async.IAjaxResolveFunction} resolveFunction The promise resolve function.
             * 
             * @returns {plat.async.AjaxPromise}
             */
            constructor(resolveFunction: IAjaxResolveFunction<R>);
            /**
             * @name constructor
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * The constructor method for the {@link plat.async.AjaxPromise}.
             * 
             * @param {plat.async.IAjaxResolveFunction} resolveFunction The promise resolve function.
             * @param {any} promise The promise object to allow for cancelling the {@link plat.async.AjaxPromise}.
             * 
             * @returns {plat.async.AjaxPromise}
             */
            constructor(resolveFunction: IAjaxResolveFunction<R>, promise: any);
            constructor(resolveFunction: IAjaxResolveFunction<R>, promise?: any) {
                super(resolveFunction);
                if (!isNull(promise)) {
                    this.__http = promise.__http;
                }
            }

            /**
             * @name cancel
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * 
             * @description
             * A method to cancel the AJAX call associated with this {@link plat.async.AjaxPromise}.
             * 
             * @returns {void}
             */
            cancel(): void {
                var http = this.__http,
                    xhr = http.xhr,
                    jsonpCallback = http.jsonpCallback;

                if (isFunction(http.clearTimeout)) {
                    http.clearTimeout();
                }

                if (!isNull(xhr)) {
                    xhr.onreadystatechange = null;
                    xhr.abort();
                    http.xhr = null;
                } else if (!isNull(jsonpCallback)) {
                    (<any>this.$Window)[jsonpCallback] = noop;
                }

                (<any>this).__subscribers = [];
            }

            /**
             * @name then
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IAjaxThenable<U>}
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U,
                onRejected?: (error: IAjaxError) => any): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IAjaxThenable<U>}
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IThenable<U>,
                onRejected?: (error: IAjaxError) => IThenable<U>): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IAjaxThenable<U>}
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IThenable<U>,
                onRejected?: (error: IAjaxError) => any): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IAjaxThenable<U>}
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U,
                onRejected?: (error: IAjaxError) => IThenable<U>): IAjaxThenable<U>;
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U,
                onRejected?: (error: IAjaxError) => any): IAjaxThenable<U> {
                return <IAjaxThenable<U>><any>super.then<U>(onFulfilled, onRejected);
            }

            /**
             * @name catch
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(error: any) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IAjaxThenable<U>} A promise that resolves with the input type parameter U.
             */
            catch<U>(onRejected: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;
            /**
             * @name catch
             * @memberof plat.async.AjaxPromise
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @typeparam {any} U The return type of the returned promise.
             * 
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next
             * onRejected method in the promise chain will be called.
             * 
             * @returns {plat.async.IAjaxThenable<U>} A promise that resolves with the input type parameter U.
             */
            catch<U>(onRejected: (error: any) => U): IAjaxThenable<U>;
            catch<U>(onRejected: (error: any) => any): IAjaxThenable<U> {
                return <IAjaxThenable<U>><any>super.catch<U>(onRejected);
            }
        }

        /**
         * @name IAjaxThenable
         * @memberof plat.async
         * @kind interface
         * 
         * @extends {plat.async.IThenable}
         * 
         * @description 
         * Describes a type of {@link plat.async.IThenable|IThenable} that can optionally cancel it's associated AJAX call.
         * 
         * @typeparam {any} R The return type for the {@link plat.async.IThenable|IThenable}.
         */
        export interface IAjaxThenable<R> extends IThenable<R> {
            /**
             * @name cancel
             * @memberof plat.async.IAjaxThenable
             * @kind function
             * @access public
             * 
             * @description
             * A method to cancel the AJAX call associated with this {@link plat.async.AjaxPromise}.
             * 
             * @returns {void}
             */
            cancel(): void;

            /**
             * @name then
             * @memberof plat.async.IAjaxThenable
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: R) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: any) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: R) => IAjaxThenable<U>, onRejected?: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IAjaxThenable
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: R) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: R) => IAjaxThenable<U>, onRejected?: (error: any) => U): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IAjaxThenable
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: R) => U} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: any) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IAjaxThenable
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: R) => U} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IAjaxThenable<U>;

            /**
             * @name catch
             * @memberof plat.async.IAjaxThenable
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @param {(error: any) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            catch<U>(onRejected: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;
            /**
             * @name catch
             * @memberof plat.async.IAjaxThenable
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            catch<U>(onRejected: (error: any) => U): IAjaxThenable<U>;
        }

        /**
         * @name IAjaxPromise
         * @memberof plat.async
         * @kind interface
         * 
         * @extends {plat.async.IAjaxThenable}
         * 
         * @description
         * Describes a type of {@link plat.async.IPromise|IPromise} that fulfills with an {@link plat.async.IAjaxResponse|IAjaxResponse} and can be optionally cancelled.
         * 
         * @typeparam {any} R The type of the response object in the {@link plat.async.IAjaxResponse|IAjaxResponse}.
         */
        export interface IAjaxPromise<R> extends IAjaxThenable<IAjaxResponse<R>> {
            /**
             * @name cancel
             * @memberof plat.async.IAjaxPromise
             * @kind function
             * @access public
             * 
             * @description
             * A method to cancel the AJAX call associated with this {@link plat.async.AjaxPromise}.
             * 
             * @returns {void}
             */
            cancel(): void;

            /**
             * @name then
             * @memberof plat.async.IAjaxPromise
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IAjaxThenable<U>, onRejected?: (error: IAjaxError) => IAjaxThenable<U>): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IAjaxPromise
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IAjaxThenable<U>, onRejected?: (error: IAjaxError) => U): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IAjaxPromise
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U, onRejected?: (error: IAjaxError) => IAjaxThenable<U>): IAjaxThenable<U>;
            /**
             * @name then
             * @memberof plat.async.IAjaxPromise
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Takes in two methods, called when/if the promise fulfills/rejects.
             * 
             * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the 
             * next then method in the promise chain.
             * 
             * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills. 
             * If undefined the next onFulfilled method in the promise chain will be called.
             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U, onRejected?: (error: IAjaxError) => U): IAjaxThenable<U>;

            /**
             * @name catch
             * @memberof plat.async.IAjaxPromise
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            catch<U>(onRejected: (error: IAjaxError) => IAjaxThenable<U>): IAjaxThenable<U>;
            /**
             * @name catch
             * @memberof plat.async.IAjaxPromise
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
             * 
             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects. 
             * If undefined the next onRejected method in the promise chain will be called.
             */
            catch<U>(onRejected: (error: IAjaxError) => U): IAjaxThenable<U>;
        }

        /**
         * @name IHttpResponseType
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * Describes an object that provides value mappings for XMLHttpRequestResponseTypes
         */
        export interface IHttpResponseType {
            /**
             * @name DEFAULT
             * @memberof plat.async.IHttpResponseType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The default response type (empty string)
             */
            DEFAULT: string;

            /**
             * @name ARRAYBUFFER
             * @memberof plat.async.IHttpResponseType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The arrayBuffer type ('arrayBuffer')
             */
            ARRAYBUFFER: string;

            /**
             * @name BLOB
             * @memberof plat.async.IHttpResponseType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The blob type ('blob')
             */
            BLOB: string;

            /**
             * @name DOCUMENT
             * @memberof plat.async.IHttpResponseType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The document type ('document')
             */
            DOCUMENT: string;

            /**
             * @name JSON
             * @memberof plat.async.IHttpResponseType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The json type ('json')
             */
            JSON: string;

            /**
             * @name TEXT
             * @memberof plat.async.IHttpResponseType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The text type ('text')
             */
            TEXT: string;
        }

        /**
         * @name IHttpContentType
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * Describes an object that provides Content-Type mappings for Http POST requests.
         */
        export interface IHttpContentType {
            /**
             * @name ENCODED_FORM
             * @memberof plat.async.IHttpContentType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Standard denotation for form encoded data. All objects are converted 
             * to string key-value pairs.
             */
            ENCODED_FORM: string;

            /**
             * @name JSON
             * @memberof plat.async.IHttpContentType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Standard denotation for JavaScript Object Notation (JSON).
             */
            JSON: string;

            /**
             * @name MULTIPART_FORM
             * @memberof plat.async.IHttpContentType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Standard denotation for a multi-part Webform. Associated with 
             * an entype of 'multipart/form-data'.
             */
            MULTIPART_FORM: string;

            /**
             * @name OCTET_STREAM
             * @memberof plat.async.IHttpContentType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Standard denotation for arbitrary binary data.
             */
            OCTET_STREAM: string;

            /**
             * @name XML
             * @memberof plat.async.IHttpContentType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Standard denotation for XML files.
             */
            XML: string;

            /**
             * @name PLAIN_TEXT
             * @memberof plat.async.IHttpContentType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Standard denotation for textual data.
             */
            PLAIN_TEXT: string;

            /**
             * @name HTML
             * @memberof plat.async.IHttpContentType
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Standard denotation for HTML.
             */
            HTML: string;
        }

        /**
         * @name Http
         * @memberof plat.async
         * @kind class
         * 
         * @implements {plat.async.IHttp}
         * 
         * @description
         * The instantiated class of the injectable for making 
         * AJAX requests.
         */
        export class Http implements IHttp {
            /**
             * @name config
             * @memberof plat.async.Http
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.async.IHttpConfig}
             * 
             * @description
             * Default Http config
             */
            static config: IHttpConfig = {
                url: null,
                method: 'GET',
                responseType: '',
                transforms: [],
                headers: {},
                withCredentials: false,
                timeout: null,
                jsonpIdentifier: 'callback',
                contentType: 'application/json;charset=utf-8;'
            };

            /**
             * @name responseType
             * @memberof plat.async.Http
             * @kind property
             * @access public
             * 
             * @type {plat.async.IHttpResponseType}
             * 
             * @description
             * Provides value mappings for XMLHttpRequestResponseTypes
             */
            responseType: IHttpResponseType = {
                DEFAULT: '',
                ARRAYBUFFER: 'arraybuffer',
                BLOB: 'blob',
                DOCUMENT: 'document',
                JSON: 'json',
                TEXT: 'text'
            };

            /**
             * @name contentType
             * @memberof plat.async.Http
             * @kind property
             * @access public
             * 
             * @type {plat.async.IHttpContentType}
             * 
             * @description
             * Provides Content-Type mappings for Http POST requests.
             */
            contentType: IHttpContentType = {
                ENCODED_FORM: 'application/x-www-form-urlencoded;charset=utf-8;',
                JSON: 'application/json;charset=utf-8;',
                MULTIPART_FORM: 'multipart/form-data;',
                OCTET_STREAM: 'application/octet-stream;charset=utf-8;',
                XML: 'application/xml;charset=utf-8;',
                PLAIN_TEXT: 'text/plain;',
                HTML: 'text/html;'
            };

            /**
             * @name ajax
             * @memberof plat.async.Http
             * @kind function
             * @access public
             * 
             * @description
             * A wrapper method for the Http class that creates and executes a new Http with
             * the specified {@link plat.async.IAjaxOptions|IAjaxOptions}. This function will check if 
             * XMLHttpRequest level 2 is present, and will default to JSONP if it isn't and 
             * the request is cross-domain.
             * 
             * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}
             * 
             * @param {plat.async.IHttpConfig} options The {@link plat.async.IAjaxOptions|IAjaxOptions} for either the XMLHttpRequest 
             * or the JSONP callback.
             * 
             * @returns {plat.async.IAjaxPromise} A promise, when fulfilled
             * or rejected, will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object.
             */
            ajax<R>(options: IHttpConfig): IAjaxPromise<R> {
                return new HttpRequest(options).execute<R>();
            }

            /**
             * @name jsonp
             * @memberof plat.async.Http
             * @kind function
             * @access public
             * 
             * @description
             * A direct method to force a cross-domain JSONP request.
             * 
             * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}
             * 
             * @param {plat.async.IJsonpConfig} options The {@link plat.async.IJsonpConfig|IJsonpConfig} 
             * 
             * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected, will return an 
             * {@link plat.async.IAjaxResponse|IAjaxResponse} object.
             */
            jsonp<R>(options: IJsonpConfig): IAjaxPromise<R> {
                return new HttpRequest(options).executeJsonp<R>();
            }

            /**
             * @name json
             * @memberof plat.async.Http
             * @kind function
             * @access public
             * 
             * @description
             * Makes an ajax request, specifying responseType: 'json'.
             * 
             * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}
             * 
             * @param {plat.async.IHttpConfig} options The {@link plat.async.IHttpConfig|IHttpConfig} 
             * for either the XMLHttpRequest or the JSONP callback.
             * 
             * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected, 
             * will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object, with the response 
             * being a parsed JSON object (assuming valid JSON).
             */
            json<R>(options: IHttpConfig): IAjaxPromise<R> {
                return new HttpRequest(extend({}, options, { responseType: 'json' })).execute<R>();
            }
        }

        /**
         * The Type for referencing the '$Http' injectable as a dependency.
         */
        export function IHttp(): IHttp {
            return new Http();
        }

        register.injectable(__Http, IHttp);

        /**
         * @name IHttp
         * @memberof plat.async
         * @kind interface
         * 
         * @description
         * The interface of the injectable for making 
         * AJAX requests.
         */
        export interface IHttp {
            /**
             * @name responseType
             * @memberof plat.async.IHttp
             * @kind property
             * @access public
             * 
             * @type {plat.async.IHttpResponseType}
             * 
             * @description
             * Provides value mappings for
             * XMLHttpRequestResponseTypes
             */
            responseType: IHttpResponseType;

            /**
             * @name contentType
             * @memberof plat.async.IHttp
             * @kind property
             * @access public
             * 
             * @type {plat.async.IHttpContentType}
             * 
             * @description
             * Provides Content-Type mappings for Http POST requests.
             */
            contentType: IHttpContentType;

            /**
             * @name ajax
             * @memberof plat.async.IHttp
             * @kind function
             * @access public
             * 
             * @description
             * A wrapper method for the Http class that creates and executes a new Http with
             * the specified {@link plat.async.IAjaxOptions|IAjaxOptions}. This function will check if 
             * XMLHttpRequest level 2 is present, and will default to JSONP if it isn't and 
             * the request is cross-domain.
             * 
             * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}
             * 
             * @param {plat.async.IHttpConfig} options The {@link plat.async.IAjaxOptions|IAjaxOptions} for either the XMLHttpRequest 
             * or the JSONP callback.
             * 
             * @returns {plat.async.AjaxPromise} A promise, when fulfilled
             * or rejected, will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object.
             */
            ajax<R>(options: IHttpConfig): IAjaxPromise<R>;

            /**
             * @name jsonp
             * @memberof plat.async.IHttp
             * @kind function
             * @access public
             * 
             * @description
             * A direct method to force a cross-domain JSONP request.
             * 
             * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}
             * 
             * @param {plat.async.IJsonpConfig} options The {@link plat.async.IJsonpConfig|IJsonpConfig} 
             * 
             * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected, will return an 
             * {@link plat.async.IAjaxResponse|IAjaxResponse} object.
             */
            jsonp? <R>(options: IJsonpConfig): IAjaxPromise<R>;

            /**
             * @name json
             * @memberof plat.async.IHttp
             * @kind function
             * @access public
             * 
             * @description
             * Makes an ajax request, specifying responseType: 'json'.
             * 
             * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}
             * 
             * @param {plat.async.IHttpConfig} options The {@link plat.async.IHttpConfig|IHttpConfig} 
             * for either the XMLHttpRequest or the JSONP callback.
             * 
             * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected, 
             * will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object, with the response 
             * being a parsed JSON object (assuming valid JSON).
             */
            json? <R>(options: IHttpConfig): IAjaxPromise<R>;
        }

        /**
         * The Type for referencing the '$HttpConfig' injectable as a dependency.
         */
        export function IHttpConfig(): IHttpConfig {
            return Http.config;
        }

        register.injectable(__HttpConfig, IHttpConfig);
    }
    /**
     * @name storage
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds classes and interfaces related to storage in platypus.
     */
    export module storage {
        /**
         * @name caches
         * @memberof plat.storage
         * @kind property
         * @access private
         * @static
         * @exported false
         * 
         * @type {plat.IObject<plat.storage.Cache<any>>}
         * 
         * @description
         * The keyed collection of all created {@link plat.storage.ICache|ICaches} in the 
         * {@link plat.storage.ICacheFactory|ICacheFactory}.
         */
        var caches: IObject<Cache<any>> = {};
        /**
         * @name internalCaches
         * @memberof plat.storage
         * @kind property
         * @access private
         * @static
         * @exported false
         * 
         * @type {any}
         * 
         * @description
         * Internal storage for all the items stored in each {@link plat.storage.ICache|ICache}.
         */
        var internalCaches: any = {};

        /**
         * @name Cache
         * @memberof plat.storage
         * @kind class
         * 
         * @implements {plat.storage.ICache<T>}
         * 
         * @description
         * A Cache class, for use with the {@link plat.storage.ICacheFactory|ICacheFactory} injectable. 
         * Used for storing objects. Takes in a generic type corresponding to the type of objects it contains.
         * 
         * @typeparam {any} T The type of objects stored in the cache.
         */
        export class Cache<T> implements ICache<T> {
            /**
             * @name create
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Method for creating a new cache object. Takes a generic type to denote the
             * type of objects stored in the new cache.  If a cache with the same ID already exists
             * in the {@link plat.storage.ICacheFactory|ICacheFactory}, a new cache will not be created.
             * 
             * @param {string} id The ID of the new Cache.
             * @param {plat.storage.ICacheOptions} options {@link plat.storage.ICacheOptions|ICacheOptions} 
             * for customizing the Cache.
             * 
             * @typeparam {any} T Denotes the type of objects stored in the new Cache.
             * 
             * @returns {plat.storage.ICache<T>} The new cache.
             */
            static create<T>(id: string, options?: ICacheOptions): ICache<T> {
                var cache: ICache<T> = caches[id];

                if (isNull(cache)) {
                    cache = caches[id] = new Cache<T>(id, options);
                }

                return cache;
            }

            /**
             * @name fetch
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Gets a cache out of the {@link plat.storage.ICacheFactory|ICacheFactory} if it exists.
             * 
             * @param {string} id The identifier used to search for the cache.
             * 
             * @typeparam {any} T Denotes the type of objects stored in the new Cache.
             * 
             * @returns {plat.storage.ICache<T>} The cache with the input ID or undefined if it does not exist.
             */
            static fetch<T>(id: string): ICache<T> {
                return caches[id];
            }
        
            /**
             * @name clear
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clears the {@link plat.storage.ICacheFactory|ICacheFactory} and all of its caches.
             * 
             * @returns {void}
             */
            static clear(): void {
                var keys = Object.keys(caches),
                    length = keys.length;

                for (var i = 0; i < length; ++i) {
                    caches[keys[i]].clear();
                }

                caches = <IObject<Cache<any>>>{};
            }

            /**
             * @name __size
             * @memberof plat.storage.Cache
             * @kind property
             * @access private
             * 
             * @type {number}
             * 
             * @description
             * The size of this cache specified by its ID.
             */
            private __size: number;
            /**
             * @name __id
             * @memberof plat.storage.Cache
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * The ID of this cache.
             */
            private __id: string;
            /**
             * @name __options
             * @memberof plat.storage.Cache
             * @kind property
             * @access private
             * 
             * @type {plat.storage.ICacheOptions}
             * 
             * @description
             * The options for this cache.
             */
            private __options: ICacheOptions;

            /**
             * @name constructor
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.storage.Cache|Cache}.
             * 
             * @param {string} id The id to use to retrieve the cache from the {@link plat.storage.ICacheFactory|ICacheFactory}.
             * @param {plat.storage.ICacheOptions} options The {@link plat.storage.ICacheOptions|ICacheOptions} for customizing the cache.
             * 
             * @returns {plat.storage.Cache} A new {@link plat.storage.Cache|Cache} instance specified by the ID.
             */
            constructor(id: string, options?: ICacheOptions) {
                this.__id = id;
                this.__options = options;
                this.__size = 0;

                if (isNull(options)) {
                    this.__options = {
                        timeout: 0
                    };
                }

                internalCaches[id] = {};
            }

            /**
             * @name info
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * 
             * @description
             * Retrieves the {@link plat.storage.ICacheInfo|ICacheInfo} about this cache 
             * (i.e. ID, size, options)
             * 
             * @returns {plat.storage.ICacheInfo} The information about this cache.
             */
            info(): ICacheInfo {
                return {
                    id: this.__id,
                    size: this.__size,
                    options: this.__options
                };
            }
        
            /**
             * @name put
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * 
             * @description
             * Method for inserting an object into an {@link plat.storage.ICache|ICache}.
             * 
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {T} value The value to store with the associated key.
             * 
             * @returns {T} The value inserted into an {@link plat.storage.ICache|ICache}.
             */
            put(key: string, value: T): T {
                var val = internalCaches[this.__id][key];
                internalCaches[this.__id][key] = value;

                if (isUndefined(val)) {
                    this.__size++;
                }

                var timeout = this.__options.timeout;

                if (isNumber(timeout) && timeout > 0) {
                    defer(<(key?: string) => void>this.remove, timeout, [key], this);
                }

                return value;
            }
        
            /**
             * @name read
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * 
             * @description
             * Method for retrieving an object from an {@link plat.storage.ICache|ICache}.
             * 
             * @param key The key to search for in an {@link plat.storage.ICache|ICache}.
             * 
             * @returns {T} The value found at the associated key. Returns undefined for a cache miss.
             */
            read(key: string): T {
                return internalCaches[this.__id][key];
            }
        
            /**
             * @name remove
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * 
             * @description
             * Method for removing an object from an {@link plat.storage.ICache|ICache}.
             * 
             * @param {string} key The key to remove from the {@link plat.storage.ICache|ICache}.
             * 
             * @returns {void}
             */
            remove(key: string): void {
                deleteProperty(internalCaches[this.__id], key);
                this.__size--;
            }
        
            /**
             * @name clear
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * 
             * @description
             * Method for clearing an {@link plat.storage.ICache|ICache}, removing all of its keys.
             * 
             * @returns {void}
             */
            clear(): void {
                internalCaches[this.__id] = {};
                this.__size = 0;
            }
        
            /**
             * @name dispose
             * @memberof plat.storage.Cache
             * @kind function
             * @access public
             * 
             * @description
             * Method for removing an {@link plat.storage.ICache|ICache} from the {@link plat.storage.ICacheFactory|ICacheFactory}.
             * 
             * @returns {void}
             */
            dispose(): void {
                this.clear();
                deleteProperty(caches, this.__id);
            }
        }

        /**
         * The Type for referencing the '$CacheFactory' injectable as a dependency.
         */
        export function ICacheFactory(): ICacheFactory {
            return Cache;
        }

        register.injectable(__CacheFactory, ICacheFactory, null, __FACTORY);
    
        /**
         * @name ICacheFactory
         * @memberof plat.storage
         * @kind interface
         * 
         * @description
         * Used to manage all the defined caches for the current application session.
         */
        export interface ICacheFactory {
            /**
             * @name create
             * @memberof plat.storage.ICacheFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Method for creating a new cache object. Takes a generic type to denote the
             * type of objects stored in the new cache.  If a cache with the same ID already exists
             * in the {@link plat.storage.ICacheFactory|ICacheFactory}, a new cache will not be created.
             * 
             * @param {string} id The ID of the new Cache.
             * @param {plat.storage.ICacheOptions} options {@link plat.storage.ICacheOptions|ICacheOptions} 
             * for customizing the Cache.
             * 
             * @typeparam {any} T Denotes the type of objects stored in the new Cache.
             * 
             * @returns {plat.storage.ICache<T>} The new cache.
             */
            create<T>(id: string, options?: ICacheOptions): ICache<T>;

            /**
             * @name fetch
             * @memberof plat.storage.ICacheFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Gets a cache out of the {@link plat.storage.ICacheFactory|ICacheFactory} if it exists.
             * 
             * @param {string} id The identifier used to search for the cache.
             * 
             * @typeparam {any} T Denotes the type of objects stored in the new Cache.
             * 
             * @returns {plat.storage.ICache<T>} The cache with the input ID or undefined if it does not exist.
             */
            fetch<T>(id: string): ICache<T>;

            /**
             * @name clear
             * @memberof plat.storage.ICacheFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clears the {@link plat.storage.ICacheFactory|ICacheFactory} and all of its caches.
             * 
             * @returns {void}
             */
            clear(): void;
        }
    
        /**
         * @name ICache
         * @memberof plat.storage
         * @kind interface
         * 
         * @description
         * Describes a cache. Takes in a generic type
         * corresponding to the type of objects stored in the cache.
         * 
         * @typeparam {any} T The type of objects stored in this cache.
         */
        export interface ICache<T> {
            /**
             * @name info
             * @memberof plat.storage.ICache
             * @kind function
             * @access public
             * 
             * @description
             * Retrieves the {@link plat.storage.ICacheInfo|ICacheInfo} about this cache 
             * (i.e. ID, size, options)
             * 
             * @returns {plat.storage.ICacheInfo} The information about this cache.
             */
            info(): ICacheInfo;

            /**
             * @name put
             * @memberof plat.storage.ICache
             * @kind function
             * @access public
             * 
             * @description
             * Method for inserting an object into an {@link plat.storage.ICache|ICache}.
             * 
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {T} value The value to store with the associated key.
             * 
             * @returns {T} The value inserted into an {@link plat.storage.ICache|ICache}.
             */
            put(key: string, value: T): T;

            /**
             * @name read
             * @memberof plat.storage.ICache
             * @kind function
             * @access public
             * 
             * @description
             * Method for retrieving an object from an {@link plat.storage.ICache|ICache}.
             * 
             * @param key The key to search for in an {@link plat.storage.ICache|ICache}.
             * 
             * @returns {T} The value found at the associated key. Returns undefined for a cache miss.
             */
            read(key: string): T;

            /**
             * @name remove
             * @memberof plat.storage.ICache
             * @kind function
             * @access public
             * 
             * @description
             * Method for removing an object from an {@link plat.storage.ICache|ICache}.
             * 
             * @param {string} key The key to remove from the {@link plat.storage.ICache|ICache}.
             * 
             * @returns {void}
             */
            remove(key: string): void;

            /**
             * @name clear
             * @memberof plat.storage.ICache
             * @kind function
             * @access public
             * 
             * @description
             * Method for clearing an {@link plat.storage.ICache|ICache}, removing all of its keys.
             * 
             * @returns {void}
             */
            clear(): void;

            /**
             * @name dispose
             * @memberof plat.storage.ICache
             * @kind function
             * @access public
             * 
             * @description
             * Method for removing an {@link plat.storage.ICache|ICache} from the {@link plat.storage.ICacheFactory|ICacheFactory}.
             * 
             * @returns {void}
             */
            dispose(): void;
        }

        /**
         * A cache for persisting NodeManager trees.
         */
        var managerCache = Cache.create<processing.INodeManager>('__managerCache');

        /**
         * The Type for referencing the '$ManagerCache' injectable as a dependency.
         */
        export function IManagerCache(): typeof managerCache {
            return managerCache;
        }

        register.injectable(__ManagerCache, IManagerCache);
    
        /**
         * @name ICacheOptions
         * @memberof plat.storage
         * @kind interface
         * 
         * @description
         * Options for a cache.
         */
        export interface ICacheOptions {
            /**
             * @name timeout
             * @memberof plat.storage.ICacheOptions
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * Specifies a timeout for a cache value. When a value 
             * is put in the cache, it will be valid for the given
             * period of time (in milliseconds). After the timeout 
             * is reached, the value will automatically be removed
             * from the cache.
             */
            timeout?: number;
        }
    
        /**
         * @name ICacheInfo
         * @memberof plat.storage
         * @kind interface
         * 
         * @description
         * Contains information about an {@link plat.storage.ICache|ICache}.
         */
        export interface ICacheInfo {
            /**
             * @name id
             * @memberof plat.storage.ICacheInfo
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A unique id for the {@link plat.storage.ICache|ICache} object, used to 
             * retrieve the {@link plat.storage.ICache|ICache} out of the {@link plat.storage.ICacheFactory|ICacheFactory}.
             */
            id: string;
        
            /**
             * @name size
             * @memberof plat.storage.ICacheInfo
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * Represents the number of items in the {@link plat.storage.ICache|ICache}.
             */
            size: number;
        
            /**
             * @name options
             * @memberof plat.storage.ICacheInfo
             * @kind property
             * @access public
             * 
             * @type {plat.storage.ICacheOptions}
             * 
             * @description
             * Represents the {@link plat.storage.ICacheOptions|ICacheOptions} that the 
             * {@link plat.storage.ICache|ICache} is using.
             */
            options: ICacheOptions;
        }

        /**
         * @name TemplateCache
         * @memberof plat.storage
         * @kind class
         * 
         * @extends {plat.storage.Cache<any>}
         * @implements {plat.storage.ITemplateCache}
         * 
         * @description
         * Used for caching compiled nodes. This class will
         * clone a template when you put it in the cache. It will
         * also clone the template when you retrieve it.
         */
        export class TemplateCache extends Cache<async.IThenable<DocumentFragment>> implements ITemplateCache {
            /**
             * @name $Promise
             * @memberof plat.storage.TemplateCache
             * @kind property
             * @access public
             * 
             * @type {plat.async.IPromise}
             * 
             * @description
             * Reference to the {@link plat.async.IPromise|IPromise} injectable.
             */
            $Promise: async.IPromise = acquire(__Promise);
        
            /**
             * @name constructor
             * @memberof plat.storage.TemplateCache
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.storage.TemplateCache|TemplateCache}. Creates a new {@link plat.storage.ICache|ICache}  
             * with the ID "__templateCache".
             * 
             * @returns {plat.storage.TemplateCache}
             */
            constructor() {
                super('__templateCache');
            }
        
            /**
             * @name put
             * @memberof plat.storage.TemplateCache
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Stores a Node in the cache as a DocumentFragment.
             * 
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {Node} value The Node.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves with a 
             * DocumentFragment containing the input Node.
             */
            put(key: string, value: Node): async.IThenable<DocumentFragment>;
            /**
             * @name put
             * @memberof plat.storage.TemplateCache
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Stores a {@link plat.async.IPromise|IPromise} in the cache.
             * 
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {plat.async.IThenable<Node>} value {@link plat.async.Promise|Promise} that 
             * should resolve with a Node.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A {@link plat.async.Promise|Promise} that resolves when 
             * the input {@link plat.async.Promise|Promise} resolves.
             */
            put(key: string, value: async.IThenable<Node>): async.IThenable<DocumentFragment>;
            put(key: string, value: any): async.IThenable<DocumentFragment> {
                var Promise = this.$Promise;
                super.put(key, Promise.resolve<DocumentFragment>(value));

                if (isDocumentFragment(value)) {
                    value = value.cloneNode(true);
                } else if (isNode(value)) {
                    var fragment = document.createDocumentFragment();
                    fragment.appendChild(value.cloneNode(true));
                    value = fragment;
                }

                return Promise.resolve<DocumentFragment>(value);
            }
        
            /**
             * @name read
             * @memberof plat.storage.TemplateCache
             * @kind function
             * @access public
             * 
             * @description
             * Method for retrieving a Node from this cache. The DocumentFragment that resolves from the returned 
             * {@link plat.async.Promise|Promise} will be cloned to avoid manipulating the cached template.
             * 
             * @param {string} key The key to search for in this cache.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} The {@link plat.async.Promise|Promise} found at the associated key. 
             * Returns undefined for a cache miss.
             */
            read(key: string): async.IThenable<DocumentFragment> {
                var promise: async.IThenable<DocumentFragment> = super.read(key);

                if (isNull(promise)) {
                    return <any>this.$Promise.reject(null);
                }

                return promise.then((node) => {
                    return this.put(key, node);
                }, (error: Error) => {
                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                    $exception.warn('Error retrieving template from promise.', $exception.TEMPLATE);
                    return <DocumentFragment>null;
                });
            }
        }

        /**
         * The Type for referencing the '$TemplateCache' injectable as a dependency.
         */
        export function ITemplateCache(): ITemplateCache {
            return new TemplateCache();
        }

        register.injectable(__TemplateCache, ITemplateCache);
    
        /**
         * @name ITemplateCache
         * @memberof plat.storage
         * @kind interface
         * 
         * @extends {plat.storage.ICache<plat.async.IThenable<DocumentFragment>>}
         * 
         * @description
         * Used to manage all templates. Returns a unique template 
         * for every read, to avoid having to call cloneNode.
         */
        export interface ITemplateCache extends ICache<async.IThenable<DocumentFragment>> {
            /**
             * @name put
             * @memberof plat.storage.ITemplateCache
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Stores a Node in the cache as a DocumentFragment.
             * 
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {Node} value The Node.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves with a 
             * DocumentFragment containing the input Node.
             */
            put(key: string, value: Node): async.IThenable<DocumentFragment>;
            /**
             * @name put
             * @memberof plat.storage.ITemplateCache
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Stores a {@link plat.async.IPromise|IPromise} in the cache.
             * 
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {plat.async.IThenable<Node>} value {@link plat.async.Promise|Promise} that 
             * should resolve with a Node.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A {@link plat.async.Promise|Promise} that resolves when 
             * the input {@link plat.async.Promise|Promise} resolves.
             */
            put(key: string, value: async.IThenable<Node>): async.IThenable<DocumentFragment>;
        
            /**
             * @name read
             * @memberof plat.storage.ITemplateCache
             * @kind function
             * @access public
             * 
             * @description
             * Method for retrieving a Node from this cache. The DocumentFragment that resolves from the returned 
             * {@link plat.async.Promise|Promise} will be cloned to avoid manipulating the cached template.
             * 
             * @param {string} key The key to search for in this cache.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} The {@link plat.async.Promise|Promise} found at the associated key. 
             * Returns undefined for a cache miss.
             */
            read(key: string): async.IThenable<DocumentFragment>;
        }

        /**
         * @name BaseStorage
         * @memberof plat.storage
         * @kind class
         * 
         * @implements {plat.storage.IBaseStorage}
         * 
         * @description
         * A base class for storing data with a designated storage type.
         */
        export class BaseStorage implements IBaseStorage {
            /**
             * @name constructor
             * @memberof plat.storage.BaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.storage.BaseStorage|BaseStorage}.
             * 
             * @returns {plat.storage.BaseStorage}
             */
            constructor() {
                forEach((<Storage>(<any>this).__storage), (value, key) => {
                    (<any>this)[key] = value;
                });
            }

            /**
             * @name length
             * @memberof plat.storage.BaseStorage
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {number}
             * 
             * @description
             * Returns the number of items in storage.
             */
            get length(): number {
                return (<Storage>(<any>this).__storage).length;
            }
        
            /**
             * @name clear
             * @memberof plat.storage.BaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Clears storage, deleting all of its keys.
             * 
             * @returns {void}
             */
            clear(): void {
                (<Storage>(<any>this).__storage).clear();
            }
        
            /**
             * @name getItem
             * @memberof plat.storage.BaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Gets an item out of storage with the assigned key.
             * 
             * @param {string} key The key of the item to retrieve from storage.
             * 
             * @typeparam {any} T The type of item being retrieved.
             * 
             * @returns {T} The item retrieved from storage.
             */
            getItem<T>(key: string): T {
                return (<Storage>(<any>this).__storage).getItem(key);
            }
        
            /**
             * @name key
             * @memberof plat.storage.BaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Allows for iterating over storage keys with an index. When
             * called with an index, it will return the key at that index in 
             * storage.
             * 
             * @param {number} index The index used to retrieve the associated key.
             * 
             * @returns {string} The key at the given index.
             */
            key(index: number): string {
                return (<Storage>(<any>this).__storage).key(index);
            }
        
            /**
             * @name removeItem
             * @memberof plat.storage.BaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Searches in storage for an item and removes it if it 
             * exists.
             * 
             * @param {string} key The key of the item to remove from storage.
             * 
             * @returns {void}
             */
            removeItem(key: string): void {
                (<Storage>(<any>this).__storage).removeItem(key);
            }
        
            /**
             * @name setItem
             * @memberof plat.storage.BaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Adds data to storage with the designated key.
             * 
             * @param {string} key The key of the item to store in storage.
             * @param {any} data The data to store in storage with the key.
             * 
             * @returns {void}
             */
            setItem(key: string, data: any): void {
                (<Storage>(<any>this).__storage).setItem(key, data);
                (<any>this)[key] = this.getItem(key);
            }
        }
    
        /**
         * @name IBaseStorage
         * @memberof plat.storage
         * @kind interface
         * 
         * @description
         * An object designed for storing data with a designated storage type.
         */
        export interface IBaseStorage {
            /**
             * @name length
             * @memberof plat.storage.IBaseStorage
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {number}
             * 
             * @description
             * Returns the number of items in storage.
             */
            length: number;

            /**
             * @name clear
             * @memberof plat.storage.IBaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Clears storage, deleting all of its keys.
             * 
             * @returns {void}
             */
            clear(): void;
        
            /**
             * @name getItem
             * @memberof plat.storage.IBaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Gets an item out of storage with the assigned key.
             * 
             * @param {string} key The key of the item to retrieve from storage.
             * 
             * @typeparam {any} T The type of item being retrieved.
             * 
             * @returns {T} The item retrieved from storage.
             */
            getItem<T>(key: string): T;
        
            /**
             * @name key
             * @memberof plat.storage.IBaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Allows for iterating over storage keys with an index. When
             * called with an index, it will return the key at that index in 
             * storage.
             * 
             * @param {number} index The index used to retrieve the associated key.
             * 
             * @returns {string} The key at the given index.
             */
            key(index: number): string;
        
            /**
             * @name removeItem
             * @memberof plat.storage.IBaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Searches in storage for an item and removes it if it 
             * exists.
             * 
             * @param {string} key The key of the item to remove from storage.
             * 
             * @returns {void}
             */
            removeItem(key: string): void;
        
            /**
             * @name setItem
             * @memberof plat.storage.IBaseStorage
             * @kind function
             * @access public
             * 
             * @description
             * Adds data to storage with the designated key.
             * 
             * @param {string} key The key of the item to store in storage.
             * @param {any} data The data to store in storage with the key.
             * 
             * @returns {void}
             */
            setItem(key: string, data: any): void;
        }

        /**
         * @name LocalStorage
         * @memberof plat.storage
         * @kind class
         * 
         * @extends {plat.storage.BaseStorage}
         * @implements {plat.storage.ILocalStorage}
         * 
         * @description
         * A class used to wrap HTML5 localStorage into an injectable.
         */
        export class LocalStorage extends BaseStorage implements ILocalStorage {
            /* tslint:disable:no-unused-variable */
            /**
             * @name __storage
             * @memberof plat.storage.LocalStorage
             * @kind property
             * @access private
             * 
             * @type {Storage}
             * 
             * @description
             * Reference to HTML5 localStorage.
             */
            private __storage: Storage = (<Window>acquire(__Window)).localStorage;
            /* tslint:enable:no-unused-variable */
        }

        /**
         * The Type for referencing the '$LocalStorage' injectable as a dependency.
         */
        export function ILocalStorage(): ILocalStorage {
            return new LocalStorage();
        }

        register.injectable(__LocalStorage, ILocalStorage);
    
        /**
         * @name ILocalStorage
         * @memberof plat.storage
         * @kind interface
         * 
         * @description
         * Describes an object used to wrap local storage into an injectable.
         */
        export interface ILocalStorage {
            /**
             * @name length
             * @memberof plat.storage.ILocalStorage
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {number}
             * 
             * @description
             * Returns the number of items in localStorage.
             */
            length: number;
        
            /**
             * @name clear
             * @memberof plat.storage.ILocalStorage
             * @kind function
             * @access public
             * 
             * @description
             * Clears localStorage, deleting all of its keys.
             * 
             * @returns {void}
             */
            clear(): void;
        
            /**
             * @name getItem
             * @memberof plat.storage.ILocalStorage
             * @kind function
             * @access public
             * 
             * @description
             * Gets an item out of localStorage with the assigned key.
             * 
             * @param {string} key The key of the item to retrieve from localStorage.
             * 
             * @typeparam {any} T The type of item being retrieved.
             * 
             * @returns {T} The item retrieved from storage.
             */
            getItem<T>(key: string): T;
        
            /**
             * @name key
             * @memberof plat.storage.ILocalStorage
             * @kind function
             * @access public
             * 
             * @description
             * Allows for iterating over localStorage keys with an index. When
             * called with an index, it will return the key at that index in 
             * localStorage.
             * 
             * @param {number} index The index used to retrieve the associated key.
             * 
             * @returns {string} The key at the given index.
             */
            key(index: number): string;
        
            /**
             * @name removeItem
             * @memberof plat.storage.ILocalStorage
             * @kind function
             * @access public
             * 
             * @description
             * Searches in localStorage for an item and removes it if it 
             * exists.
             * 
             * @param {string} key The key of the item to remove from storage.
             * 
             * @returns {void}
             */
            removeItem(key: string): void;
        
            /**
             * @name setItem
             * @memberof plat.storage.ILocalStorage
             * @kind function
             * @access public
             * 
             * @description
             * Adds data to localStorage with the designated key.
             * 
             * @param {string} key The key of the item to store in localStorage.
             * @param {any} data The data to store in localStorage with the key.
             * 
             * @returns {void}
             */
            setItem(key: string, data: any): void;
        }

        /**
         * @name SessionStorage
         * @memberof plat.storage
         * @kind class
         * 
         * @extends {plat.storage.BaseStorage}
         * @implements {plat.storage.ISessionStorage}
         * 
         * @description
         * A class for wrapping SessionStorage as an injectable.
         */
        export class SessionStorage extends BaseStorage implements ISessionStorage {
            /* tslint:disable:no-unused-variable */
            /**
             * @name __storage
             * @memberof plat.storage.LocalStorage
             * @kind property
             * @access private
             * 
             * @type {Storage}
             * 
             * @description
             * Reference to HTML5 sessionStorage.
             */
            private __storage: Storage = (<Window>acquire(__Window)).sessionStorage;
            /* tslint:enable:no-unused-variable */
        }

        /**
         * The Type for referencing the '$SessionStorage' injectable as a dependency.
         */
        export function ISessionStorage(): ISessionStorage {
            return new SessionStorage();
        }

        register.injectable(__SessionStorage, ISessionStorage);
    
        /**
         * @name ISessionStorage
         * @memberof plat.storage
         * @kind interface
         * 
         * @description
         * Describes an object used to wrap session storage into an injectable.
         */
        export interface ISessionStorage {
            /**
             * @name length
             * @memberof plat.storage.ISessionStorage
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {number}
             * 
             * @description
             * Returns the number of items in sessionStorage.
             */
            length: number;
        
            /**
             * @name clear
             * @memberof plat.storage.ISessionStorage
             * @kind function
             * @access public
             * 
             * @description
             * Clears sessionStorage, deleting all of its keys.
             * 
             * @returns {void}
             */
            clear(): void;
        
            /**
             * @name getItem
             * @memberof plat.storage.ISessionStorage
             * @kind function
             * @access public
             * 
             * @description
             * Gets an item out of sessionStorage with the assigned key.
             * 
             * @param {string} key The key of the item to retrieve from sessionStorage.
             * 
             * @typeparam {any} T The type of item being retrieved.
             * 
             * @returns {T} The item retrieved from storage.
             */
            getItem<T>(key: string): T;
        
            /**
             * @name key
             * @memberof plat.storage.ISessionStorage
             * @kind function
             * @access public
             * 
             * @description
             * Allows for iterating over sessionStorage keys with an index. When
             * called with an index, it will return the key at that index in 
             * sessionStorage.
             * 
             * @param {number} index The index used to retrieve the associated key.
             * 
             * @returns {string} The key at the given index.
             */
            key(index: number): string;
        
            /**
             * @name removeItem
             * @memberof plat.storage.ISessionStorage
             * @kind function
             * @access public
             * 
             * @description
             * Searches in sessionStorage for an item and removes it if it 
             * exists.
             * 
             * @param {string} key The key of the item to remove from storage.
             * 
             * @returns {void}
             */
            removeItem(key: string): void;
        
            /**
             * @name setItem
             * @memberof plat.storage.ISessionStorage
             * @kind function
             * @access public
             * 
             * @description
             * Adds data to sessionStorage with the designated key.
             * 
             * @param {string} key The key of the item to store in sessionStorage.
             * @param {any} data The data to store in sessionStorage with the key.
             * 
             * @returns {void}
             */
            setItem(key: string, data: any): void;
        }
    }
    /* tslint:disable:no-unused-variable */
    /**
     * @name OPERATORS
     * @memberof plat.expressions
     * @kind property
     * @access private
     * @static
     * @readonly
     * @exported false
     * 
     * @type {plat.IObject<plat.expressions.ITokenDetails>}
     * 
     * @description
     * An object used to create {@link plat.expressions.ITokenDetails|ITokenDetails} for every operator.
     */
    var OPERATORS: plat.IObject<plat.expressions.ITokenDetails> = {
        'u+': {
            precedence: 4, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any): any => +a(context, aliases)
        },
        '+': {
            precedence: 6, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) + b(context, aliases)
        },
        'u-': {
            precedence: 4, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any): any => -a(context, aliases)
        },
        '-': {
            precedence: 6, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) - b(context, aliases)
        },
        '*': {
            precedence: 5, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) * b(context, aliases)
        },
        '/': {
            precedence: 5, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) / b(context, aliases)
        },
        '%': {
            precedence: 5, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) % b(context, aliases)
        },
        '?': {
            precedence: 15, associativity: 'rtl',
            fn: (context: any, aliases: any): void => undefined
        },
        ':': {
            precedence: 15, associativity: 'rtl',
            fn: (context: any, aliases: any): void => undefined
        },
        '>': {
            precedence: 8, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) > b(context, aliases)
        },
        '<': {
            precedence: 8, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) < b(context, aliases)
        },
        '!': {
            precedence: 4, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any): any => !a(context, aliases)
        },
        '~': {
            precedence: 4, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any): any => ~a(context, aliases)
        },
        '&': {
            precedence: 10, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) & b(context, aliases)
        },
        '|': {
            precedence: 12, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) | b(context, aliases)
        },
        '>>': {
            precedence: 7, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) >> b(context, aliases)
        },
        '<<': {
            precedence: 7, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) << b(context, aliases)
        },
        '>>>': {
            precedence: 7, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) >>> b(context, aliases)
        },
        '&&': {
            precedence: 13, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) && b(context, aliases)
        },
        '||': {
            precedence: 14, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) || b(context, aliases)
        },
        '==': {
            precedence: 9, associativity: 'ltr',
            /* tslint:disable:triple-equals */
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) == b(context, aliases)
            /* tslint:enable:triple-equals */
        },
        '===': {
            precedence: 9, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) === b(context, aliases)
        },
        '!=': {
            precedence: 9, associativity: 'ltr',
            /* tslint:disable:triple-equals */
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) != b(context, aliases)
            /* tslint:enable:triple-equals */
        },
        '!==': {
            precedence: 9, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) !== b(context, aliases)
        },
        '>=': {
            precedence: 8, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) >= b(context, aliases)
        },
        '<=': {
            precedence: 8, associativity: 'ltr',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): any => a(context, aliases) <= b(context, aliases)
        },
        '=': {
            precedence: 17, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        },
        '++': {
            precedence: 3, associativity: '',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        },
        '--': {
            precedence: 3, associativity: '',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        },
        '+=': {
            precedence: 17, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        },
        '-=': {
            precedence: 17, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        },
        '*=': {
            precedence: 17, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        },
        '/=': {
            precedence: 17, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        },
        '%=': {
            precedence: 17, associativity: 'rtl',
            fn: (context: any, aliases: any,
                a: (context: any, aliases: any) => any,
                b: (context: any, aliases: any) => any): void => {
                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);
                $exception.fatal('Assignment operators are not supported', $exception.PARSE);
            }
        }
    };
    
    /**
     * @name ACCESSORS
     * @memberof plat.expressions
     * @kind property
     * @access private
     * @static
     * @readonly
     * @exported false
     * 
     * @type {plat.IObject<plat.expressions.ITokenDetails>}
     * 
     * @description
     * An object used to create {@link plat.expressions.ITokenDetails|ITokenDetails} for every accessor.
     */
    var ACCESSORS: plat.IObject<plat.expressions.ITokenDetails> = {
        '()': { precedence: 2, associativity: null, fn: null },
        '[]': { precedence: 2, associativity: null, fn: null },
        '.': { precedence: 2, associativity: null, fn: null },
        '{}': { precedence: 1, associativity: null, fn: null }
    };
    
    /**
     * @name DELIMITERS
     * @memberof plat.expressions
     * @kind property
     * @access private
     * @static
     * @readonly
     * @exported false
     * 
     * @type {plat.IObject<plat.expressions.ITokenDetails>}
     * 
     * @description
     * An object used to create {@link plat.expressions.ITokenDetails|ITokenDetails} for every delimiter.
     */
    var DELIMITERS: plat.IObject<plat.expressions.ITokenDetails> = {
        '{': { precedence: 1, associativity: null, fn: null },
        '}': { precedence: 1, associativity: null, fn: null },
        '[': { precedence: 2, associativity: null, fn: null },
        ']': { precedence: 2, associativity: null, fn: null },
        '(': { precedence: 2, associativity: null, fn: null },
        ')': { precedence: 2, associativity: null, fn: null },
        '.': { precedence: 2, associativity: null, fn: null },
        ',': { precedence: 18, associativity: null, fn: null },
        '\'': { precedence: 0, associativity: null, fn: null },
        '"': { precedence: 0, associativity: null, fn: null }
    };
    
    /**
     * @name KEYWORDS
     * @memberof plat.expressions
     * @kind property
     * @access private
     * @static
     * @readonly
     * @exported false
     * 
     * @type {plat.IObject<plat.expressions.ITokenDetails>}
     * 
     * @description
     * An object used to get literal values from string values of false, true, and undefined
     */
    var KEYWORDS: plat.IObject<any> = {
        false: false,
        true: true,
        null: null,
        undefined: 'undefined'
    };
    
    /**
     * @name isDelimiter
     * @memberof plat.expressions
     * @kind function
     * @access private
     * @static
     * @exported false
     * 
     * @description
     * Checks if a string is in the {@link plat.expressions.DELIMITERS|DELIMITERS} array.
     * 
     * @param {string} key The string to index into the DELIMITERS array.
     * 
     * @returns {boolean} Whether or not the key is a delimiter.
     */
    function isDelimiter(key: string): boolean {
        return !isNull(DELIMITERS[key]);
    }
    
    /**
     * @name isAccessor
     * @memberof plat.expressions
     * @kind function
     * @access private
     * @static
     * @exported false
     * 
     * @description
     * Checks if a string is in the {@link plat.expressions.ACCESSORS|ACCESSORS} array.
     * 
     * @param {string} key The string to index into the ACCESSORS array.
     * 
     * @returns {boolean} Whether or not the key is a accessor.
     */
    function isAccessor(key: string): boolean {
        return !isNull(ACCESSORS[key]);
    }
    
    /**
     * @name isOperator
     * @memberof plat.expressions
     * @kind function
     * @access private
     * @static
     * @exported false
     * 
     * @description
     * Checks if a string is in the {@link plat.expressions.OPERATORS|OPERATORS} array.
     * 
     * @param {string} key The string to index into the OPERATORS array.
     * 
     * @returns {boolean} Whether or not the key is a operator.
     */
    function isOperator(key: string): boolean {
        return !isNull(OPERATORS[key]);
    }
    
    /**
     * @name isKeyword
     * @memberof plat.expressions
     * @kind function
     * @access private
     * @static
     * @exported false
     * 
     * @description
     * Checks if a string is in the {@link plat.expressions.KEYWORDS|KEYWORDS} array.
     * 
     * @param {string} key The string to index into the KEYWORDS array.
     * 
     * @returns {boolean} Whether or not the key is a keyword.
     */
    function isKeyword(key: string): boolean {
        return !isUndefined(KEYWORDS[key]);
    }
    /* tslint:enable:no-unused-variable */
    
    /**
     * @name observable
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds all classes and interfaces related to observable components in platypus.
     */
    export module observable {
        /**
         * @name arrayMethods
         * @memberof plat.observable
         * @kind property
         * @access private
         * @static
         * @exported false
         * 
         * @type {Array<string>}
         * 
         * @description
         * The array methods to be overwritten if it is to be observed.
         */
        var arrayMethods = ['push', 'pop', 'reverse', 'shift', 'sort', 'splice', 'unshift'];
    
        /**
         * @name ContextManager
         * @memberof plat.observable
         * @kind class
         * 
         * @implements {plat.observable.IContextManager}
         * 
         * @description
         * A class for managing both context inheritance and observable properties on controls and 
         * facilitating in data-binding.
         */
        export class ContextManager implements IContextManager {
            /**
             * @name observedArrayListeners
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.IObject<plat.IObject<Array<(ev: plat.observable.IArrayMethodInfo<any>) => void>>>}
             * 
             * @description
             * A set of functions to be fired when a particular observed array is mutated.
             */
            static observedArrayListeners: IObject<IObject<Array<(ev: IArrayMethodInfo<any>) => void>>> = {};
        
            /**
             * @name getManager
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Gets the {@link plat.observable.IContextManager|IContextManager} associated to the given control. If no 
             * {@link plat.observable.IContextManager|IContextManager} exists, one is created for that control.
             * 
             * @param {plat.IControl} control The control on which to locate the {@link plat.observable.IContextManager|IContextManager}.
             * 
             * @returns {plat.observable.IContextManager} The {@link plat.observable.IContextManager|IContextManager} 
             * associated with the input control.
             */
            static getManager(control: IControl): IContextManager {
                var contextManager: IContextManager,
                    managers = ContextManager.__managers,
                    uid = control.uid,
                    manager = managers[uid];

                if (!isNull(manager)) {
                    contextManager = manager;
                    return contextManager;
                }

                contextManager = managers[uid] = new ContextManager();
                contextManager.context = control;

                return contextManager;
            }
        
            /**
             * @name dispose
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes all the listeners for a given control's unique ID.
             * 
             * @param {plat.IControl} control The control whose manager is being disposed.
             * @param {boolean} persist? Whether or not the control's context needs to 
             * be persisted post-disposal or can be set to null.
             * 
             * @returns {void}
             */
            static dispose(control: IControl, persist?: boolean): void;
            static dispose(control: ui.ITemplateControl, persist?: boolean): void {
                if (isNull(control)) {
                    return;
                }

                var uid = control.uid,
                    controls = ContextManager.__controls,
                    identifiers = controls[uid] || {},
                    managers = ContextManager.__managers,
                    manager = managers[uid];

                if (!isNull(manager)) {
                    manager.dispose();
                    deleteProperty(managers, uid);
                }

                var keys = Object.keys(identifiers),
                    listeners: Array<IRemoveListener>;

                while (keys.length > 0) {
                    listeners = identifiers[keys.shift()];
                    while (listeners.length > 0) {
                        listeners.shift()();
                    }
                }

                keys = Object.keys(ContextManager.observedArrayListeners);

                var remove = ContextManager.removeArrayListeners,
                    length = keys.length;

                for (var i = 0; i < length; ++i) {
                    remove(keys[i], uid);
                }

                deleteProperty(controls, uid);

                if (!isNull(control.context)) {
                    ContextManager.defineProperty(control, 'context',
                        persist === true ? _clone(control.context, true) : null, true, true);
                }
            }
        
            /**
             * @name removeArrayListeners
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes all listeners for an Array associated with a given uid.
             * 
             * @param {string} absoluteIdentifier The identifier used to locate the array.
             * @param {string} uid The uid used to search for listeners.
             * 
             * @returns {void}
             */
            static removeArrayListeners(absoluteIdentifier: string, uid: string): void {
                var listeners = ContextManager.observedArrayListeners[absoluteIdentifier];

                if (!isNull(listeners)) {
                    deleteProperty(listeners, uid);
                }
            }
        
            /**
             * @name getContext
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Safely retrieves the local context given a root context and an Array of
             * property strings.
             * 
             * @param {any} rootContext The root object in which to find a local context.
             * @param {Array<string>} split The string array containing properties used to index into 
             * the rootContext.
             * 
             * @returns {any} The narrowed down context.
             */
            static getContext(rootContext: any, split: Array<string>): any {
                if (isNull(rootContext)) {
                    return rootContext;
                }

                split = split.slice(0);
                while (split.length > 0) {
                    rootContext = rootContext[split.shift()];
                    if (isNull(rootContext)) {
                        return rootContext;
                    }
                }

                return rootContext;
            }
        
            /**
             * @name defineProperty
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Defines an object property with the associated value. Useful for unobserving objects.
             * 
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated 
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             * 
             * @returns {void}
             */
            static defineProperty(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: enumerable === true,
                    configurable: configurable === true
                });
            }
        
            /**
             * @name defineGetter
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Defines an object property with the associated value. Useful for unobserving objects.
             * 
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated 
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             * 
             * @returns {void}
             */
            static defineGetter(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void {
                Object.defineProperty(obj, key, {
                    get: () => value,
                    enumerable: enumerable === true,
                    configurable: configurable === true
                });
            }
        
            /**
             * @name pushRemoveListener
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Pushes the function for removing an observed property upon adding the property.
             * 
             * @param {string} identifer The identifier for which the remove listener is being pushed.
             * @param {string} uid The unique ID of the control observing the identifier.
             * @param {plat.IRemoveListener} listener The function for removing the observed property.
             * 
             * @returns {void}
             */
            static pushRemoveListener(identifier: string, uid: string, listener: IRemoveListener): void {
                var controls = ContextManager.__controls,
                    control = controls[uid],
                    listeners: Array<IRemoveListener>;

                if (isNull(control)) {
                    control = controls[uid] = {};
                }

                listeners = control[identifier];

                if (isNull(listeners)) {
                    listeners = control[identifier] = [];
                }

                listeners.push(listener);
            }
        
            /**
             * @name removeIdentifier
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes a specified identifier from being observed for a given set of control IDs.
             * 
             * @param {Array<string>} uids The set of unique Ids for which to remove the specified identifier.
             * @param {string} identifier The identifier to stop observing.
             * 
             * @returns {void}
             */
            static removeIdentifier(uids: Array<string>, identifier: string): void {
                var length = uids.length,
                    controls = ContextManager.__controls,
                    identifiers: IObject<Array<IRemoveListener>>;

                for (var i = 0; i < length; ++i) {
                    identifiers = controls[uids[i]];

                    if (isNull(identifiers)) {
                        continue;
                    }

                    deleteProperty(identifiers, identifier);
                }
            }
        
            /**
             * @name createContext
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Ensures that an identifier path will exist on a given control. Will create 
             * objects/arrays if necessary.
             * 
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * on which to create the context.
             * @param {string} identifier The period-delimited identifier string used to create 
             * the context path.
             * 
             * @returns {any} The newly created context object.
             */
            static createContext(control: ui.ITemplateControl, identifier: string): any {
                var context = control.context;

                if (!isObject(context)) {
                    if (isNull(context)) {
                        context = control.context = {};
                    } else {
                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);
                        Exception.warn('A child control is trying to create a child context that has ' +
                            'a parent control with a primitive type context', Exception.BIND);
                        return;
                    }
                }

                var split = identifier.split('.'),
                    property: string,
                    temp: any;

                while (split.length > 0) {
                    property = split.shift();

                    temp = context[property];

                    if (isNull(temp)) {
                        if (isNumber(Number(split[0]))) {
                            temp = context[property] = [];
                        } else {
                            temp = context[property] = {};
                        }
                    }

                    context = temp;
                }

                return context;
            }
        
            /**
             * @name __managers
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * @static
             * 
             * @type {plat.IObject<plat.observable.IContextManager>}
             * 
             * @description
             * An object for quickly accessing a previously created {@link plat.observable.IContextManager|IContextManager}.
             */
            private static __managers: IObject<IContextManager> = {};
            /**
             * @name __controls
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * @static
             * 
             * @type {plat.IObject<plat.IObject<Array<plat.IRemoveListener>>>}
             * 
             * @description
             * An object for storing functions to remove listeners for observed identifiers.
             */
            private static __controls: IObject<IObject<Array<IRemoveListener>>> = {};
        
            /**
             * @name $Compat
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access public
             * 
             * @type {plat.ICompat}
             * 
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            $Compat: ICompat = acquire(__Compat);
        
            /**
             * @name context
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The root context associated with and to be managed by this 
             * {@link plat.observable.IContextManager|IContextManager}.
             */
            context: any;
        
            /**
             * @name __identifiers
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<Array<plat.observable.IListener>>}
             * 
             * @description
             * An object for quickly accessing callbacks associated with a given identifier.
             */
            private __identifiers: IObject<Array<IListener>> = {};
            /**
             * @name __identifierHash
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<Array<string>>}
             * 
             * @description
             * An object for quickly accessing child context associations (helps with 
             * notifying child properties).
             */
            private __identifierHash: IObject<Array<string>> = {};
            /**
             * @name __lengthListeners
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<plat.observable.IListener>}
             * 
             * @description
             * An object for storing listeners for Array length changes.
             */
            private __lengthListeners: IObject<IListener> = {};
            /**
             * @name __contextObjects
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<any>}
             * 
             * @description
             * An object for quickly accessing previously accessed or observed objects and properties.
             */
            private __contextObjects: IObject<any> = {};
            /**
             * @name __isArrayFunction
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the property currently being modified is due to an observed array function.
             */
            private __isArrayFunction = false;
            /**
             * @name __observedIdentifier
             * @memberof plat.observable.ContextManager
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * If attempting to observe a property that is already being observed, this will be set to the 
             * already observed identifier.
             */
            private __observedIdentifier: string;
        
            /**
             * @name getContext
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Safely retrieves the local context for this manager given an Array of
             * property strings.
             * 
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             * 
             * @returns {any} The obtained context.
             */
            getContext(split: Array<string>): any {
                var join = split.join('.'),
                    context = this.__contextObjects[join];

                if (isNull(context)) {
                    context = this.__contextObjects[join] = this._getImmediateContext(join);
                }

                return context;
            }
        
            /**
             * @name observe
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Given a period-delimited identifier, observes an object and calls the given listener when the 
             * object changes.
             * 
             * @param {string} absoluteIdentifier The period-delimited identifier noting the property to be observed.
             * @param {plat.observable.IListener} observableListener An object implmenting IObservableListener. The listener will be 
             * notified of object changes.
             * 
             * @returns {plat.IRemoveListener} A function to stop observing the object identified by the absoluteIdentifier.
             */
            observe(absoluteIdentifier: string, observableListener: IListener): IRemoveListener {
                if (isEmpty(absoluteIdentifier)) {
                    return noop;
                }

                var split = absoluteIdentifier.split('.'),
                    key = split.pop(),
                    hasIdentifier = this._hasIdentifier(absoluteIdentifier),
                    hasObservableListener = !isNull(observableListener),
                    join: string,
                    context: any;

                if (split.length > 0) {
                    join = split.join('.');
                    context = this.__contextObjects[join];
                    if (isNull(context)) {
                        context = this.__contextObjects[join] = this._getImmediateContext(join);
                    }
                } else {
                    join = key;
                    context = this.context;
                }

                if (!isObject(context)) {
                    if (hasObservableListener) {
                        if (key === 'length') {
                            this.__lengthListeners[absoluteIdentifier] = observableListener;
                            ContextManager.pushRemoveListener(absoluteIdentifier, uid, () => {
                                deleteProperty(this.__lengthListeners, absoluteIdentifier);
                            });
                        }
                        return this._addObservableListener(absoluteIdentifier, observableListener);
                    }

                    return noop;
                }

                // set observedIdentifier to null
                this.__observedIdentifier = null;

                this.__contextObjects[absoluteIdentifier] = context[key];

                // if observedIdentifier is not null, the primitive is already being watched
                var observedIdentifier = this.__observedIdentifier,
                    isObserved = !isNull(observedIdentifier),
                    removeCallback = noop;
                if (isObserved) {
                    hasIdentifier = true;
                }

                if (hasObservableListener) {
                    var removeObservedCallback = noop,
                        removeAbsoluteCallback = this._addObservableListener(absoluteIdentifier, observableListener);

                    if (isObserved && absoluteIdentifier !== observedIdentifier) {
                        removeObservedCallback = this._addObservableListener(observedIdentifier, observableListener);
                    }

                    removeCallback = () => {
                        removeAbsoluteCallback();
                        removeObservedCallback();
                    };
                }

                // check if value is defined and context manager hasn't seen this identifier
                if (!hasIdentifier) {
                    if (key === 'length' && isArray(context)) {
                        var property = split.pop(),
                            parentContext = this.getContext(split),
                            uid = observableListener.uid;

                        this.__observedIdentifier = null;
                        access(parentContext, property);

                        if (isString(this.__observedIdentifier)) {
                            join = this.__observedIdentifier;
                        }

                        var removeObservableListener = removeCallback,
                            removeListener = this.observeArray(uid, noop, join, context, null),
                            removeArrayObserve = this.observe(join, {
                                uid: uid,
                                listener: (newValue: Array<any>, oldValue: Array<any>) => {
                                    removeListener();
                                    removeListener = this.observeArray(uid, noop, join, newValue, oldValue);
                                }
                            });

                        removeCallback = () => {
                            removeObservableListener();
                            removeArrayObserve();
                            removeListener();
                        };
                    } else {
                        this._define(absoluteIdentifier, context, key);
                    }
                }

                return removeCallback;
            }
        
            /**
             * @name observeArray
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Observes an array and calls the listener when certain functions are called on 
             * that array. The watched functions are push, pop, shift, splice, unshift, sort, 
             * and reverse.
             * 
             * @param {string} uid The unique ID of the object observing the array.
             * @param {(ev: plat.observable.IArrayMethodInfo<any>) => void} listener The callback for when an observed Array 
             * function has been called.
             * @param {string} absoluteIdentifier The identifier from the root context used to find the array.
             * @param {Array<any>} array The array to be observed.
             * @param {Array<any>} oldArray The old array to stop observing.
             * 
             * @returns {plat.IRemoveListener} A function to stop observing the array identified by the absoluteIdentifier.
             */
            observeArray(uid: string, listener: (ev: IArrayMethodInfo<any>) => void,
                absoluteIdentifier: string, array: Array<any>, oldArray: Array<any>): IRemoveListener {
                var length = arrayMethods.length,
                    method: string,
                    i: number,
                    $compat = this.$Compat,
                    proto = $compat.proto,
                    setProto = $compat.setProto;

                if (isArray(oldArray)) {
                    if (setProto) {
                        (<any>Object).setPrototypeOf(oldArray, Object.create(Array.prototype));
                    } else if (proto) {
                        (<any>oldArray).__proto__ = Object.create(Array.prototype);
                    } else {
                        for (i = 0; i < length; ++i) {
                            method = arrayMethods[i];
                            (<any>oldArray)[method] = (<any>Array.prototype)[method];
                        }
                    }
                }

                if (isNull(array)) {
                    return noop;
                }

                var split = absoluteIdentifier.split('.'),
                    property = split.pop(),
                    context = this.getContext(split);

                this.__observedIdentifier = null;
                access(context, property);

                if (isString(this.__observedIdentifier)) {
                    absoluteIdentifier = this.__observedIdentifier;
                }

                var observedArrayCallbacks = ContextManager.observedArrayListeners[absoluteIdentifier];

                if (isNull(observedArrayCallbacks)) {
                    observedArrayCallbacks = ContextManager.observedArrayListeners[absoluteIdentifier] = {};
                }

                var arrayCallbacks = observedArrayCallbacks[uid];

                if (isNull(arrayCallbacks)) {
                    arrayCallbacks = observedArrayCallbacks[uid] = [];
                }

                var removeListener = () => {
                    arrayCallbacks.splice(arrayCallbacks.indexOf(listener), 1);
                };

                arrayCallbacks.push(listener);

                if (proto) {
                    var obj = Object.create(Array.prototype);

                    for (i = 0; i < length; ++i) {
                        method = arrayMethods[i];
                        obj[method] = this._overwriteArrayFunction(absoluteIdentifier, method);
                    }

                    if (setProto) {
                        (<any>Object).setPrototypeOf(array, obj);
                    } else {
                        (<any>array).__proto__ = obj;
                    }

                    return removeListener;
                }

                for (i = 0; i < length; ++i) {
                    method = arrayMethods[i];
                    ContextManager.defineProperty(array, method,
                        this._overwriteArrayFunction(absoluteIdentifier, method), false, true);
                }

                return removeListener;
            }
        
            /**
             * @name dispose
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Disposes the memory for an {@link plat.observable.IContextManager|IContextManager}.
             * 
             * @returns {void}
             */
            dispose(): void {
                this.context = null;
                this.__identifiers = {};
                this.__identifierHash = {};
                this.__contextObjects = {};
            }
        
            /**
             * @name _getImmediateContext
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Gets the immediate context of identifier by splitting on "." 
             * and observes the objects along the way.
             * 
             * @param {string} identifier The identifier being observed.
             * 
             * @returns {any} The immediate context denoted by the identifier.
             */
            _getImmediateContext(identifier: string): any {
                if (isNull(this.__identifiers[identifier])) {
                    this.observe(identifier, null);
                }

                var split = identifier.split('.'),
                    context = this.context;

                while (split.length > 0) {
                    context = context[split.shift()];
                    if (isNull(context)) {
                        break;
                    }
                }

                return context;
            }
        
            /**
             * @name _getValues
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Obtains the old value and new value of a given context 
             * property on a property changed event.
             * 
             * @param {Array<string>} split The split identifier of the property that changed.
             * @param {any} newRootContext The new context.
             * @param {any} oldRootContext The old context.
             * 
             * @returns {{ newValue: any; oldValue: any; }} An object containing the old value and new value of a 
             * property upon a potential context change.
             */
            _getValues(split: Array<string>, newRootContext: any, oldRootContext: any): { newValue: any; oldValue: any; } {
                var property: string,
                    doNew = true,
                    doOld = true;

                while (split.length > 1) {
                    property = split.shift();
                    if (doNew) {
                        newRootContext = newRootContext[property];
                        if (isNull(newRootContext)) {
                            doNew = false;
                        }
                    }
                    if (doOld) {
                        oldRootContext = oldRootContext[property];
                        if (isNull(oldRootContext)) {
                            doOld = false;
                        }
                    }

                    if (!(doNew || doOld)) {
                        return null;
                    }
                }

                property = split[0];

                var newValue: any,
                    oldValue: any;

                if (!isNull(newRootContext)) {
                    newValue = newRootContext[property];
                }

                if (!isNull(oldRootContext)) {
                    oldValue = oldRootContext[property];
                }

                return {
                    newValue: newValue,
                    oldValue: oldValue
                };
            }
        
            /**
             * @name _notifyChildProperties
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Notifies all child properties being observed that a parent property 
             * has changed.
             * 
             * @param {string} identifier The identifier for the property that changed.
             * @param {any} newValue The new value of the property.
             * @param {any} oldValue The old value of the property.
             * 
             * @returns {void}
             */
            _notifyChildProperties(identifier: string, newValue: any, oldValue: any): void {
                var mappings = this.__identifierHash[identifier];

                if (isNull(mappings)) {
                    return;
                }

                var length = mappings.length,
                    binding: string,
                    property: string,
                    parentProperty: string,
                    split: Array<string>,
                    values: IObject<any> = {},
                    value: any,
                    key: string,
                    start = identifier.length + 1,
                    newParent: any,
                    oldParent: any,
                    newChild: any,
                    oldChild: any;

                if (length === 0) {
                    deleteProperty(this.__identifierHash, identifier);
                    return;
                }

                for (var i = 0; i < length; ++i) {
                    binding = mappings[i];
                    property = binding.slice(start);
                    split = property.split('.');
                    key = split.pop();
                    parentProperty = split.join('.');

                    if (isEmpty(parentProperty)) {
                        newParent = newValue;
                        oldParent = oldValue;
                        newChild = isNull(newParent) ? undefined : newParent[key];
                        oldChild = isNull(oldParent) ? undefined : oldParent[key];

                        if (key === 'length' && !isArray(oldParent) && isArray(newParent)) {
                            var lengthListener = this.__lengthListeners[binding];
                            if (!isNull(lengthListener)) {
                                var uid = lengthListener.uid,
                                    arraySplit = identifier.split('.'),
                                    arrayKey = arraySplit.pop(),
                                    arrayParent = this.getContext(arraySplit),
                                    join: string;

                                this.__observedIdentifier = null;
                                access(arrayParent, arrayKey);

                                join = isString(this.__observedIdentifier) ? this.__observedIdentifier : arraySplit.join('.');
                                var removeListener = this.observeArray(uid, noop, join, newParent, null);
                                this.observe(join, {
                                    uid: uid,
                                    listener: (nValue: Array<any>, oValue: Array<any>) => {
                                        removeListener();
                                        removeListener = this.observeArray(uid, noop, join, nValue, oValue);
                                    }
                                });

                                deleteProperty(this.__lengthListeners, binding);
                            }
                        }
                    } else {
                        value = values[parentProperty];

                        if (isNull(value)) {
                            value = values[parentProperty] = this._getValues(split, newValue, oldValue);

                            if (isNull(value)) {
                                this._execute(binding, null, null);
                                continue;
                            }
                        }

                        newParent = value.newValue;
                        oldParent = value.oldValue;
                        newChild = isNull(newParent) ? undefined : newParent[key];
                        oldChild = isNull(oldParent) ? undefined : oldParent[key];
                    }

                    values[property] = {
                        newValue: newChild,
                        oldValue: oldChild
                    };

                    if (isObject(newParent) && (!isArray(newParent) || newParent.length > key)) {
                        this._define(binding, newParent, key);
                    }

                    this._execute(binding, newChild, oldChild);
                }

                values = null;
            }
        
            /**
             * @name _addObservableListener
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Adds a listener to be fired for a particular identifier.
             * 
             * @param {string} absoluteIdentifier The identifier being observed.
             * @param {plat.observable.IListener} observableListener The function and associated unique ID to be fired 
             * for this identifier.
             * 
             * @returns {plat.IRemoveListener} A function for removing the given listener for the given absoluteIdentifier.
             */
            _addObservableListener(absoluteIdentifier: string, observableListener: IListener): IRemoveListener {
                var remove = () => {
                        this._removeCallback(absoluteIdentifier, observableListener);
                    },
                    split = absoluteIdentifier.split('.'),
                    property = split.pop(),
                    isLength = property === 'length',
                    context: any;

                if (isLength) {
                    property = split.pop();
                    context = this.getContext(split);
                }

                if (isObject(context)) {
                    this.__observedIdentifier = null;
                    access(context, property);

                    if (isString(this.__observedIdentifier)) {
                        absoluteIdentifier = this.__observedIdentifier + (isLength ? '.length' : '');
                    }
                }

                this.__add(absoluteIdentifier, observableListener);

                ContextManager.pushRemoveListener(absoluteIdentifier, observableListener.uid, remove);

                return remove;
            }
        
            /**
             * @name _define
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Observes a property on a given context specified by an identifier.
             * 
             * @param {string} identifier The full identifier path for the property being observed.
             * @param {any} immediateContext The object whose property will be observed.
             * @param {string} key The property key for the value on the immediateContext that's 
             * being observed.
             * 
             * @returns {void}
             */
            _define(identifier: string, immediateContext: any, key: string): void {
                if (isObject(immediateContext[key])) {
                    this.__defineObject(identifier, immediateContext, key);
                } else {
                    this.__definePrimitive(identifier, immediateContext, key);
                }
            }
        
            /**
             * @name _overwriteArrayFunction
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Intercepts an array function for observation.
             * 
             * @param {string} absoluteIdentifier The full identifier path for the observed array.
             * @param {string} method The array method being called.
             * 
             * @returns {(...args: any[]) => any} A function that acts as an intercept for an observed 
             * array function.
             */
            _overwriteArrayFunction(absoluteIdentifier: string, method: string): (...args: any[]) => any {
                var callbackObjects = ContextManager.observedArrayListeners[absoluteIdentifier],
                    _this = this;

                // we can't use a fat-arrow function here because we need the array context.
                return function observedArrayFn(...args: any[]) {
                    var oldArray = this.slice(0),
                        returnValue: any,
                        isShift = method.indexOf('shift') !== -1;

                    if (isShift) {
                        _this.__isArrayFunction = true;
                        returnValue = (<any>Array.prototype)[method].apply(this, args);
                        _this.__isArrayFunction = false;
                    } else {
                        returnValue = (<any>Array.prototype)[method].apply(this, args);
                    }

                    var keys = Object.keys(callbackObjects),
                        length = keys.length,
                        callbacks: Array<(ev: IArrayMethodInfo<any>) => void>,
                        jLength: number;

                    for (var i = 0; i < length; ++i) {
                        callbacks = callbackObjects[keys[i]];
                        jLength = callbacks.length;

                        for (var j = 0; j < jLength; ++j) {
                            callbacks[j]({
                                method: method,
                                returnValue: returnValue,
                                oldArray: oldArray,
                                newArray: this,
                                arguments: args
                            });
                        }
                    }

                    if (isShift) {
                        _this._notifyChildProperties(absoluteIdentifier, this, oldArray);
                    } else if (oldArray.length !== this.length) {
                        _this._execute(absoluteIdentifier + '.length', this.length, oldArray.length);
                    }

                    return returnValue;
                };
            }
        
            /**
             * @name _removeCallback
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Removes a single listener callback
             * 
             * @param {string} identifier The identifier attached to the callbacks.
             * @param {plat.observable.IListener} listener The observable listener to remove.
             * 
             * @returns {void}
             */
            _removeCallback(identifier: string, listener: IListener): void {
                var callbacks = this.__identifiers[identifier];
                if (isNull(callbacks)) {
                    return;
                }

                // splice the observed listener
                callbacks.splice(callbacks.indexOf(listener), 1);

                if (isEmpty(this.__identifiers[identifier])) {
                    deleteProperty(this.__identifierHash, identifier);
                    deleteProperty(this.__contextObjects, identifier);
                }
            }
        
            /**
             * @name _hasIdentifier
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Checks if the specified identifier is already being 
             * observed in this context.
             * 
             * @param {string} identifier The identifier being observed.
             * 
             * @returns {boolean} Whether or not the identiifer is already being observed.
             */
            _hasIdentifier(identifier: string): boolean {
                return !isEmpty(this.__identifiers[identifier]);
            }
        
            /**
             * @name _execute
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Executes the listeners for the specified identifier on 
             * this context.
             * 
             * @param {string} identifier The identifier attached to the callbacks.
             * @param {any} value The new value on this context specified by 
             * the identifier.
             * @param {any} oldValue The old value on this context specified by 
             * the identifier.
             * 
             * @returns {void}
             */
            _execute(identifier: string, value: any, oldValue: any): void {
                var observableListeners = this.__identifiers[identifier];

                if (isUndefined(value)) {
                    deleteProperty(this.__contextObjects, identifier);
                } else {
                    this.__contextObjects[identifier] = value;
                }

                if (isNull(observableListeners)) {
                    return;
                }

                for (var i = 0; i < observableListeners.length; ++i) {
                    observableListeners[i].listener(value, oldValue);
                }
            }
        
            /**
             * @name __defineObject
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access private
             * 
             * @description
             * Defines a getter and setter for an object using Object.defineProperty.
             * 
             * @param {string} identifier The identifier of the object being defined.
             * @param {any} immediateContext The parent object of the object being defined.
             * @param {string} key The property key of the object being defined.
             * 
             * @returns {void}
             */
            private __defineObject(identifier: string, immediateContext: any, key: string): void {
                var value = immediateContext[key];

                Object.defineProperty(immediateContext, key, {
                    configurable: true,
                    enumerable: true,
                    get: () => {
                        this.__observedIdentifier = identifier;
                        return value;
                    },
                    set: (newValue) => {
                        if (value === newValue) {
                            return;
                        }

                        var oldValue = value;
                        value = newValue;

                        if (this.__isArrayFunction) {
                            return;
                        }

                        var hash = this.__identifierHash[identifier],
                            childPropertiesLength = isArray(hash) ? hash.length : 0;

                        this._execute(identifier, value, oldValue);
                        if (childPropertiesLength > 0) {
                            this._notifyChildProperties(identifier, value, oldValue);
                        }

                        if (!isObject(value)) {
                            this.__definePrimitive(identifier, immediateContext, key);
                        }
                    }
                });
            }

            /**
             * @name __definePrimitive
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access private
             * 
             * @description
             * Defines a getter and setter for a primitive using Object.defineProperty.
             * 
             * @param {string} identifier The identifier of the primitive being defined.
             * @param {any} immediateContext The parent object of the primitive being defined.
             * @param {string} key The property key of the primitive being defined.
             * 
             * @returns {void}
             */
            private __definePrimitive(identifier: string, immediateContext: any, key: string): void {
                var value = immediateContext[key],
                    isDefined = !isNull(value);

                if (isArray(immediateContext) && key === 'length') {
                    return;
                }

                Object.defineProperty(immediateContext, key, {
                    configurable: true,
                    enumerable: true,
                    get: () => {
                        this.__observedIdentifier = identifier;
                        return value;
                    },
                    set: (newValue) => {
                        if (value === newValue) {
                            return;
                        }
                        var oldValue = value;
                        value = newValue;

                        if (this.__isArrayFunction && isArray(immediateContext)) {
                            return;
                        }

                        if (isObject(value)) {
                            var childPropertiesLength = this.__identifierHash[identifier].length;
                            this._execute(identifier, newValue, oldValue);
                            this.__defineObject(identifier, immediateContext, key);
                            if (childPropertiesLength > 0) {
                                this._notifyChildProperties(identifier, newValue, oldValue);
                            }
                        } else if (isDefined) {
                            this._execute(identifier, newValue, oldValue);
                        } else {
                            this._execute(identifier, newValue, oldValue);
                            this.__definePrimitive(identifier, immediateContext, key);
                            isDefined = true;
                        }
                    }
                });
            }

            /**
             * @name __add
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access private
             * 
             * @description
             * Adds and associates a listener with a given identifier.
             * 
             * @param {string} identifier The identifier to attach the listener.
             * @param {plat.observable.IListener} observableListener The listener being added.
             * 
             * @returns {void}
             */
            private __add(identifier: string, observableListener: IListener): void {
                var callbacks = this.__identifiers[identifier];

                if (isNull(callbacks)) {
                    callbacks = this.__identifiers[identifier] = [];
                }

                callbacks.push(observableListener);

                this.__addHashValues(identifier);
            }
        
            /**
             * @name __addHashValues
             * @memberof plat.observable.ContextManager
             * @kind function
             * @access private
             * 
             * @description
             * Adds a mapping for an identifier which allows quick access to it 
             * if a parent context is changed.
             * 
             * @param {string} identifier The identifier to map.
             * 
             * @returns {void}
             */
            private __addHashValues(identifier: string): void {
                var split = identifier.split('.'),
                    ident = split.shift(),
                    hashValue = this.__identifierHash[ident];

                if (isNull(hashValue)) {
                    hashValue = this.__identifierHash[ident] = [];
                    if (split.length === 0) {
                        return;
                    }
                }

                if (ident !== identifier && hashValue.indexOf(identifier) === -1) {
                    hashValue.push(identifier);
                }

                while (split.length > 0) {
                    ident += '.' + split.shift();
                    hashValue = this.__identifierHash[ident];

                    if (isNull(hashValue)) {
                        hashValue = this.__identifierHash[ident] = [];
                        if (ident !== identifier) {
                            hashValue.push(identifier);
                        }
                    } else if (ident !== identifier && hashValue.indexOf(identifier) === -1) {
                        hashValue.push(identifier);
                    }
                }
            }
        }

        /**
         * The Type for referencing the '$ContextManagerStatic' injectable as a dependency.
         */
        export function IContextManagerStatic(): IContextManagerStatic {
            return ContextManager;
        }

        register.injectable(__ContextManagerStatic, IContextManagerStatic, null, __STATIC);

        /**
         * @name IContextManagerStatic
         * @memberof plat.observable
         * @kind interface
         * 
         * @description
         * Creates and manages {@link plat.observable.IContextManager|IContextManagers} and has 
         * additional helper functions for observing objects and primitives.
         */
        export interface IContextManagerStatic {
            /**
             * @name observedArrayListeners
             * @memberof plat.observable.IContextManagerStatic
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.IObject<plat.IObject<Array<(ev: plat.observable.IArrayMethodInfo<any>) => void>>>}
             * 
             * @description
             * A set of functions to be fired when a particular observed array is mutated.
             */
            observedArrayListeners: IObject<IObject<Array<(ev: IArrayMethodInfo<any>) => void>>>;

            /**
             * @name getManager
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Gets the {@link plat.observable.IContextManager|IContextManager} associated to the given control. If no 
             * {@link plat.observable.IContextManager|IContextManager} exists, one is created for that control.
             * 
             * @param {plat.IControl} control The control on which to locate the {@link plat.observable.IContextManager|IContextManager}.
             * 
             * @returns {plat.observable.IContextManager} The {@link plat.observable.IContextManager|IContextManager} 
             * associated with the input control.
             */
            getManager(control: IControl): IContextManager;

            /**
             * @name dispose
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes all the listeners for a given control's unique ID.
             * 
             * @param {plat.IControl} control The control whose manager is being disposed.
             * @param {boolean} persist? Whether or not the control's context needs to 
             * be persisted post-disposal or can be set to null.
             * 
             * @returns {void}
             */
            dispose(control: IControl, persist?: boolean): void;

            /**
             * @name removeArrayListeners
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes all listeners for an Array associated with a given uid.
             * 
             * @param {string} absoluteIdentifier The identifier used to locate the array.
             * @param {string} uid The uid used to search for listeners.
             * 
             * @returns {void}
             */
            removeArrayListeners(absoluteIdentifier: string, uid: string): void;

            /**
             * @name getContext
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Safely retrieves the local context given a root context and an Array of
             * property strings.
             * 
             * @param {any} rootContext The root object in which to find a local context.
             * @param {Array<string>} split The string array containing properties used to index into 
             * the rootContext.
             * 
             * @returns {any} The narrowed down context.
             */
            getContext(rootContext: any, split: Array<string>): void;

            /**
             * @name defineProperty
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Defines an object property with the associated value. Useful for unobserving objects.
             * 
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated 
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             * 
             * @returns {void}
             */
            defineProperty(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void;

            /**
             * @name defineGetter
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Defines an object property with the associated value. Useful for unobserving objects.
             * 
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated 
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             * 
             * @returns {void}
             */
            defineGetter(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void;

            /**
             * @name pushRemoveListener
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Pushes the function for removing an observed property upon adding the property.
             * 
             * @param {string} identifer The identifier for which the remove listener is being pushed.
             * @param {string} uid The unique ID of the control observing the identifier.
             * @param {plat.IRemoveListener} listener The function for removing the observed property.
             * 
             * @returns {void}
             */
            pushRemoveListener(identifier: string, uid: string, listener: IRemoveListener): void;

            /**
             * @name removeIdentifier
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes a specified identifier from being observed for a given set of control IDs.
             * 
             * @param {Array<string>} uids The set of unique Ids for which to remove the specified identifier.
             * @param {string} identifier The identifier to stop observing.
             * 
             * @returns {void}
             */
            removeIdentifier(uids: Array<string>, identifier: string): void;

            /**
             * @name createContext
             * @memberof plat.observable.IContextManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Ensures that an identifier path will exist on a given control. Will create 
             * objects/arrays if necessary.
             * 
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * on which to create the context.
             * @param {string} identifier The period-delimited identifier string used to create 
             * the context path.
             * 
             * @returns {any} The newly created context object.
             */
            createContext(control: ui.ITemplateControl, identifier: string): any;
        }
    
        /**
         * @name IContextManager
         * @memberof plat.observable
         * @kind interface
         * 
         * @description
         * Describes an object that manages observing properties on any object.
         */
        export interface IContextManager {
            /**
             * @name context
             * @memberof plat.observable.IContextManager
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The root context associated with and to be managed by this 
             * {@link plat.observable.IContextManager|IContextManager}.
             */
            context: any;

            /**
             * @name getContext
             * @memberof plat.observable.IContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Safely retrieves the local context for this manager given an Array of
             * property strings.
             * 
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             * 
             * @returns {any} The obtained context.
             */
            getContext(split: Array<string>): any;

            /**
             * @name observe
             * @memberof plat.observable.IContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Given a period-delimited identifier, observes an object and calls the given listener when the 
             * object changes.
             * 
             * @param {string} absoluteIdentifier The period-delimited identifier noting the property to be observed.
             * @param {plat.observable.IListener} observableListener An object implmenting IObservableListener. The listener will be 
             * notified of object changes.
             * 
             * @returns {plat.IRemoveListener} A function to stop observing the object identified by the absoluteIdentifier.
             */
            observe(identifier: string, observableListener: IListener): IRemoveListener;

            /**
             * @name observeArray
             * @memberof plat.observable.IContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Observes an array and calls the listener when certain functions are called on 
             * that array. The watched functions are push, pop, shift, splice, unshift, sort, 
             * and reverse.
             * 
             * @param {string} uid The unique ID of the object observing the array.
             * @param {(ev: plat.observable.IArrayMethodInfo<any>) => void} listener The callback for when an observed Array 
             * function has been called.
             * @param {string} absoluteIdentifier The identifier from the root context used to find the array.
             * @param {Array<any>} array The array to be observed.
             * @param {Array<any>} oldArray The old array to stop observing.
             * 
             * @returns {plat.IRemoveListener} A function to stop observing the array identified by the absoluteIdentifier.
             */
            observeArray(uid: string, listener: (ev: IArrayMethodInfo<any>) => void,
                absoluteIdentifier: string, array: Array<any>, oldArray: Array<any>): IRemoveListener;

            /**
             * @name dispose
             * @memberof plat.observable.IContextManager
             * @kind function
             * @access public
             * 
             * @description
             * Disposes the memory for an {@link plat.observable.IContextManager|IContextManager}.
             * 
             * @returns {void}
             */
            dispose(): void;
        }
    
        /**
         * @name IListener
         * @memberof plat.observable
         * @kind interface
         * 
         * @description
         * An object specifying a listener callback function and a unique id to use to manage the
         * listener.
         */
        export interface IListener {
            /**
             * @name listener
             * @memberof plat.observable.IListener
             * @kind function
             * @access public
             * 
             * @description
             * A listener method called when the object it is observing is changed.
             * 
             * @param {any} value The new value of the object.
             * @param {any} oldValue The previous value of the object.
             * 
             * @returns {void}
             */
            listener(value: any, oldValue: any): void;
        
            /**
             * @name uid
             * @memberof plat.observable.IListener
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A unique id used to manage the listener.
             */
            uid: string;
        }
    
        /**
         * @name IArrayMethodInfo
         * @memberof plat.observable
         * @kind interface
         * 
         * @description
         * An object for Array method info. Takes a 
         * generic type to denote the type of array it uses.
         * 
         * @typeparam T Denotes the type of array it uses.
         */
        export interface IArrayMethodInfo<T> {
            /**
             * @name method
             * @memberof plat.observable.IArrayMethodInfo
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The method name that was called. Possible values are:
             * 'push', 'pop', 'reverse', 'shift', 'sort', 'splice', 
             * and 'unshift'
             */
            method: string;
        
            /**
             * @name returnValue
             * @memberof plat.observable.IArrayMethodInfo
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The value returned from the called function.
             */
            returnValue: any;
        
            /**
             * @name oldArray
             * @memberof plat.observable.IArrayMethodInfo
             * @kind property
             * @access public
             * 
             * @type {Array<T>}
             * 
             * @description
             * The previous value of the array.
             */
            oldArray: Array<T>;
        
            /**
             * @name newArray
             * @memberof plat.observable.IArrayMethodInfo
             * @kind property
             * @access public
             * 
             * @type {Array<T>}
             * 
             * @description
             * The new value of the array.
             */
            newArray: Array<T>;
        
            /**
             * @name arguments
             * @memberof plat.observable.IArrayMethodInfo
             * @kind property
             * @access public
             * 
             * @type {Array<any>}
             * 
             * @description
             * The arguments passed into the array function.
             */
            arguments: Array<any>;
        }

            /**
             * @name IObservableProperty
             * @memberof plat.observable
             * @access public
             * @kind interface
             * 
             * @description
             * Defines the object added to a template control when its element 
             * has an attribute control that extends {@link plat.controls.ObservableAttributeControl|ObservableAttributeControl}.
             * 
             * This will contain the value of the expression as well as a way to observe the 
             * attribute value for changes.
             * 
             * @remarks
             * {@link plat.controls.Option|plat-options} is a control that implements this interface, and puts an 'options' 
             * property on its associated template control.
             * 
             * The generic type corresponds to the type of object created when the attribute 
             * expression is evaluated.
             * 
             * @typeparam {any} T The type of the value obtained from the attribute's expression.
             */
            export interface IObservableProperty<T> {
                /**
                 * @name value
                 * @memberof plat.observable.IObservableProperty
                 * @access public
                 * @kind property
                 * 
                 * @type {T}
                 * 
                 * @description
                 * The value obtained from evaluating the attribute's expression.
                 */
                value: T;

                /**
                 * @name observe
                 * @memberof plat.observable.IObservableProperty
                 * @access public
                 * @kind function
                 * 
                 * @description
                 * A method for observing the attribute for changes.
                 * 
                 * @param {(newValue: T, oldValue: T) => void} listener The listener callback which will be pre-bound to the 
                 * template control.
                 * 
                 * @returns {plat.IRemoveListener} A method for removing the listener.
                 */
                observe(listener: (newValue: T, oldValue: T) => void): IRemoveListener;
            }
    }
    /**
     * @name events
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds classes and interfaces related to event management components in platypus.
     */
    export module events {
        /**
         * @name DispatchEvent
         * @memberof plat.events
         * @kind class
         * @access public
         * 
         * @implements {plat.events.IDispatchEventInstance}
         * 
         * @description
         * An event class that propagates through a control tree. 
         * Propagation of the event always starts at the sender, allowing a control to both 
         * initialize and consume an event. If a consumer of an event throws an error while 
         * handling the event it will be logged to the app using exception.warn. Errors will 
         * not stop propagation of the event.
         */
        export class DispatchEvent implements IDispatchEventInstance {
            /**
             * @name $EventManagerStatic
             * @memberof plat.events.DispatchEvent
             * @kind property
             * @access public
             * 
             * @type {plat.events.IEventManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.
             */
            $EventManagerStatic: IEventManagerStatic = acquire(__EventManagerStatic);

            /**
             * @name sender
             * @memberof plat.events.DispatchEvent
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The object that initiated the event.
             */
            sender: any;

            /**
             * @name name
             * @memberof plat.events.DispatchEvent
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The name of the event.
             */
            name: string;

            /**
             * @name direction
             * @memberof plat.events.DispatchEvent
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event direction this object is using for propagation.
             */
            direction: string;

            /**
             * @name initialize
             * @memberof plat.events.DispatchEvent
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'up'): void;
            /**
             * @name initialize
             * @memberof plat.events.DispatchEvent
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'down'): void;
            /**
             * @name initialize
             * @memberof plat.events.DispatchEvent
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'direct'): void;
            /**
             * @name initialize
             * @memberof plat.events.DispatchEvent
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction The direction of propagation
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: string): void;
            initialize(name: string, sender: any, direction?: string) {
                this.name = name;
                this.direction = direction || this.$EventManagerStatic.DIRECT;
                this.sender = sender;
            }

            /**
             * @name stopPropagation
             * @memberof plat.events.DispatchEvent
             * @kind function
             * @access public
             * 
             * @description
             * Call this method to halt the propagation of an upward-moving event.
             * Downward events cannot be stopped with this method.
             * 
             * @returns {void}
             */
            stopPropagation(): void {
                if (this.direction === this.$EventManagerStatic.UP) {
                    (<any>this.$EventManagerStatic.propagatingEvents)[this.name] = false;
                }
            }
        }

        /**
         * The Type for referencing the '$DispatchEventInstance' injectable as a dependency.
         */
        export function IDispatchEventInstance(): IDispatchEventInstance {
            return new DispatchEvent();
        }

        register.injectable(__DispatchEventInstance, IDispatchEventInstance, null, __INSTANCE);

        /**
         * @name IDispatchEventInstance
         * @memberof plat.events
         * @kind interface
         * @access public
         * 
         * @description
         * Describes an event that propagates through a control tree. 
         * Propagation of the event always starts at the sender, allowing a control to both 
         * initialize and consume an event. If a consumer of an event throws an error while 
         * handling the event it will be logged to the app using exception.warn. Errors will 
         * not stop propagation of the event.
         */
        export interface IDispatchEventInstance {
            /**
             * @name sender
             * @memberof plat.events.IDispatchEventInstance
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The object that initiated the event.
             */
            sender: any;

            /**
             * @name name
             * @memberof plat.events.IDispatchEventInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The name of the event.
             */
            name: string;

            /**
             * @name direction
             * @memberof plat.events.IDispatchEventInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event direction this object is using for propagation.
             */
            direction: string;

            /**
             * @name initialize
             * @memberof plat.events.IDispatchEventInstance
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'up'): void;
            /**
             * @name initialize
             * @memberof plat.events.IDispatchEventInstance
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'down'): void;
            /**
             * @name initialize
             * @memberof plat.events.IDispatchEventInstance
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'direct'): void;
            /**
             * @name initialize
             * @memberof plat.events.IDispatchEventInstance
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object that initiated the event.
             * @param {string} direction The direction of propagation
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: string): void;

            /**
             * @name stopPropagation
             * @memberof plat.events.IDispatchEventInstance
             * @kind function
             * @access public
             * 
             * @description
             * Call this method to halt the propagation of an upward-moving event.
             * Downward events cannot be stopped with this method.
             * 
             * @returns {void}
             */
            stopPropagation(): void;
        }

        /**
         * @name LifecycleEvent
         * @memberof plat.events
         * @kind class
         * 
         * @extends {plat.events.DispatchEvent}
         * @implements {plat.events.ILifecycleEvent}
         * 
         * @description
         * Represents a Lifecycle Event. Lifecycle Events are always direct events.
         */
        export class LifecycleEvent extends DispatchEvent implements ILifecycleEvent {
            /**
             * @name dispatch
             * @memberof plat.events.LifecycleEvent
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a new LifecycleEvent and fires it.
             * 
             * @typeparam {Error} E The type of Error this event represents.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * 
             * @returns {void}
             */
            static dispatch(name: string, sender: any): void {
                var event = new LifecycleEvent();

                event.initialize(name, sender);
                EventManager.sendEvent(event);
            }

            /**
             * @name initialize
             * @memberof plat.events.LifecycleEvent
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             */
            initialize(name: string, sender: any): void {
                super.initialize(name, sender, this.$EventManagerStatic.DIRECT);
            }
        }

        /**
         * The Type for referencing the '$LifecycleEventStatic' injectable as a dependency.
         */
        export function ILifecycleEventStatic(): ILifecycleEventStatic {
            return LifecycleEvent;
        }

        register.injectable(__LifecycleEventStatic, ILifecycleEventStatic, null, __STATIC);

        /**
         * @name ILifecycleEventStatic
         * @memberof plat.events
         * @kind interface
         * 
         * @description
         * Dispatches {@link plat.events.LifecycleEvent|LifecycleEvent}
         */
        export interface ILifecycleEventStatic {
            /**
             * @name dispatch
             * @memberof plat.events.ILifecycleEventStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a new LifecycleEvent and fires it.
             * 
             * @typeparam {Error} E The type of Error this event represents.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * 
             * @returns {void}
             */
            dispatch(name: string, sender: any): void;
        }

        /**
         * @name ILifecycleEvent
         * @memberof plat.events
         * @kind interface
         * 
         * @extends {plat.events.IDispatchEventInstance}
         * 
         * @description
         * Represents a Lifecycle Event. Lifecycle Events are always direct events.
         */
        export interface ILifecycleEvent extends IDispatchEventInstance {
            /**
             * @name initialize
             * @memberof plat.events.ILifecycleEvent
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any): void;
        }

        /**
         * @name EventManager
         * @memberof plat.events
         * @kind class
         * @access public
         * 
         * @description
         * Manages dispatching events, handling all propagating events as well as any error handling.
         */
        export class EventManager {
            /**
             * @name $Compat
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ICompat}
             * 
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            static $Compat: ICompat;

            /**
             * @name $Document
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {Document}
             * 
             * @description
             * Reference to the {@link plat.Document|Document} injectable.
             */
            static $Document: Document;

            /**
             * @name $Window
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {Window}
             * 
             * @description
             * Reference to the {@link plat.Window|Window} injectable.
             */
            static $Window: Window;

            /**
             * @name $Dom
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ui.IDom}
             * 
             * @description
             * Reference to the {@link plat.ui.IDom|IDom} injectable.
             */
            static $Dom: ui.IDom;

            /**
             * @name UP
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * An upward-moving event will start at the sender and move 
             * up the parent chain.
             */
            static UP = 'up';

            /**
             * @name DOWN
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * A downward-moving event will start at the sender and move 
             * to its children and beyond.
             */
            static DOWN = 'down';

            /**
             * @name DIRECT
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Goes through all listeners for an event name, ignoring order.
             */
            static DIRECT = 'direct';

            /**
             * @name propagatingEvents
             * @memberof plat.events.EventManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.IObject<boolean>}
             * 
             * @description
             * Keeps track of which events are currently propagating.
             */
            static propagatingEvents: IObject<boolean> = {};

            /**
             * @name __eventsListeners
             * @memberof plat.events.EventManager
             * @kind property
             * @access private
             * @static
             * 
             * @type {plat.IObject<plat.events.IEventsListener>}
             * 
             * @description
             * Holds all the {@link plat.events.IEventsListener|event listeners} keyed by uid.
             */
            private static __eventsListeners: IObject<IEventsListener> = {};

            /**
             * @name __lifecycleEventListeners
             * @memberof plat.events.EventManager
             * @kind property
             * @access private
             * @static
             * 
             * @type {Array<{ name: string; value: () => void; }>}
             * 
             * @description
             * Holds all the event listeners for the application lifefycle events.
             */
            private static __lifecycleEventListeners: Array<{ name: string; value: () => void; }> = [];

            /**
             * @name __initialized
             * @memberof plat.events.EventManager
             * @kind property
             * @access private
             * @static
             * 
             * @type {boolean}
             * 
             * @description
             * whether or not the event manager has been initialized.
             */
            private static __initialized = false;

            /**
             * @name initialize
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Initializes the {@link plat.events.EventManager|EventManager}, creating the initial ALM event listeners.
             * 
             * @returns {void}
             */
            static initialize(): void {
                if (EventManager.__initialized) {
                    return;
                }

                EventManager.__initialized = true;

                var lifecycleListeners = EventManager.__lifecycleEventListeners,
                    length = lifecycleListeners.length,
                    $compat = EventManager.$Compat,
                    $document = EventManager.$Document,
                    $dom = EventManager.$Dom,
                    dispatch = LifecycleEvent.dispatch,
                    listener: { name: string; value: () => void; };

                while (lifecycleListeners.length > 0) {
                    listener = lifecycleListeners.pop();
                    $document.removeEventListener(listener.name, listener.value, false);
                }

                if ($compat.cordova) {
                    var eventNames = ['resume', 'online', 'offline'],
                        event: string;

                    length = eventNames.length;

                    for (var i = 0; i < eventNames.length; ++i) {
                        event = eventNames[i];
                        lifecycleListeners.push({
                            name: event,
                            value: ((ev: string) => () => {
                                dispatch(ev, EventManager);
                            })(event)
                        });

                        $dom.addEventListener($document, event, lifecycleListeners[i].value, false);
                    }

                    lifecycleListeners.push({
                        name: 'pause',
                        value: () => {
                            dispatch('suspend', EventManager);
                        }
                    });

                    $dom.addEventListener($document, 'pause', lifecycleListeners[lifecycleListeners.length - 1].value, false);

                    lifecycleListeners.push({
                        name: 'deviceReady',
                        value: () => {
                            dispatch('ready', EventManager);
                        }
                    });

                    $dom.addEventListener($document, 'deviceReady', lifecycleListeners[lifecycleListeners.length - 1].value, false);

                    lifecycleListeners.push({
                        name: 'backbutton',
                        value: () => {
                            dispatch('goBack', EventManager);
                        }
                    });

                    $dom.addEventListener($document, 'backbutton', lifecycleListeners[lifecycleListeners.length - 1].value, false);
                } else if ($compat.amd) {
                    return;
                } else {
                    $dom.addEventListener(EventManager.$Window, 'load', () => {
                        dispatch('ready', EventManager);
                    });
                }
            }

            /**
             * @name dispose
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes all event listeners for a given uid. Useful for garbage collection when 
             * certain objects that listen to events go out of scope.
             * 
             * @param {string} uid The uid for which the event listeners will be removed.'
             * 
             * @returns {void}
             */
            static dispose(uid: string): void {
                deleteProperty(EventManager.__eventsListeners, uid);
            }

            /**
             * @name on
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when a {@link plat.events.DispatchEvent|DispatchEvent} is 
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: IDispatchEventInstance, ...args: any[]) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            static on(uid: string, eventName: string, listener: (ev: IDispatchEventInstance, ...args: any[]) => void,
                context?: any): IRemoveListener {
                var eventsListener = EventManager.__eventsListeners[uid];

                if (isNull(eventsListener)) {
                    eventsListener = EventManager.__eventsListeners[uid] = {
                        listeners: {},
                        context: context
                    };
                }

                var eventListeners = eventsListener.listeners[eventName];

                if (isNull(eventListeners)) {
                    eventListeners = eventsListener.listeners[eventName] = [];
                }

                eventListeners.push(listener);

                var index = eventListeners.length - 1;

                return () => {
                    eventListeners.splice(index, 1);
                };
            }

            /**
             * @name dispatch
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}.
             * @param {Array<any>} args? The arguments to send to the listeners.
             * 
             * @returns {void}
             */
            static dispatch(name: string, sender: any, direction: 'up', args?: Array<any>): void;
            /**
             * @name dispatch
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}.
             * @param {Array<any>} args? The arguments to send to the listeners.
             * 
             * @returns {void}
             */
            static dispatch(name: string, sender: any, direction: 'down', args?: Array<any>): void;
            /**
             * @name dispatch
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.
             * @param {Array<any>} args? The arguments to send to the listeners.
             * 
             * @returns {void}
             */
            static dispatch(name: string, sender: any, direction: 'direct', args?: Array<any>): void;
            /**
             * @name dispatch
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction The direction in which to send the event.
             * @param {Array<any>} args? The arguments to send to the listeners.
             * 
             * @returns {void}
             */
            static dispatch(name: string, sender: any, direction: string, args?: Array<any>): void;
            static dispatch(name: string, sender: any, direction: string, args?: Array<any>) {
                var $dispatchEvent: IDispatchEventInstance = acquire(__DispatchEventInstance);
                $dispatchEvent.initialize(name, sender, direction);
                EventManager.sendEvent($dispatchEvent, args);
            }

            /**
             * @name hasDirection
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns whether or not the given string is a registered direction.
             * 
             * @param {string} direction The direction of the event
             * 
             * @returns {boolean} Whether or not the direction is valid.
             */
            static hasDirection(direction: string): boolean {
                return (direction === EventManager.UP ||
                    direction === EventManager.DOWN ||
                    direction === EventManager.DIRECT);
            }

            /**
             * @name sendEvent
             * @memberof plat.events.EventManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines the appropriate direction and dispatches the event accordingly.
             * 
             * @param {plat.events.IDispatchEventInstance} event The {@link plat.events.DispatchEvent|DispatchEvent} to send
             * @param {Array<any>} args The arguments associated with the event
             * 
             * @returns {void}
             */
            static sendEvent(event: IDispatchEventInstance, args?: Array<any>): void {
                var name = event.name,
                    direction = event.direction;

                args = args || [];

                EventManager.propagatingEvents[name] = true;
                args = args || [];

                switch (direction) {
                    case EventManager.UP:
                        EventManager._dispatchUp(event, args);
                        break;
                    case EventManager.DOWN:
                        EventManager._dispatchDown(event, args);
                        break;
                    case EventManager.DIRECT:
                        EventManager._dispatchDirect(event, args);
                        break;
                }

                deleteProperty(EventManager.propagatingEvents, name);
            }

            /**
             * @name _dispatchUp
             * @memberof plat.events.EventManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Dispatches the event up the control chain.
             * 
             * @param {plat.events.IDispatchEventInstance} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             * 
             * @returns {void}
             */
            static _dispatchUp(event: IDispatchEventInstance, args: Array<any>): void {
                var name = event.name,
                    parent = event.sender;

                while (!isNull(parent) && EventManager.propagatingEvents[name]) {
                    if (isNull(parent.uid)) {
                        continue;
                    }
                    EventManager.__executeEvent(parent.uid, event, args);
                    parent = parent.parent;
                }
            }

            /**
             * @name _dispatchDown
             * @memberof plat.events.EventManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Dispatches the event down the control chain.
             * 
             * @param {plat.events.IDispatchEventInstance} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             * 
             * @returns {void}
             */
            static _dispatchDown(event: IDispatchEventInstance, args: Array<any>): void {
                var controls: Array<IControl> = [],
                    control: IControl,
                    name = event.name;

                controls.push(event.sender);

                while (controls.length && EventManager.propagatingEvents[name]) {
                    control = controls.pop();

                    if (isNull(control.uid)) {
                        continue;
                    }

                    EventManager.__executeEvent(control.uid, event, args);

                    if (isNull((<ui.ITemplateControl>control).controls)) {
                        continue;
                    }

                    controls = controls.concat((<ui.ITemplateControl>control).controls);
                }
            }

            /**
             * @name _dispatchDirect
             * @memberof plat.events.EventManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Dispatches the event directly to all listeners.
             * 
             * @param {plat.events.IDispatchEventInstance} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             * 
             * @returns {void}
             */
            static _dispatchDirect(event: IDispatchEventInstance, args: Array<any>): void {
                var uids = Object.keys(EventManager.__eventsListeners),
                    length = uids.length,
                    name = event.name,
                    eventsListener: IEventsListener;

                for (var i = 0; i < length; ++i) {
                    if (!EventManager.propagatingEvents[name]) {
                        break;
                    }

                    eventsListener = EventManager.__eventsListeners[uids[i]];

                    if (isNull(eventsListener) || isNull(eventsListener.listeners[name])) {
                        continue;
                    }

                    EventManager.__callListeners(eventsListener.context, event, eventsListener.listeners[name], args);
                }
            }

            /**
             * @name __executeEvent
             * @memberof plat.events.EventManager
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Dispatches the event to the listeners for the given uid.
             * 
             * @param {string} uid The uid used to find the event listeners.
             * @param {plat.events.IDispatchEventInstance} The event.
             * @param {Array<any>} args The arguments to send to the listeners.
             * 
             * @returns {void}
             */
            private static __executeEvent(uid: string, ev: IDispatchEventInstance, args: Array<any>): void {
                var eventsListener = EventManager.__eventsListeners[uid];

                if (isNull(eventsListener)) {
                    return;
                }
                var context = eventsListener.context,
                    listeners = eventsListener.listeners[ev.name];

                if (isNull(listeners)) {
                    return;
                }

                EventManager.__callListeners(context, ev, listeners, args);
            }

            /**
             * @name __callListeners
             * @memberof plat.events.EventManager
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Calls event listeners with the given context, event, and arguments.
             * 
             * @param {any} context The context with which to call the listeners.
             * @param {plat.events.IDispatchEventInstance} The event.
             * @param {Array<(ev: IDispatchEventInstance, ...args: any[]) => void>} The event listeners.
             * @param {Array<any>} args The arguments to send to the listeners.
             * 
             * @returns {void}
             */
            private static __callListeners(context: any, ev: IDispatchEventInstance,
                listeners: Array<(ev: IDispatchEventInstance, ...args: any[]) => void>, args: Array<any>): void {
                var name = ev.name,
                    length = listeners.length,
                    index = -1;

                args = [ev].concat(args);

                while (++index < length && EventManager.propagatingEvents[name]) {
                    try {
                        listeners[index].apply(context, args);
                    } catch (e) {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.warn(e, $exception.EVENT);
                    }
                }
            }
        }

        /**
         * The Type for referencing the '$EventManagerStatic' injectable as a dependency.
         */
        export function IEventManagerStatic(
            $Compat?: ICompat,
            $Document?: Document,
            $Window?: Window,
            $Dom?: ui.IDom): IEventManagerStatic {
                EventManager.$Compat = $Compat;
                EventManager.$Document = $Document;
                EventManager.$Window = $Window;
                EventManager.$Dom = $Dom;
                return EventManager;
        }

        register.injectable(__EventManagerStatic, IEventManagerStatic, [
            __Compat,
            __Document,
            __Window,
            __Dom
        ], __STATIC);

        /**
         * @name IEventManagerStatic
         * @memberof plat.events
         * @kind interface
         * @access public
         * 
         * @description
         * Manages dispatching events, handling all propagating events as well as any error handling.
         */
        export interface IEventManagerStatic {
            /**
             * @name $Compat
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             *
             * @type {plat.ICompat}
             *
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            $Compat: ICompat;

            /**
             * @name $Document
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             *
             * @type {Document}
             *
             * @description
             * Reference to the {@link plat.Document|Document} injectable.
             */
            $Document: Document;

            /**
             * @name $Window
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             *
             * @type {Window}
             *
             * @description
             * Reference to the {@link plat.Window|Window} injectable.
             */
            $Window: Window;

            /**
             * @name $Dom
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             *
             * @type {plat.ui.IDom}
             *
             * @description
             * Reference to the {@link plat.ui.IDom|IDom} injectable.
             */
            $Dom: ui.IDom;

            /**
             * @name UP
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             * @readonly
             *
             * @type {string}
             *
             * @description
             * An upward-moving event will start at the sender and move
             * up the parent chain.
             */
            UP: string;

            /**
             * @name DOWN
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             * @readonly
             *
             * @type {string}
             *
             * @description
             * A downward-moving event will start at the sender and move
             * to its children and beyond.
             */
            DOWN: string;

            /**
             * @name DIRECT
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             * @readonly
             *
             * @type {string}
             *
             * @description
             * Goes through all listeners for an event name, ignoring order.
             */
            DIRECT: string;

            /**
             * @name propagatingEvents
             * @memberof plat.events.IEventManagerStatic
             * @kind property
             * @access public
             * @static
             *
             * @type {plat.IObject<boolean>}
             *
             * @description
             * Keeps track of which events are currently propagating.
             */
            propagatingEvents: IObject<boolean>;

            /**
             * @name initialize
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Initializes the {@link plat.events.EventManager|EventManager}, creating the initial ALM event listeners.
             * 
             * @returns {void}
             */
            initialize(): void;

            /**
             * @name dispose
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Removes all event listeners for a given uid. Useful for garbage collection when 
             * certain objects that listen to events go out of scope.
             * 
             * @param {string} uid The uid for which the event listeners will be removed.'
             * 
             * @returns {void}
             */
            dispose(uid: string): void;

            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Registers a listener for the beforeNavigate Event. The listener will be called when the beforeNavigate 
             * event is propagating over the given uid. Any number of listeners can exist for a single event name. The 
             * listener can chose to cancel the event using ev.cancel(), preventing any navigation as well as further 
             * calls to event listeners.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='beforeNavigate' The name of the event to listen to.
             * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'beforeNavigate',
                listener: (ev: INavigationEvent<any>) => void, context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Registers a listener for the navigating Event. The listener will be called when the navigating 
             * event is propagating over the given uid. Any number of listeners can exist for a single event name.
             * The listener can chose to cancel the event using ev.cancel(), preventing any navigation as well as further 
             * calls to event listeners.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='navigating' Specifies that this is a listener for the navigating event.
             * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'navigating',
                listener: (ev: INavigationEvent<any>) => void, context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 2
             * 
             * @description
             * Registers a listener for the navigated Event. The listener will be called when the navigated 
             * event is propagating over the given uid. Any number of listeners can exist for a single event name.
             * The listener cannot cancel the event.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='navigated' Specifies that this is a listener for the navigated event.
             * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'navigated',
                listener: (ev: INavigationEvent<any>) => void, context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 3
             * 
             * @description
             * Registers a listener for a NavigationEvent. The listener will be called when a NavigationEvent is
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: string, listener: (ev: INavigationEvent<any>) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 4
             * 
             * @description
             * Registers a listener for the ready AlmEvent. The ready event will be called when the app 
             * is ready to start.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='ready' Specifies that the listener is for the ready event.
             * @param {(ev: plat.events.ILifecycleEvent) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'ready', listener: (ev: ILifecycleEvent) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 5
             * 
             * @description
             * Registers a listener for the suspend AlmEvent. The listener will be called when an app 
             * is being suspended.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='suspend' Specifies the listener is for the suspend event.
             * @param {(ev: plat.events.ILifecycleEvent) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'suspend', listener: (ev: ILifecycleEvent) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 6
             * 
             * @description
             * Registers a listener for the resume AlmEvent. The listener will be called when an app 
             * is being resumeed.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='suspend' Specifies the listener is for the resume event.
             * @param {(ev: plat.events.ILifecycleEvent) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'resume', listener: (ev: ILifecycleEvent) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 7
             * 
             * @description
             * Registers a listener for the online AlmEvent. This event fires when the app's network 
             * connection changes to be online.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='online' Specifies the listener is for the online event.
             * @param {(ev: plat.events.ILifecycleEvent) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'online', listener: (ev: ILifecycleEvent) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 8
             * 
             * @description
             * Registers a listener for the offline AlmEvent. This event fires when the app's network 
             * connection changes to be offline.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName='offline' Specifies the listener is for the offline event.
             * @param {(ev: plat.events.ILifecycleEvent) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'offline', listener: (ev: ILifecycleEvent) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 9
             * 
             * @description
             * Registers a listener for an AlmEvent. The listener will be called when an AlmEvent is
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: plat.events.ILifecycleEvent) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: string, listener: (ev: ILifecycleEvent) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 10
             * 
             * @description
             * Registers a listener for a ErrorEvent. The listener will be called when a ErrorEvent is
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: plat.events.IErrorEvent<Error>) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: 'error', listener: (ev: IErrorEvent<Error>) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 11
             * 
             * @description
             * Registers a listener for a ErrorEvent. The listener will be called when a ErrorEvent is
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: plat.events.IErrorEvent<any>) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: string, listener: (ev: IErrorEvent<any>) => void,
                context?: any): IRemoveListener;
            /**
             * @name on
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * @variation 12
             * 
             * @description
             * Registers a listener for a DispatchEvent. The listener will be called when a DispatchEvent is
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * 
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: plat.events.IDispatchEventInstance, ...args: any[]) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             * 
             * @returns {plat.IRemoveListener} A method for removing the listener.
             */
            on(uid: string, eventName: string, listener: (ev: IDispatchEventInstance, ...args: any[]) => void,
                context?: any): IRemoveListener;

            /**
             * @name dispatch
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             *
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             *
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}.
             * @param {Array<any>} args? The arguments to send to the listeners.
             *
             * @returns {void}
             */
            dispatch(name: string, sender: any, direction: 'up', args?: Array<any>): void;
            /**
             * @name dispatch
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             *
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             *
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}.
             * @param {Array<any>} args? The arguments to send to the listeners.
             *
             * @returns {void}
             */
            dispatch(name: string, sender: any, direction: 'down', args?: Array<any>): void;
            /**
             * @name dispatch
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             *
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             *
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.
             * @param {Array<any>} args? The arguments to send to the listeners.
             *
             * @returns {void}
             */
            dispatch(name: string, sender: any, direction: 'direct', args?: Array<any>): void;
            /**
             * @name dispatch
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             *
             * @description
             * Looks for listeners to a given event name, and fires the listeners using the specified
             * event direction.
             *
             * @param {string} name The name of the event.
             * @param {any} sender The object sending the event.
             * @param {string} direction The direction in which to send the event.
             * @param {Array<any>} args? The arguments to send to the listeners.
             *
             * @returns {void}
             */
            dispatch(name: string, sender: any, direction: string, args?: Array<any>): void;

            /**
             * @name hasDirection
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns whether or not the given string is a registered direction.
             * 
             * @param {string} direction The direction of the event
             * 
             * @returns {boolean} Whether or not the direction is valid.
             */
            hasDirection(direction: string): boolean;

            /**
             * @name sendEvent
             * @memberof plat.events.IEventManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines the appropriate direction and dispatches the event accordingly.
             * 
             * @param {plat.events.IDispatchEventInstance} event The {@link plat.events.DispatchEvent|DispatchEvent} to send
             * @param {Array<any>} args The arguments associated with the event
             * 
             * @returns {void}
             */
            sendEvent(event: IDispatchEventInstance, args?: Array<any>): void;
        }

        /**
         * @name IEventsListener
         * @memberof plat.events
         * @kind interface
         * @access public
         * 
         * @description
         * An object that contains event listeners.
         */
        interface IEventsListener {
            /**
             * @name listeners
             * @memberof plat.events.IEventsListener
             * @kind property
             * @access public
             * @static
             *
             * @type {plat.IObject<Array<(ev: plat.events.IDispatchEventInstance, ...args: any[]) => void>>}
             *
             * @description
             * An IObject of listener arrays, keyed by event name.
             */
            listeners: IObject<Array<(ev: IDispatchEventInstance, ...args: any[]) => void>>;
        
            /**
             * @name context
             * @memberof plat.events.IEventsListener
             * @kind property
             * @access public
             * @static
             *
             * @type {any}
             *
             * @description
             * The context with which to call each event listener.
             */
            context: any;
        }

        /**
         * A class used by the Navigator to dispatch Navigation events. Allows anyone to listen 
         * for navigation events and respond to them, even canceling them if necessary.
         * 
         * @generic P Corresponds to the type of event parameter.
         */
        export class NavigationEvent<P> extends DispatchEvent implements INavigationEvent<P> {
            static $EventManagerStatic: IEventManagerStatic;
            /**
             * Dispatches an event with the specified target type.
             * 
             * @param name The name of the event (e.g. 'beforeNavigate')
             * @param sender The object sending the event.
             * @param eventOptions An object implementing INavigationEvent, specifying what all event listeners
             * will be passed.
             */
            static dispatch<P>(name: string, sender: any, eventOptions: INavigationEventOptions<P>): INavigationEvent<P> {
                var event = new NavigationEvent<P>();

                event.initialize(name, sender, null, eventOptions);
                NavigationEvent.$EventManagerStatic.sendEvent(event, []);

                return event;
            }

            parameter: P;
            options: navigation.IBaseNavigationOptions;
            target: any;
            type: string;
            cancelable: boolean = true;
            cancelled: boolean = false;

            initialize(name: string, sender: any, direction?: string, eventOptions?: INavigationEventOptions<P>) {
                super.initialize(name, sender, this.$EventManagerStatic.DIRECT);
                this.parameter = eventOptions.parameter;
                this.options = eventOptions.options;
                this.target = eventOptions.target;
                this.type = eventOptions.type;
            }

            cancel() {
                if (this.cancelable) {
                    this.cancelled = true;

                    (<any>this.$EventManagerStatic.propagatingEvents)[this.name] = false;
                }
            }
        }

        /**
         * The Type for referencing the '$NavigationEventStatic' injectable as a dependency.
         */
        export function INavigationEventStatic($EventManagerStatic?: IEventManagerStatic): INavigationEventStatic {
            NavigationEvent.$EventManagerStatic = $EventManagerStatic;
            return NavigationEvent;
        }

        register.injectable(__NavigationEventStatic, INavigationEventStatic, [__EventManagerStatic], __STATIC);

        /**
         * The intended external interface for the '$NavigationEventStatic' injectable.
         */
        export interface INavigationEventStatic {
            /**
             * Dispatches an event with the specified target type.
             * 
             * @generic P Corresponds to the type of the event parameter.
             * 
             * @param name The name of the event (e.g. 'beforeNavigate')
             * @param sender The object sending the event.
             * @param eventOptions An object implementing INavigationEvent, specifying what all event listeners
             * will be passed.
             */
            dispatch<P>(name: string, sender: any, eventOptions: events.INavigationEventOptions<P>): INavigationEvent<P>;
        }

        /**
         * Describes an object used by the Navigator to dispatch Navigation events.
         */
        export interface INavigationEvent<P> extends IDispatchEventInstance {
            /**
             * Navigation parameter, used to send objects from one view control to another.
             */
            parameter: P;

            /**
             * The INavigationOptions in use for the navigation.
             */
            options: navigation.IBaseNavigationOptions;

            /**
             * The navigation event target. Its type depends on the type of Navigation event.
             */
            target: any;

            /**
             * Specifies the type of IViewControl for the Route Event.
             */
            type: string;

            /**
             * The sender of the event.
             */
            sender: any;

            /**
             * States whether or not this event is able to be cancelled. Some navigation events can be 
             * cancelled, preventing further navigation.
             */
            cancelable?: boolean;

            /**
             * States whether or not this event has been cancelled.
             */
            cancelled?: boolean;

            /**
             * If the event is cancelable (ev.cancelable), calling this method will cancel the event.
             */
            cancel(): void;

            /**
             * Initializes the event members.
             * 
             * @param name The name of the event.
             * @param sender The object that initiated the event.
             * @param direction='direct' Equivalent to EventManager.direction.DIRECT.
             * 
             * @see EventManager.direction
             */
            initialize(name: string, sender: any, direction?: 'direct', eventOptions?: INavigationEventOptions<P>);
            /**
             * Initializes the event members.
             * 
             * @param name The name of the event.
             * @param sender The object that initiated the event.
             * @param direction This will always be a direct event no matter what is sent in.
             * 
             * @see EventManager.direction
             */
            initialize(name: string, sender: any, direction?: string, eventOptions?: INavigationEventOptions<P>);
        }

        /**
         * Describes options for an INavigationEvent. The generic parameter specifies the 
         * target type for the event.
         */
        export interface INavigationEventOptions<P> {
            /**
             * Navigation parameter, used to send objects from one view control to another.
             */
            parameter: P;

            /**
             * The INavigationOptions in use for the navigation.
             */
            options: navigation.IBaseNavigationOptions;

            /**
             * The navigation event target. Its type depends on the type of Navigation event.
             */
            target: any;

            /**
             * Specifies the type of IViewControl for the Route Event.
             */
            type: string;

            /**
             * States whether or not this event is able to be cancelled. Some navigation events can be 
             * cancelled, preventing further navigation.
             */
            cancelable?: boolean;
        }

        /**
         * @name ErrorEvent
         * @memberof plat.events
         * @kind class
         * 
         * @extends {plat.events.DispatchEvent}
         * @implements {plat.events.IErrorEvent}
         * 
         * @description
         * Represents an internal Error Event. This is used for any 
         * internal errors (both fatal and warnings). All error events are 
         * direct events.
         * 
         * @typeparam {Error} E The type of Error this event represents.
         */
        export class ErrorEvent<E extends Error> extends DispatchEvent implements IErrorEvent<E> {
            /**
             * @name $EventManagerStatic
             * @memberof plat.events.ErrorEvent
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.events.IEventManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.
             */
            static $EventManagerStatic: IEventManagerStatic;

            /**
             * @name dispatch
             * @memberof plat.events.ErrorEvent
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a new ErrorEvent and fires it.
             * 
             * @typeparam {Error} E The type of Error this event represents.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {E} error The error that occurred, resulting in the event.
             * 
             * @returns {void}
             */
            static dispatch<E extends Error>(name: string, sender: any, error: E): void {
                var event = new ErrorEvent<E>();

                event.initialize(name, sender, null, error);
                ErrorEvent.$EventManagerStatic.sendEvent(event);
            }

            /**
             * @name error
             * @memberof plat.events.ErrorEvent
             * @kind property
             * @access public
             * @static
             * 
             * @type {E}
             * 
             * @description
             * The error being dispatched.
             */
            error: E;

            /**
             * @name initialize
             * @memberof plat.events.ErrorEvent
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.
             * @param {E} error The error that occurred, resulting in the event.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'direct', error?: E): void;
            /**
             * @name initialize
             * @memberof plat.events.ErrorEvent
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {string} direction This is always a direct event.
             * @param {E} error The error that occurred, resulting in the event.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: string, error?: E): void;
            initialize(name: string, sender: any, direction?: string, error?: E) {
                super.initialize(name, sender, this.$EventManagerStatic.DIRECT);

                this.error = error;
            }
        }

        /**
         * The Type for referencing the '$ErrorEventStatic' injectable as a dependency.
         */
        export function IErrorEventStatic($EventManagerStatic?: IEventManagerStatic): IErrorEventStatic {
            ErrorEvent.$EventManagerStatic = $EventManagerStatic;
            return ErrorEvent;
        }

        register.injectable(__ErrorEventStatic, IErrorEventStatic, [__EventManagerStatic], __STATIC);

        /**
         * @name IErrorEventStatic
         * @memberof plat.events
         * @kind interface
         * 
         * @description
         * Dispatches {@link plat.events.ErrorEvent|ErrorEvents}
         */
        export interface IErrorEventStatic {
            /**
             * @name dispatch
             * @memberof plat.events.IErrorEventStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a new ErrorEvent and fires it.
             * 
             * @typeparam {Error} E The type of Error this event represents.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {E} error The error that occurred, resulting in the event.
             * 
             * @returns {void}
             */
            dispatch<E extends Error>(name: string, sender: any, error: E): void;
        }

        /**
         * @name IErrorEvent
         * @memberof plat.events
         * @kind interface
         * 
         * @extends {plat.events.IDispatchEventInstance}
         * 
         * @description
         * Represents an internal Error Event. This is used for any 
         * internal errors (both fatal and warnings). All error events are 
         * direct events.
         * 
         * @typeparam {Error} E The type of Error this event represents.
         */
        export interface IErrorEvent<E extends Error> extends IDispatchEventInstance {
            /**
             * @name error
             * @memberof plat.events.IErrorEvent
             * @kind property
             * @access public
             * @static
             * 
             * @type {E}
             * 
             * @description
             * The error being dispatched.
             */
            error: E;

            /**
             * @name initialize
             * @memberof plat.events.IErrorEvent
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.
             * @param {E} error The error that occurred, resulting in the event.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: 'direct', error?: E): void;
            /**
             * @name initialize
             * @memberof plat.events.IErrorEvent
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the event, populating its public properties.
             * 
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {string} direction This is always a direct event.
             * @param {E} error The error that occurred, resulting in the event.
             * 
             * @returns {void}
             */
            initialize(name: string, sender: any, direction?: string, error?: E): void;
        }
    }
    /**
     * @name Control
     * @memberof plat
     * @kind class
     * 
     * @implements {plat.IControl}
     * 
     * @description
     * Used for facilitating data and DOM manipulation. Contains lifecycle events 
     * as well as properties for communicating with other controls. This is the base
     * class for all types of controls.
     */
    export class Control implements IControl {
        /**
         * @name $Parser
         * @memberof plat.Control
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.expressions.IParser}
         * 
         * @description
         * Reference to the {@link plat.expressions.IParser|IParser} injectable.
         */
        static $Parser: expressions.IParser;

        /**
         * @name $ContextManagerStatic
         * @memberof plat.Control
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.observable.IContextManagerStatic}
         * 
         * @description
         * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
         */
        static $ContextManagerStatic: observable.IContextManagerStatic;

        /**
         * @name $EventManagerStatic
         * @memberof plat.Control
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.events.IEventManagerStatic}
         * 
         * @description
         * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.
         */
        static $EventManagerStatic: events.IEventManagerStatic;

        /**
         * @name __eventListeners
         * @memberof plat.Control
         * @kind property
         * @access private
         * @static
         * 
         * @type {plat.IObject<Array<plat.IRemoveListener>>}
         * 
         * @description
         * An object containing all controls' registered event listeners.
         */
        private static __eventListeners: IObject<Array<IRemoveListener>> = {};

        /**
         * @name getRootControl
         * @memberof plat.Control
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Finds the ancestor control for the given control that contains the root 
         * context.
         * 
         * @param {plat.IControl} control The control with which to find the root.
         * 
         * @returns {plat.ui.ITemplateControl} The root control.
         */
        static getRootControl(control: IControl): ui.ITemplateControl;
        static getRootControl(control: ui.ITemplateControl): ui.ITemplateControl {
            if (isNull(control)) {
                return control;
            } else if (!isNull(control.root)) {
                return control.root;
            }

            while (!(isNull(control.parent) || control.hasOwnContext)) {
                if (!isNull(control.root)) {
                    return control.root;
                }
                control = control.parent;
            }

            return control;
        }

        /**
         * @name load
         * @memberof plat.Control
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Given a control, calls the loaded method for the control if it exists.
         * 
         * @param {plat.IControl} control The control to load.
         * 
         * @returns {void}
         */
        static load(control: IControl): void {
            if (isNull(control)) {
                return;
            }

            var ctrl = <ui.ITemplateControl>control;
            if (isString(ctrl.absoluteContextPath) && isFunction(ctrl.contextChanged)) {
                var contextManager = Control.$ContextManagerStatic.getManager(ctrl.root);

                contextManager.observe(ctrl.absoluteContextPath, {
                    uid: control.uid,
                    listener: (newValue, oldValue) => {
                        ui.TemplateControl.contextChanged(control, newValue, oldValue);
                    }
                });

                if (isFunction((<any>ctrl).zCC__plat)) {
                    (<any>ctrl).zCC__plat();
                    deleteProperty(ctrl, 'zCC__plat');
                }
            }

            if (isFunction(control.loaded)) {
                control.loaded();
            }
        }

        /**
         * @name dispose
         * @memberof plat.Control
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Disposes all the necessary memory for a control. Uses specific dispose 
         * methods related to a control's constructor if necessary.
         * 
         * @param {plat.IControl} control The {@link plat.Control|Control} to dispose.
         * 
         * @returns {void}
         */
        static dispose(control: IControl): void {
            var ctrl = <any>control;

            if (isNull(ctrl)) {
                return;
            } else if (!isUndefined(ctrl.templateControl)) {
                controls.AttributeControl.dispose(ctrl);
                return;
            } else if (ctrl.hasOwnContext) {
                ui.ViewControl.dispose(ctrl);
                return;
            } else if (ctrl.controls) {
                ui.TemplateControl.dispose(ctrl);
                return;
            }

            Control.removeEventListeners(control);
            Control.$ContextManagerStatic.dispose(control);
            control.dispose();
            control.element = null;
            Control.removeParent(control);
        }

        /**
         * @name removeParent
         * @memberof plat.Control
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Splices a control from its parent's controls list. Sets the control's parent 
         * to null.
         * 
         * @param {plat.IControl} control The control whose parent will be removed.
         * 
         * @returns {void}
         */
        static removeParent(control: IControl): void {
            if (isNull(control)) {
                return;
            }

            var parent = control.parent;

            if (isNull(parent)) {
                return;
            }

            var controls = parent.controls || [],
                index = controls.indexOf(control);

            if (index !== -1) {
                controls.splice(index, 1);
            }

            control.parent = null;
        }

        /**
         * @name removeEventListeners
         * @memberof plat.Control
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Removes all event listeners for a control with the given uid.
         * 
         * @param {plat.IControl} control The control having its event listeners removed.
         * 
         * @returns {void}
         */
        static removeEventListeners(control: IControl): void {
            if (isNull(control)) {
                return;
            }

            var removeListeners = Control.__eventListeners,
                uid = control.uid;

            var listeners = removeListeners[uid];
            if (isArray(listeners)) {
                var index = listeners.length;
                while (index-- > 0) {
                    listeners[index]();
                }

                deleteProperty(removeListeners, uid);
            }
        }

        /**
         * @name getInstance
         * @memberof plat.Control
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Returns a new instance of {@link plat.Control|Control}.
         * 
         * @returns {plat.IControl} The newly instantiated control.
         */
        static getInstance(): IControl {
            return new Control();
        }

        /**
         * @name __addRemoveListener
         * @memberof plat.Control
         * @kind function
         * @access private
         * @static
         * 
         * @description
         * Adds a function to remove an event listener for the control specified 
         * by its uid.
         * 
         * @param {string} uid The uid of the control associated with the remove function.
         * @param {plat.IRemoveListener} listener The remove function to add.
         * 
         * @returns {void}
         */
        private static __addRemoveListener(uid: string, listener: IRemoveListener): void {
            var removeListeners = Control.__eventListeners;

            if (isArray(removeListeners[uid])) {
                removeListeners[uid].push(listener);
                return;
            }

            removeListeners[uid] = [listener];
        }

        /**
         * @name __spliceRemoveListener
         * @memberof plat.Control
         * @kind function
         * @access private
         * @static
         * 
         * @description
         * Removes a {@link plat.IRemoveListener|IRemoveListener} from a control's listeners.
         * 
         * @param {string} uid The uid of the control associated with the remove function.
         * @param {plat.IRemoveListener} listener The remove function to add.
         * 
         * @returns {void}
         */
        private static __spliceRemoveListener(uid: string, listener: IRemoveListener): void {
            var removeListeners = Control.__eventListeners,
                controlListeners = removeListeners[uid];

            if (isArray(controlListeners)) {
                var index = controlListeners.indexOf(listener);
                if (index === -1) {
                    return;
                }

                controlListeners.splice(index, 1);
            }
        }

        /**
         * @name __getControls
         * @memberof plat.Control
         * @kind function
         * @access private
         * @static
         * 
         * @description
         * Gets controls that have a specific key/value string pair.
         * 
         * 
         * @param {plat.IControl} control The at which to start searching for key/value pairs.
         * @param {string} key The key to search for on all the controls in the tree.
         * @param {string} value The expected value used to find similar controls.
         * 
         * @returns {Array<plat.IControl>} The controls matching the input key/value pair.
         */
        private static __getControls(control: IControl, key: string, value: string): Array<IControl> {
            var controls: Array<IControl> = [],
                root = Control.getRootControl(control),
                child: IControl;

            if (!isNull(root) && (<any>root)[key] === value) {
                controls.push(root);
            }

            var children = root.controls;

            if (isNull(children)) {
                return controls;
            }

            var queue: Array<IControl> = [];
            queue = queue.concat(children);

            while (queue.length > 0) {
                child = queue.shift();

                if ((<any>child)[key] === value) {
                    controls.push(child);
                }

                if (isNull((<ui.ITemplateControl>child).controls)) {
                    continue;
                }

                queue = queue.concat((<ui.ITemplateControl>child).controls);
            }

            return controls;
        }

        /**
         * @name uid
         * @memberof plat.Control
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {string}
         * 
         * @description
         * A unique id, created during instantiation and found on every {@link plat.Control|Control}.
         */
        uid: string;

        /**
         * @name type
         * @memberof plat.Control
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {string}
         * 
         * @description
         * The type of a {@link plat.Control|Control}.
         */
        type: string;

        /**
         * @name priority
         * @memberof plat.Control
         * @kind property
         * @access public
         * 
         * @type {number}
         * 
         * @description
         * Specifies the priority of the control. The purpose of 
         * this is so that controls like plat-bind can have a higher 
         * priority than plat-tap. The plat-bind will be initialized 
         * and loaded before plat-tap, meaning it has the first chance 
         * to respond to events.
         */
        priority = 0;

        /**
         * @name parent
         * @memberof plat.Control
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {plat.ui.ITemplateControl}
         * 
         * @description
         * The parent control that created this control.
         */
        parent: ui.ITemplateControl;

        /**
         * @name element
         * @memberof plat.Control
         * @kind property
         * @access public
         * 
         * @type {HTMLElement}
         * 
         * @description
         * The HTMLElement that represents this {@link plat.Control|Control}. Should only be modified by controls that implement 
         * {plat.ui.ITemplateControl|ITemplateControl}. During initialize the control should populate this element with what it wishes
         * to render to the user. 
         * 
         * @remarks
         * When there is innerHTML in the element prior to instantiating the control:
         *     The element will include the innerHTML
         * When the control implements templateString or templateUrl:
         *     The serialized DOM will be auto-generated and included in the element. Any
         *     innerHTML will be stored in the innerTemplate property on the control.
         * After an {@link plat.IControl|IControl} is initialized its element will be compiled.
         */
        element: HTMLElement;

        /**
         * @name attributes
         * @memberof plat.Control
         * @kind property
         * @access public
         * 
         * @type {plat.ui.IAttributesInstance}
         * 
         * @description
         * The attributes object representing all the attributes for a {@link plat.Control|Control's} element. All attributes are 
         * converted from dash notation to camelCase.
         */
        attributes: ui.IAttributesInstance;

        /**
         * @name dom
         * @memberof plat.Control
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {plat.ui.IDom}
         * 
         * @description
         * Contains DOM helper methods for manipulating this control's element.
         */
        dom: ui.IDom = acquire(__Dom);

        /**
         * @name constructor
         * @memberof plat.Control
         * @kind function
         * @access public
         * 
         * @description
         * The constructor for a control. Any injectables specified during control registration will be
         * passed into the constructor as arguments as long as the control is instantiated with its associated
         * injector.
         * 
         * @returns {plat.Control}
         */
        constructor() {
            var ContextManager: observable.IContextManagerStatic = Control.$ContextManagerStatic ||
                acquire(__ContextManagerStatic);
            ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));
        }

        /**
         * @name initialize
         * @memberof plat.Control
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * The initialize event method for a control. In this method a control should initialize all the necessary 
         * variables. This method is typically only necessary for view controls. If a control does not implement 
         * {@link plat.ui.IBaseViewControl|IBaseViewControl} then it is not safe to access, observe, or modify 
         * the context property in this method. A view control should call services/set context in this method in 
         * order to fire the loaded event. No control will be loaded until the view control has specified a context.
         * 
         * @returns {void}
         */
        initialize() { }

        /**
         * @name loaded
         * @memberof plat.Control
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * The loaded event method for a control. This event is fired after a control has been loaded,
         * meaning all of its children have also been loaded and initial DOM has been created and populated. It is now 
         * safe for all controls to access, observe, and modify the context property.
         * 
         * @returns {void}
         */
        loaded() { }

        /**
         * @name getControlsByName
         * @memberof plat.Control
         * @kind function
         * @access public
         * 
         * @description
         * Retrieves all the controls with the specified name.
         * 
         * @param {string} name The string name with which to populate the returned controls array.
         * 
         * @returns {Array<plat.IControl>} The controls that match the input name.
         */
        getControlsByName(name: string): Array<IControl> {
            return Control.__getControls(this, 'name', name);
        }

        /**
         * @name getControlsByType
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Retrieves all the controls of the specified type.
         * 
         * @typeparam {plat.Control} T The type of control to be returned in an Array.
         * 
         * @param {string} type The type used to find controls (e.g. 'plat-foreach')
         * 
         * @returns {Array<T>} The controls matching the input type.
         */
        getControlsByType<T extends Control>(type: string): Array<T>;
        /**
         * @name getControlsByType
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Retrieves all the controls of the specified type.
         * 
         * @typeparam {plat.Control} T The type of control to be returned in an Array.
         * 
         * @param {new () => T} Constructor The constructor used to find controls.
         * 
         * @returns {Array<T>} The controls matching the input type.
         */
        getControlsByType<T extends Control>(Constructor: new () => T): Array<T>;
        getControlsByType(type: any) {
            if (isString(type)) {
                return Control.__getControls(this, 'type', type);
            }
            return Control.__getControls(this, 'constructor', type);
        }

        /**
         * @name addEventListener
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Adds an event listener of the specified type to the specified element. Removal of the 
         * event is handled automatically upon disposal.
         * 
         * @param {EventTarget} element The element to add the event listener to.
         * @param {string} type The type of event to listen to.
         * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.
         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
         * of event propagation.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.
         */
        addEventListener(element: EventTarget, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;
        /**
         * @name addEventListener
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Adds an event listener of the specified type to the specified element. Removal of the 
         * event is handled automatically upon disposal.
         * 
         * @param {EventTarget} element The element to add the event listener to.
         * @param {string}  type The type of event to listen to.
         * @param {EventListener} listener The listener to fire when the event occurs.
         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
         * of event propagation.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.
         */
        addEventListener(element: EventTarget, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;
        addEventListener(element: any, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener {
            if (!isFunction(listener)) {
                var Exception: IExceptionStatic = acquire(__ExceptionStatic);
                Exception.warn('"Control.addEventListener" must take a function as the third argument.', Exception.EVENT);
                return noop;
            }

            listener = listener.bind(this);
            var removeListener = this.dom.addEventListener(element, type, listener, useCapture),
                uid = this.uid;

            Control.__addRemoveListener(uid, removeListener);

            return () => {
                removeListener();
                Control.__spliceRemoveListener(uid, removeListener);
            };
        }

        /**
         * @name observe
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when
         * the property is changed.
         * 
         * @typeparam {any} T The type of object to observe.
         * 
         * @param {any} context The immediate parent object containing the property.
         * @param {string} property The property identifier to watch for changes.
         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. This method 
         * will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.
         */
        observe<T>(context: any, property: string, listener: (value: T, oldValue: T) => void): IRemoveListener;
        /**
         * @name observe
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when
         * the property is changed.
         * 
         * @typeparam {any} T The type of object to observe.
         * 
         * @param {any} context The immediate parent object containing the property.
         * @param {number} property The property identifier to watch for changes.
         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. This method 
         * will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.
         */
        observe<T>(context: any, property: number, listener: (value: T, oldValue: T) => void): IRemoveListener;
        observe(context: any, property: any, listener: (value: any, oldValue: any) => void): IRemoveListener {
            if (isNull(context) || !context.hasOwnProperty(property)) {
                return noop;
            }

            var control = isFunction((<ui.ITemplateControl>(<any>this)).getAbsoluteIdentifier) ? this : <IControl>this.parent;

            if (isNull(control) || !isFunction((<ui.ITemplateControl>(<any>control)).getAbsoluteIdentifier)) {
                return noop;
            }

            var absoluteIdentifier = (<ui.ITemplateControl>(<any>control)).getAbsoluteIdentifier(context);

            if (isNull(absoluteIdentifier)) {
                return noop;
            }

            var contextManager = Control.$ContextManagerStatic.getManager(Control.getRootControl(this));

            return contextManager.observe(absoluteIdentifier + '.' + property, {
                listener: listener.bind(this),
                uid: this.uid
            });
        }

        /**
         * @name observeArray
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.
         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch
         * every item in the array.
         * 
         * @typeparam {any} T The type of the Array to observe.
         * 
         * @param {any} context The immediate parent object containing the array as a property.
         * @param {string} property The array property identifier to watch for changes.
         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. 
         * This method will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.
         */
        observeArray<T>(context: any, property: string, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;
        /**
         * @name observeArray
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.
         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch
         * every item in the array.
         * 
         * @typeparam {any} T The type of the Array to observe.
         * 
         * @param {any} context The immediate parent object containing the array as a property.
         * @param {number} property The array property identifier to watch for changes.
         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. 
         * This method will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.
         */
        observeArray<T>(context: any, property: number, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;
        observeArray(context: any, property: any, listener: (ev: observable.IArrayMethodInfo<any>) => void): IRemoveListener {
            if (isNull(context) || !context.hasOwnProperty(property)) {
                return noop;
            }

            var array = context[property],
                callback = listener.bind(this);

            if (!isArray(array)) {
                return noop;
            }

            var control = isFunction((<ui.ITemplateControl>this).getAbsoluteIdentifier) ? this : <IControl>this.parent;

            if (isNull(control) || !isFunction((<ui.ITemplateControl>control).getAbsoluteIdentifier)) {
                return noop;
            }

            var absoluteIdentifier = (<ui.ITemplateControl>control).getAbsoluteIdentifier(context),
                ContextManager = Control.$ContextManagerStatic;

            if (isNull(absoluteIdentifier)) {
                if (property === 'context') {
                    absoluteIdentifier = (<ui.ITemplateControl>control).absoluteContextPath;
                } else {
                    return noop;
                }
            } else {
                absoluteIdentifier += '.' + property;
            }

            var contextManager = ContextManager.getManager(Control.getRootControl(this)),
                uid = this.uid,
                removeCallback = contextManager.observe(absoluteIdentifier, {
                    listener: (newValue: Array<any>, oldValue: Array<any>) => {
                        removeListener();
                        removeListener = contextManager.observeArray(uid, callback, absoluteIdentifier, newValue, oldValue);
                    },
                    uid: uid
                }),
                removeListener = contextManager.observeArray(uid, callback, absoluteIdentifier, array, null);

            // need to call callback if 
            return () => {
                ContextManager.removeArrayListeners(absoluteIdentifier, uid);
                removeListener();
                removeCallback();
            };
        }

        /**
         * @name observeExpression
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Parses an expression string and observes any associated identifiers. When an identifier
         * value changes, the listener will be called.
         * 
         * @param {string} expression The expression string to watch for changes.
         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.
         */
        observeExpression(expression: string, listener: (value: any, oldValue: any) => void): IRemoveListener;
        /**
         * @name observeExpression
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Using a {@link plat.expressions.IParsedExpression|IParsedExpression} observes any associated identifiers. When an identifier
         * value changes, the listener will be called.
         * 
         * @param {plat.expressions.IParsedExpression} expression The expression string to watch for changes.
         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.
         */
        observeExpression(expression: expressions.IParsedExpression, listener: (value: any, oldValue: any) => void): IRemoveListener;
        observeExpression(expression: any, listener: (value: any, oldValue: any) => void): IRemoveListener {
            if (isNull(expression)) {
                return noop;
            } else if (!(isString(expression) || isFunction(expression.evaluate))) {
                return noop;
            }

            var parsedExpression: expressions.IParsedExpression = isString(expression) ? Control.$Parser.parse(expression) : expression,
                aliases = parsedExpression.aliases,
                control: ui.TemplateControl = !isNull((<ui.TemplateControl>(<any>this)).resources) ?
                    <ui.TemplateControl>(<any>this) :
                    <ui.TemplateControl>this.parent,
                alias: string,
                length = aliases.length,
                resources: IObject<observable.IContextManager> = {},
                ContextManager = Control.$ContextManagerStatic,
                getManager = ContextManager.getManager,
                TemplateControl = ui.TemplateControl,
                findResource = TemplateControl.findResource,
                evaluateExpression = TemplateControl.evaluateExpression,
                i: number;

            if (isNull(control) || !isString(control.absoluteContextPath)) {
                return noop;
            }

            for (i = 0; i < length; ++i) {
                alias = aliases[i];

                var resourceObj = findResource(control, alias);
                if (!isNull(resourceObj) && resourceObj.resource.type === 'observable') {
                    resources[alias] = getManager(resourceObj.control);
                }
            }

            var identifiers = parsedExpression.identifiers,
                contextManager = getManager(Control.getRootControl(control)),
                identifier: string,
                split: Array<string> = [],
                absolutePath = control.absoluteContextPath + '.',
                managers: IObject<observable.IContextManager> = {};

            length = identifiers.length;

            for (i = 0; i < length; ++i) {
                identifier = identifiers[i];
                split = identifier.split('.');

                if (identifier.indexOf('this') === 0) {
                    identifier = identifier.slice(5);
                } else if (identifier[0] === '@') {
                    alias = split[0].slice(1);
                    identifier = identifier.replace('@' + alias, 'resources.' + alias + '.value');

                    if (!isNull(resources[alias])) {
                        managers[identifier] = resources[alias];
                    }

                    continue;
                }

                managers[absolutePath + identifier] = contextManager;
            }

            identifiers = Object.keys(managers);
            length = identifiers.length;

            var oldValue = evaluateExpression(parsedExpression, control),
                listeners: Array<IRemoveListener> = [],
                uid = this.uid;

            for (i = 0; i < length; ++i) {
                identifier = identifiers[i];

                listeners.push(managers[identifier].observe(identifier, {
                    uid: uid,
                    listener: () => {
                        var value = evaluateExpression(parsedExpression, control);
                        listener.call(this, value, oldValue);
                        oldValue = value;
                    }
                }));
            }

            return () => {
                var length = listeners.length;

                for (var i = 0; i < length; ++i) {
                    listeners[i]();
                }
            };
        }

        /**
         * @name evaluateExpression
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Evaluates an expression string, using the control.parent.context.
         * 
         * @param {string} expression The expression string to evaluate.
         * @param {any} aliases Optional alias values to parse with the expression
         * 
         * @returns {any} The evaluated expression
         */
        evaluateExpression(expression: string, aliases?: any): any;
        /**
         * @name evaluateExpression
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Evaluates an {@link plat.expressions.IParsedExpression|IParsedExpression} using the control.parent.context.
         * 
         * @param {string} expression The expression string to evaluate.
         * @param {any} aliases Optional alias values to parse with the expression
         * 
         * @returns {any} The evaluated expression
         */
        evaluateExpression(expression: expressions.IParsedExpression, aliases?: any): any;
        evaluateExpression(expression: any, aliases?: any): any {
            var TemplateControl = ui.TemplateControl;
            return TemplateControl.evaluateExpression(expression, this.parent, aliases);
        }

        /**
         * @name dispatchEvent
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent(name: string, direction?: 'up', ...args: any[]): void;
        /**
         * @name dispatchEvent
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent(name: string, direction?: 'down', ...args: any[]): void;
        /**
         * @name dispatchEvent
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 2
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent(name: string, direction?: 'direct', ...args: any[]): void;
        /**
         * @name dispatchEvent
         * @memberof plat.Control
         * @kind function
         * @access public
         * @variation 3
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction The direction in which to send the event.
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent(name: string, direction?: string, ...args: any[]): void;
        dispatchEvent(name: string, direction?: string, ...args: any[]) {
            var manager = Control.$EventManagerStatic;

            if (!manager.hasDirection(direction)) {
                if (!isUndefined(direction)) {
                    args.unshift(direction);
                }
                direction = manager.UP;
            }
            var sender: any = this;

            if (!isNull(sender.templateControl)) {
                sender = sender.templateControl;
            }

            manager.dispatch(name, sender, direction, args);
        }

        /**
         * @name on
         * @memberof plat.Control
         * @kind function
         * @access public
         * 
         * @description
         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when a 
         * {@link plat.events.DispatchEvent|DispatchEvent} is propagating over the control. Any number of listeners can exist 
         * for a single event name.
         * 
         * @param {string} name The name of the event, cooinciding with the {@link plat.events.DispatchEvent|DispatchEvent} name.
         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when the 
         * {@link plat.events.DispatchEvent|DispatchEvent} is fired.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop listening for this event.
         */
        on(name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener {
            var manager = Control.$EventManagerStatic;
            return manager.on(this.uid, name, listener, this);
        }

        /**
         * @name dispose
         * @memberof plat.Control
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * The dispose event is called when a control is being removed from memory. A control should release 
         * all of the memory it is using, including DOM event and property listeners.
         * 
         * @returns {void}
         */
        dispose(): void { }
    }

    /**
     * The Type for referencing the '$ControlFactory' injectable as a dependency.
     */
    export function IControlFactory(
        $Parser?: expressions.IParser,
        $ContextManagerStatic?: observable.IContextManagerStatic,
        $EventManagerStatic?: events.IEventManagerStatic): IControlFactory {
            Control.$Parser = $Parser;
            Control.$ContextManagerStatic = $ContextManagerStatic;
            Control.$EventManagerStatic = $EventManagerStatic;
            return Control;
    }

    register.injectable(__ControlFactory, IControlFactory, [
        __Parser,
        __ContextManagerStatic,
        __EventManagerStatic
    ], __FACTORY);

    /**
     * @name IControlFactory
     * @memberof plat
     * @kind interface
     * 
     * @description
     * Creates and manages instances of {@link plat.IControl|IControl}.
     */
    export interface IControlFactory {
        /**
         * @name getRootControl
         * @memberof plat.IControlFactory
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Finds the ancestor control for the given control that contains the root 
         * context.
         * 
         * @param {plat.IControl} control The control with which to find the root.
         * 
         * @returns {plat.ui.ITemplateControl} The root control.
         */
        getRootControl(control: IControl): ui.ITemplateControl;

        /**
         * @name load
         * @memberof plat.IControlFactory
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Given a control, calls the loaded method for the control if it exists.
         * 
         * @param {plat.IControl} control The control to load.
         * 
         * @returns {void}
         */
        load(control: IControl): void;

        /**
         * @name dispose
         * @memberof plat.IControlFactory
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Disposes all the necessary memory for a control. Uses specific dispose 
         * methods related to a control's constructor if necessary.
         * 
         * @param {plat.IControl} control The {@link plat.Control|Control} to dispose.
         * 
         * @returns {void}
         */
        dispose(control: IControl): void;

        /**
         * @name removeParent
         * @memberof plat.IControlFactory
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Splices a control from its parent's controls list. Sets the control's parent 
         * to null.
         * 
         * @param {plat.IControl} control The control whose parent will be removed.
         * 
         * @returns {void}
         */
        removeParent(control: IControl): void;

        /**
         * @name removeEventListeners
         * @memberof plat.IControlFactory
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Removes all event listeners for a control with the given uid.
         * 
         * @param {plat.IControl} control The control having its event listeners removed.
         * 
         * @returns {void}
         */
        removeEventListeners(control: IControl): void;

        /**
         * @name getInstance
         * @memberof plat.IControlFactory
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Returns a new instance of {@link plat.Control|Control}.
         * 
         * @returns {plat.IControl} The newly instantiated control.
         */
        getInstance(): IControl;
    }

    /**
     * @name IControl
     * @memberof plat
     * @kind interface
     * 
     * @description
     * Used for facilitating data and DOM manipulation. Contains lifecycle events 
     * as well as properties for communicating with other controls. This is the base
     * class for all types of controls.
     */
    export interface IControl {
        /**
         * @name uid
         * @memberof plat.IControl
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {string}
         * 
         * @description
         * A unique id, created during instantiation and found on every {@link plat.Control|Control}.
         */
        uid: string;

        /**
         * @name type
         * @memberof plat.IControl
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {string}
         * 
         * @description
         * The type of a {@link plat.Control|Control}.
         */
        type?: string;

        /**
         * @name priority
         * @memberof plat.IControl
         * @kind property
         * @access public
         * 
         * @type {number}
         * 
         * @description
         * Specifies the priority of the control. The purpose of 
         * this is so that controls like plat-bind can have a higher 
         * priority than plat-tap. The plat-bind will be initialized 
         * and loaded before plat-tap, meaning it has the first chance 
         * to respond to events.
         */
        priority?: number;

        /**
         * @name parent
         * @memberof plat.IControl
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {plat.ui.ITemplateControl}
         * 
         * @description
         * The parent control that created this control.
         */
        parent?: ui.ITemplateControl;

        /**
         * @name element
         * @memberof plat.IControl
         * @kind property
         * @access public
         * 
         * @type {HTMLElement}
         * 
         * @description
         * The HTMLElement that represents this {@link plat.Control|Control}. Should only be modified by controls that implement 
         * {plat.ui.ITemplateControl|ITemplateControl}. During initialize the control should populate this element with what it wishes
         * to render to the user. 
         * 
         * @remarks
         * When there is innerHTML in the element prior to instantiating the control:
         *     The element will include the innerHTML
         * When the control implements templateString or templateUrl:
         *     The serialized DOM will be auto-generated and included in the element. Any
         *     innerHTML will be stored in the innerTemplate property on the control.
         * After an {@link plat.IControl|IControl} is initialized its element will be compiled.
         */
        element?: HTMLElement;

        /**
         * @name attributes
         * @memberof plat.IControl
         * @kind property
         * @access public
         * 
         * @type {plat.ui.IAttributesInstance}
         * 
         * @description
         * The attributes object representing all the attributes for a {@link plat.Control|Control's} element. All attributes are 
         * converted from dash notation to camelCase.
         */
        attributes?: ui.IAttributesInstance;

        /**
         * @name dom
         * @memberof plat.IControl
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {plat.ui.IDom}
         * 
         * @description
         * Contains DOM helper methods for manipulating this control's element.
         */
        dom: ui.IDom;

        /**
         * @name initialize
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * The initialize event method for a control. In this method a control should initialize all the necessary 
         * variables. This method is typically only necessary for view controls. If a control does not implement 
         * {@link plat.ui.IBaseViewControl|IBaseViewControl} then it is not safe to access, observe, or modify 
         * the context property in this method. A view control should call services/set context in this method in 
         * order to fire the loaded event. No control will be loaded until the view control has specified a context.
         * 
         * @returns {void}
         */
        initialize? (): void;

        /**
         * @name loaded
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * The loaded event method for a control. This event is fired after a control has been loaded,
         * meaning all of its children have also been loaded and initial DOM has been created and populated. It is now 
         * safe for all controls to access, observe, and modify the context property.
         * 
         * @returns {void}
         */
        loaded? (): void;

        /**
         * @name getControlsByName
         * @memberof plat.Control
         * @kind function
         * @access public
         * 
         * @description
         * Retrieves all the controls with the specified name.
         * 
         * @param {string} name The string name with which to populate the returned controls array.
         * 
         * @returns {Array<plat.IControl>} The controls that match the input name.
         */
        getControlsByName? (name: string): Array<IControl>;

        /**
         * @name getControlsByType
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Retrieves all the controls of the specified type.
         * 
         * @typeparam {plat.Control} T The type of control to be returned in an Array.
         * 
         * @param {string} type The type used to find controls (e.g. 'plat-foreach')
         * 
         * @returns {Array<T>} The controls matching the input type.
         */
        getControlsByType? <T extends IControl>(type: string): Array<T>;
        /**
         * @name getControlsByType
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Retrieves all the controls of the specified type.
         * 
         * @typeparam {plat.Control} T The type of control to be returned in an Array.
         * 
         * @param {new () => T} Constructor The constructor used to find controls.
         * 
         * @returns {Array<T>} The controls matching the input type.
         */
        getControlsByType? <T extends IControl>(Constructor: new () => T): Array<T>;

        /**
         * @name addEventListener
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Adds an event listener of the specified type to the specified element. Removal of the 
         * event is handled automatically upon disposal.
         * 
         * @param {EventTarget} element The element to add the event listener to.
         * @param {string} type The type of event to listen to.
         * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.
         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
         * of event propagation.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.
         */
        addEventListener? (element: EventTarget, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;
        /**
         * @name addEventListener
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Adds an event listener of the specified type to the specified element. Removal of the 
         * event is handled automatically upon disposal.
         * 
         * @param {EventTarget} element The element to add the event listener to.
         * @param {string}  type The type of event to listen to.
         * @param {EventListener} listener The listener to fire when the event occurs.
         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
         * of event propagation.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.
         */
        addEventListener? (element: EventTarget, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;

        /**
         * @name observe
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when
         * the property is changed.
         * 
         * @typeparam {any} T The type of object to observe.
         * 
         * @param {any} context The immediate parent object containing the property.
         * @param {string} property The property identifier to watch for changes.
         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. 
         * This method will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.
         */
        observe? <T>(context: any, property: string, listener: (value: T, oldValue: T) => void): IRemoveListener;
        /**
         * @name observe
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when
         * the property is changed.
         * 
         * @typeparam {any} T The type of object to observe.
         * 
         * @param {any} context The immediate parent object containing the property.
         * @param {number} property The property identifier to watch for changes.
         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. 
         * This method will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.
         */
        observe? <T>(context: any, property: number, listener: (value: T, oldValue: T) => void): IRemoveListener;

        /**
         * @name observeArray
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.
         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch
         * every item in the array.
         * 
         * @typeparam {any} T The type of the Array to observe.
         * 
         * @param {any} context The immediate parent object containing the array as a property.
         * @param {string} property The array property identifier to watch for changes.
         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. 
         * This method will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.
         */
        observeArray? <T>(context: any, property: string, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;
        /**
         * @name observeArray
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.
         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch
         * every item in the array.
         * 
         * @typeparam {any} T The type of the Array to observe.
         * 
         * @param {any} context The immediate parent object containing the array as a property.
         * @param {number} property The array property identifier to watch for changes.
         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. 
         * This method will have its 'this' context set to the control instance.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.
         */
        observeArray? <T>(context: any, property: number, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;

        /**
         * @name observeExpression
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Parses an expression string and observes any associated identifiers. When an identifier
         * value changes, the listener will be called.
         * 
         * @param {string} expression The expression string to watch for changes.
         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.
         */
        observeExpression? (expression: string, listener: (value: any, oldValue: any) => void): IRemoveListener;
        /**
         * @name observeExpression
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Using a {@link plat.expressions.IParsedExpression|IParsedExpression} observes any associated identifiers. When an identifier
         * value changes, the listener will be called.
         * 
         * @param {plat.expressions.IParsedExpression} expression The expression string to watch for changes.
         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.
         */
        observeExpression? (expression: expressions.IParsedExpression, listener: (value: any, oldValue: any) => void): IRemoveListener;

        /**
         * @name evaluateExpression
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Evaluates an expression string, using the control.parent.context.
         * 
         * @param {string} expression The expression string to evaluate.
         * @param {any} aliases Optional alias values to parse with the expression
         * 
         * @returns {any} The evaluated expression
         */
        evaluateExpression? (expression: string, aliases?: any): any;
        /**
         * @name evaluateExpression
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Evaluates an {@link plat.expressions.IParsedExpression|IParsedExpression} using the control.parent.context.
         * 
         * @param {string} expression The expression string to evaluate.
         * @param {any} aliases Optional alias values to parse with the expression
         * 
         * @returns {any} The evaluated expression
         */
        evaluateExpression? (expression: expressions.IParsedExpression, aliases?: any): any;

        /**
         * @name dispatchEvent
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent? (name: string, direction?: 'up', ...args: any[]): void;
        /**
         * @name dispatchEvent
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent? (name: string, direction?: 'down', ...args: any[]): void;
        /**
         * @name dispatchEvent
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 2
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent? (name: string, direction?: 'direct', ...args: any[]): void;
        /**
         * @name dispatchEvent
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @variation 3
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the 
         * provided direction mechanism. Controls in the propagation chain that registered
         * the event using the control.on() method will receive the event. Propagation will
         * always start with the sender, so the sender can both produce and consume the same
         * event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * control.on() method.
         * @param {string} direction The direction in which to send the event.
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent? (name: string, direction?: string, ...args: any[]): void;

        /**
         * @name on
         * @memberof plat.IControl
         * @kind function
         * @access public
         * 
         * @description
         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when a 
         * {@link plat.events.DispatchEvent|DispatchEvent} is propagating over the control. Any number of listeners can 
         * exist for a single event name.
         * 
         * @param {string} name The name of the event, cooinciding with the {@link plat.events.DispatchEvent|DispatchEvent} name.
         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when the 
         * {@link plat.events.DispatchEvent|DispatchEvent} is fired.
         * 
         * @returns {plat.IRemoveListener} A function to call in order to stop listening for this event.
         */
        on? (name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener;

        /**
         * @name dispose
         * @memberof plat.IControl
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * The dispose event is called when a control is being removed from memory. A control should release 
         * all of the memory it is using, including DOM event and property listeners.
         * 
         * @returns {void}
         */
        dispose? (): void;
    }

    /**
     * @name controls
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds all classes and interfaces related to attribute control components in platypus.
     */
    export module controls {
        /**
         * @name AttributeControl
         * @memberof plat.controls
         * @kind class
         * @access public
         * 
         * @extends {plat.Control}
         * @implements {plat.controls.IAttributeControl}
         * 
         * @description
         * A type of control that can be used as an attribute but will 
         * not be used to add, remove, or modify DOM.
         */
        export class AttributeControl extends Control implements IAttributeControl {
            /**
             * @name dispose
             * @memberof plat.controls.AttributeControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Method for disposing an attribute control. Removes any 
             * necessary objects from the control.
             * 
             * @param {plat.IAttributeControl} control The {@link plat.controls.AttributeControl|AttributeControl} to dispose.
             * 
             * @returns {void}
             */
            static dispose(control: IAttributeControl): void {
                deleteProperty(control, 'templateControl');

                Control.dispose(control);
            }

            /**
             * @name getInstance
             * @memberof plat.controls.AttributeControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of {@link plat.controls.AttributeControl|AttributeControl}.
             * 
             * @returns {plat.IAttributeControl}
             */
            static getInstance(): IAttributeControl {
                return new AttributeControl();
            }

            /**
             * @name templateControl
             * @memberof plat.controls.AttributeControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * Specifies the {@link plat.ui.ITemplateControl|ITemplateControl} associated with this
             * control's element. Can be null if no {@link plat.ui.ITemplateControl|ITemplateControl}
             * exists.
             */
            templateControl: ui.ITemplateControl = null;
        }

        /**
         * The Type for referencing the '$AttributeControlFactory' injectable as a dependency.
         */
        export function IAttributeControlFactory(): IAttributeControlFactory {
            return AttributeControl;
        }

        register.injectable(__AttributeControlFactory, IAttributeControlFactory, null, __FACTORY);

        /**
         * @name IAttributeControlFactory
         * @memberof plat.controls
         * @kind interface
         * 
         * @description
         * Creates and manages instances of {@link plat.controls.IAttributeControl|IAttributeControl}.
         */
        export interface IAttributeControlFactory {
            /**
             * @name dispose
             * @memberof plat.controls.IAttributeControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Method for disposing an attribute control. Removes any 
             * necessary objects from the control.
             * 
             * @param {plat.IAttributeControl} control The {@link plat.controls.AttributeControl|AttributeControl} to dispose.
             * 
             * @returns {void}
             */
            dispose(control: IAttributeControl): void;

            /**
             * @name getInstance
             * @memberof plat.controls.IAttributeControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of {@link plat.controls.AttributeControl|AttributeControl}.
             * 
             * @returns {plat.IAttributeControl}
             */
            getInstance(): IAttributeControl;
        }

        /**
         * @name IAttributeControl
         * @memberof plat.controls
         * @kind interface
         * @access public
         * 
         * @extends {plat.IControl}
         * 
         * @description
         * An object describing a type of control that can be used as an attribute but will 
         * not be used to add, remove, or modify DOM.
         */
        export interface IAttributeControl extends IControl {
            /**
             * @name templateControl
             * @memberof plat.controls.IAttributeControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * Specifies the {@link plat.ui.ITemplateControl|ITemplateControl} associated with this
             * control's element. Can be null if no {@link plat.ui.ITemplateControl|ITemplateControl}
             * exists.
             */
            templateControl?: ui.ITemplateControl;
        }

        /**
         * @name Name
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.AttributeControl}
         * 
         * @description
         * Allows for assigning a name to an Element or {@link plat.ui.TemplateControl|TemplateControl} and referencing it 
         * from parent controls.
         * 
         * @remarks
         * This control is useful for avoiding query selectors since it will store itself on all of its ancestor controls using 
         * the associated name.
         */
        export class Name extends AttributeControl {
            /**
             * @name _label
             * @memberof plat.controls.Name
             * @kind property
             * @access protected
             * @static
             * 
             * @type {string}
             * 
             * @description
             * The property name on the ancestor controls to set as the {@link plat.controls.INamedElement|INamedElement}.
             */
            _label: string;

            /**
             * @name initialize
             * @memberof plat.controls.Name
             * @kind function
             * @access public
             * 
             * @description
             * Defines the property specified by the attribute value as the {@link plat.controls.INamedElement|INamedElement} 
             * on all the ancestor controls, ignoring those that already have the property defined.
             * 
             * @returns {void}
             */
            initialize(): void {
                var attr = camelCase(this.type),
                    name = (<any>this.attributes)[attr];

                if (isEmpty(name) || this._isPrecompiled()) {
                    return;
                }

                this._label = name;
                this._define(name);
            }

            /**
             * @name dispose
             * @memberof plat.controls.Name
             * @kind function
             * @access public
             * 
             * @description
             * Removes the {@link plat.controls.INamedElement|INamedElement} from the ancestor controls.
             * 
             * @returns {void}
             */
            dispose(): void {
                var name = this._label,
                    control: any = this.parent;

                while (!isUndefined(name) && isObject(control)) {
                    if (isObject(control[name]) &&
                        isNode(control[name].element) &&
                        control[name].element === this.element) {
                        deleteProperty(control, name);
                    }

                    control = control.parent;
                }
            }

            /**
             * @name _define
             * @memberof plat.controls.Name
             * @kind function
             * @access protected
             * 
             * @description
             * Defines the property specified by the attribute value as the {@link plat.controls.INamedElement|INamedElement} 
             * on all the ancestor controls, ignoring those that already have the property defined.
             * 
             * @param {string} name The name to define on all the ancestor controls.
             * 
             * @returns {void}
             */
            _define(name: string): void {
                var templateControl = this.templateControl;

                if (!isNull(templateControl)) {
                    templateControl.name = name;
                }

                var control: any = this.parent,
                    namedElement = {
                        element: this.element,
                        control: templateControl
                    };

                while (isObject(control)) {
                    var obj = control[name];

                    if (!isObject(obj)) {
                        control[name] = namedElement;
                    }

                    control = control.parent;
                }
            }

            /**
             * @name _isPrecompiled
             * @memberof plat.controls.Name
             * @kind function
             * @access protected
             * 
             * @description
             * Determines whether or not this control is part of a pre-compiled control tree. In the event 
             * that it is, it shouldn't set itself on the ancestor controls.
             * 
             * @param {string} name The name to define on all the ancestor controls.
             * 
             * @returns {void}
             */
            _isPrecompiled(): boolean {
                var control = this.parent;

                while (!isNull(control)) {
                    if (control.type.indexOf(__COMPILED) !== -1) {
                        return true;
                    }
                    control = control.parent;
                }
                return false;
            }
        }

        register.control(__Name, Name);

        /**
         * @name INamedElement
         * @memberof plat.controls
         * @kind interface
         * 
         * @description
         * Defines the object added to a root control when an HTML element has 
         * a plat-name attribute. If the element corresponds to a registered 
         * control, the control will be included in the object.
         * 
         * @typeparam {Element} E The type of element that is named.
         * @typeparam {any} C The type of control that is named.
         */
        export interface INamedElement<E extends Element, C> {
            /**
             * @name element
             * @memberof plat.controls.INamedElement
             * @kind property
             * 
             * @type {E}
             * 
             * @description
             * The element on which the plat-name is specified.
             */
            element: E;

            /**
             * @name control
             * @memberof plat.controls.INamedElement
             * @kind property
             * 
             * @type {C}
             * 
             * @description
             * The template control on the associated element, if one 
             * exists.
             */
            control?: C;
        }

        /**
         * @name SimpleEventControl
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.AttributeControl}
         * @implements {plat.controls.ISimpleEventControl}
         * 
         * @description
         * An {@link plat.controls.AttributeControl|AttributeControl} that binds to a specified DOM event handler.
         */
        export class SimpleEventControl extends AttributeControl implements ISimpleEventControl {
            /**
             * @name $Parser
             * @memberof plat.controls.SimpleEventControl
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.IParser}
             * 
             * @description
             * Reference to the {@link plat.expressions.IParser|IParser} injectable.
             */
            $Parser: expressions.IParser = acquire(__Parser);

            /**
             * @name $Regex
             * @memberof plat.controls.SimpleEventControl
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.IRegex}
             * 
             * @description
             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.
             */
            $Regex: expressions.IRegex = acquire(__Regex);

            /**
             * @name event
             * @memberof plat.controls.SimpleEventControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string;

            /**
             * @name attribute
             * @memberof plat.controls.SimpleEventControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The camel-cased name of the control as it appears as an attribute.
             */
            attribute: string;

            /**
             * @name _expression
             * @memberof plat.controls.SimpleEventControl
             * @kind property
             * @access protected
             * 
             * @type {Array<string>}
             * 
             * @description
             * A parsed form of the expression found in the attribute's value.
             */
            _expression: Array<string> = [];

            /**
             * @name _aliases
             * @memberof plat.controls.SimpleEventControl
             * @kind property
             * @access protected
             * 
             * @type {Array<string>}
             * 
             * @description
             * An array of the aliases used in the expression.
             */
            _aliases: Array<string> = [];

            /**
             * @name loaded
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access public
             * 
             * @description
             * Kicks off finding and setting the listener.
             * 
             * @returns {void}
             */
            loaded(): void {
                if (isNull(this.element)) {
                    return;
                }

                this.attribute = camelCase(this.type);
                this._setListener();
            }

            /**
             * @name _setListener
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Sets the event listener.
             * 
             * @returns {void}
             */
            _setListener(): void {
                var attr = this.attribute;
                if (isEmpty(this.event) || isEmpty(attr)) {
                    return;
                }

                this._parseArgs((<any>this.attributes)[attr]);

                if (isNull(this._expression)) {
                    return;
                }

                this.addEventListener(this.element, this.event, this._onEvent, false);
            }

            /**
             * @name _findListener
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Finds the first instance of the specified function 
             * in the parent control chain.
             * 
             * @param {string} identifier the function identifer
             * 
             * @returns {{ control: ui.ITemplateControl; value: any; }} The instance of the specified function.
             */
            _findListener(identifier: string): { control: ui.ITemplateControl; value: any; } {
                var control: ui.ITemplateControl = <any>this,
                    expression = this.$Parser.parse(identifier),
                    value: any;

                while (!isNull(control)) {
                    value = expression.evaluate(control);
                    if (!isNull(value)) {
                        return {
                            control: control,
                            value: value
                        };
                    }
                    control = control.parent;
                }

                return {
                    control: null,
                    value: null
                };
            }

            /**
             * @name _buildExpression
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Constructs the function to evaluate with 
             * the evaluated arguments taking resources 
             * into account.
             * 
             * @returns {{ fn: () => void; control: ui.ITemplateControl; args: Array<expressions.IParsedExpression>; }} 
             * The function to call and the associated arguments, as well as the control context with which to call the function.
             */
            _buildExpression(): { fn: () => void; control: ui.ITemplateControl; args: Array<expressions.IParsedExpression>; } {
                var expression = this._expression.slice(0),
                    hasParent = !isNull(this.parent),
                    aliases = hasParent ? this.parent.getResources(this._aliases) : null,
                    listenerStr = expression.shift(),
                    listener: { control: ui.ITemplateControl; value: any; },
                    control: ui.ITemplateControl,
                    fn: () => void;

                if (listenerStr[0] !== '@') {
                    listener = this._findListener(listenerStr);

                    if (isNull(listener)) {
                        return {
                            fn: noop,
                            control: <ui.ITemplateControl>{},
                            args: []
                        };
                    }

                    fn = listener.value;
                    control = listener.control;
                } else {
                    fn = aliases[listenerStr];
                    control = null;
                }

                var length = expression.length,
                    args: Array<expressions.IParsedExpression> = [],
                    $parser = this.$Parser;

                for (var i = 0; i < length; ++i) {
                    args.push($parser.parse(expression[i]).evaluate(hasParent ? this.parent.context : null, aliases));
                }

                return {
                    fn: fn,
                    control: control,
                    args: args
                };
            }

            /**
             * @name _onEvent
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Calls the specified function when the DOM event is fired.
             * 
             * @param {Event} ev The event object.
             * 
             * @returns {void}
             */
            _onEvent(ev: Event): void {
                var expression = this._buildExpression(),
                    fn = expression.fn,
                    control = expression.control,
                    args = expression.args;

                if (!isFunction(fn)) {
                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                    $exception.warn('Cannot find registered event method ' +
                        this._expression[0] + ' for control: ' + this.type, $exception.BIND);
                    return;
                }

                fn.apply(control, args.concat(<any>ev));
            }

            /**
             * @name _findAliases
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Finds all alias contained within the expression.
             * 
             * @param {Array<string>} args The array of arguments as strings.
             * 
             * @returns {Array<string>} The aliases.
             */
            _findAliases(args: Array<string>): Array<string> {
                var length = args.length,
                    arg: string,
                    exec: RegExpExecArray,
                    aliases: IObject<boolean> = {},
                    $regex = this.$Regex;

                for (var i = 0; i < length; ++i) {
                    arg = args[i].trim();

                    if (arg[0] === '@') {
                        exec = $regex.aliasRegex.exec(arg);
                        aliases[!isNull(exec) ? exec[0] : arg.slice(1)] = true;
                    }
                }

                return Object.keys(aliases);
            }

            /**
             * @name _parseArgs
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Parses the expression and separates the function 
             * from its arguments.
             * 
             * @param {string} expression The expression to parse.
             * 
             * @returns {void}
             */
            _parseArgs(expression: string): void {
                var exec = this.$Regex.argumentRegex.exec(expression),
                    haveArgs = !isNull(exec);

                if (isEmpty(expression)) {
                    return;
                }

                if (haveArgs) {
                    this._expression = [expression.slice(0, exec.index)]
                        .concat((exec[1] !== '') ? exec[1].split(',') : []);
                } else {
                    this._expression.push(expression);
                }

                this._aliases = this._findAliases(this._expression);
            }
        }

        /**
         * @name ISimpleEventControl
         * @memberof plat.controls
         * @kind interface
         * 
         * @extends {plat.controls.IAttributeControl}
         * 
         * @description
         * An {@link plat.controls.IAttributeControl|IAttributeControl} that binds to a specified DOM event handler.
         */
        export interface ISimpleEventControl extends IAttributeControl {
            /**
             * @name event
             * @memberof plat.controls.ISimpleEventControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string;

            /**
             * @name attribute
             * @memberof plat.controls.ISimpleEventControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The camel-cased name of the control as it appears as an attribute.
             */
            attribute: string;
        }

        /**
         * @name Tap
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$tap' event.
         */
        export class Tap extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Tap
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$tap;
        }

        /**
         * @name Blur
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'blur' event.
         */
        export class Blur extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Blur
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'blur';
        }

        /**
         * @name Change
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'change' event.
         */
        export class Change extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Change
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'change';
        }

        /**
         * @name Copy
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'copy' event.
         */
        export class Copy extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Copy
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'copy';
        }

        /**
         * @name Cut
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'cut' event.
         */
        export class Cut extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Cut
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'cut';
        }

        /**
         * @name Paste
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'paste' event.
         */
        export class Paste extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Paste
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'paste';
        }

        /**
         * @name DblTap
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$dbltap' event.
         */
        export class DblTap extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.DblTap
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$dbltap;
        }

        /**
         * @name Focus
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'focus' event.
         */
        export class Focus extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Focus
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'focus';
        }

        /**
         * @name TouchStart
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchstart' event.
         */
        export class TouchStart extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TouchStart
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$touchstart;
        }

        /**
         * @name TouchEnd
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchend' event.
         */
        export class TouchEnd extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TouchEnd
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$touchend;
        }

        /**
         * @name TouchMove
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchmove' event.
         */
        export class TouchMove extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TouchMove
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$touchmove;
        }

        /**
         * @name TouchCancel
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchcancel' event.
         */
        export class TouchCancel extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TouchCancel
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$touchcancel;
        }

        /**
         * @name Hold
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$hold' event.
         */
        export class Hold extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Hold
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$hold;
        }

        /**
         * @name Release
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$release' event.
         */
        export class Release extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Release
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$release;
        }

        /**
         * @name Swipe
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipe' event.
         */
        export class Swipe extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Swipe
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$swipe;
        }

        /**
         * @name SwipeLeft
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipeleft' event.
         */
        export class SwipeLeft extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.SwipeLeft
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$swipeleft;
        }

        /**
         * @name SwipeRight
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swiperight' event.
         */
        export class SwipeRight extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.SwipeRight
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$swiperight;
        }

        /**
         * @name SwipeUp
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipeup' event.
         */
        export class SwipeUp extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.SwipeUp
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$swipeup;
        }

        /**
         * @name SwipeDown
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipedown' event.
         */
        export class SwipeDown extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.SwipeDown
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$swipedown;
        }

        /**
         * @name Track
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$track' event.
         */
        export class Track extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Track
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$track;
        }

        /**
         * @name TrackLeft
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackleft' event.
         */
        export class TrackLeft extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TrackLeft
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$trackleft;
        }

        /**
         * @name TrackRight
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackright' event.
         */
        export class TrackRight extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TrackRight
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$trackright;
        }

        /**
         * @name TrackUp
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackup' event.
         */
        export class TrackUp extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TrackUp
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$trackup;
        }

        /**
         * @name TrackDown
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackdown' event.
         */
        export class TrackDown extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TrackDown
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$trackdown;
        }

        /**
         * @name TrackEnd
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackend' event.
         */
        export class TrackEnd extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.TrackEnd
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = __$trackend;
        }

        /**
         * @name Submit
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * 
         * @description
         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'submit' event.
         */
        export class Submit extends SimpleEventControl {
            /**
             * @name event
             * @memberof plat.controls.Submit
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'submit';

            /**
             * @name _onEvent
             * @memberof plat.controls.SimpleEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Prevents the default submit action unless 
             * the "action" attribute is present.
             * 
             * @param {Event} ev The event object.
             */
            _onEvent(ev: Event): void {
                if (!this.element.hasAttribute('action')) {
                    ev.preventDefault();
                }

                super._onEvent(ev);
            }
        }

        register.control(__Tap, Tap);
        register.control(__Blur, Blur);
        register.control(__Change, Change);
        register.control(__Copy, Copy);
        register.control(__Cut, Cut);
        register.control(__Paste, Paste);
        register.control(__DblTap, DblTap);
        register.control(__Focus, Focus);
        register.control(__Submit, Submit);
        register.control(__TouchStart, TouchStart);
        register.control(__TouchEnd, TouchEnd);
        register.control(__TouchMove, TouchMove);
        register.control(__TouchCancel, TouchCancel);
        register.control(__Hold, Hold);
        register.control(__Release, Release);
        register.control(__Swipe, Swipe);
        register.control(__SwipeLeft, SwipeLeft);
        register.control(__SwipeRight, SwipeRight);
        register.control(__SwipeUp, SwipeUp);
        register.control(__SwipeDown, SwipeDown);
        register.control(__Track, Track);
        register.control(__TrackLeft, TrackLeft);
        register.control(__TrackRight, TrackRight);
        register.control(__TrackUp, TrackUp);
        register.control(__TrackDown, TrackDown);
        register.control(__TrackEnd, TrackEnd);

        /**
         * @name KeyCodes
         * @memberof plat.controls
         * @kind property
         * @access public
         * 
         * @type {any}
         * 
         * @description
         * A mapping of all keys to their equivalent keyCode.
         */
        export var KeyCodes = {
            'backspace': 8,
            'tab': 9,
            'enter': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'pause': 19, 'break': 19,
            'caps lock': 20,
            'escape': 27,
            'space': 32,
            'page up': 33,
            'page down': 34,
            'end': 35,
            'home': 36,
            'left': 37, 'left arrow': 37,
            'up': 38, 'up arrow': 38,
            'right': 39, 'right arrow': 39,
            'down': 40, 'down arrow': 40,
            'insert': 45,
            'delete': 46,
            '0': 48, 'zero': 48,
            ')': 48, 'right parenthesis': 48,
            '1': 49, 'one': 49,
            '!': 49, 'exclamation': 49, 'exclamation point': 49,
            '2': 50, 'two': 50,
            '@': 50, 'at': 50,
            '3': 51, 'three': 51,
            '#': 51, 'number sign': 51,
            'hash': 51, 'pound': 51,
            '4': 52, 'four': 52,
            '$': 52, 'dollar': 52, 'dollar sign': 52,
            '5': 53, 'five': 53,
            '%': 53, 'percent': 53, 'percent sign': 53,
            '6': 54, 'six': 54,
            '^': 54, 'caret': 54,
            '7': 55, 'seven': 55,
            '&': 55, 'ampersand': 55,
            '8': 56, 'eight': 56,
            '*': 56, 'asterisk': 56,
            '9': 57, 'nine': 57,
            '(': 57, 'left parenthesis': 57,
            'a': 65, 'b': 66, 'c': 67, 'd': 68, 'e': 69,
            'f': 70, 'g': 71, 'h': 72, 'i': 73, 'j': 74,
            'k': 75, 'l': 76, 'm': 77, 'n': 78, 'o': 79,
            'p': 80, 'q': 81, 'r': 82, 's': 83, 't': 84,
            'u': 85, 'v': 86, 'w': 87, 'x': 88, 'y': 89,
            'z': 90,
            'lwk': 91, 'left window key': 91,
            'rwk': 92, 'right window key': 92,
            'select': 93, 'select key': 93,
            'numpad 0': 96,
            'numpad 1': 97,
            'numpad 2': 98,
            'numpad 3': 99,
            'numpad 4': 100,
            'numpad 5': 101,
            'numpad 6': 102,
            'numpad 7': 103,
            'numpad 8': 104,
            'numpad 9': 105,
            'multiply': 106,
            'add': 107,
            'subtract': 109,
            'decimal point': 110,
            'divide': 111,
            'f1': 112, 'f2': 113, 'f3': 114, 'f4': 115,
            'f5': 116, 'f6': 117, 'f7': 118, 'f8': 119,
            'f9': 120, 'f10': 121, 'f11': 122, 'f12': 123,
            'num lock': 144,
            'scroll lock': 145,
            ';': 186, 'semi-colon': 186,
            ':': 186, 'colon': 186,
            '=': 187, 'equal': 187, 'equal sign': 187,
            '+': 187, 'plus': 187,
            ',': 188, 'comma': 188,
            '<': 188, 'lt': 188, 'less than': 188,
            'left angle bracket': 188,
            '-': 189, 'dash': 189,
            '_': 189, 'underscore': 189,
            '.': 190, 'period': 190,
            '>': 190, 'gt': 190, 'greater than': 190,
            'right angle bracket': 190,
            '/': 191, 'forward slash': 191,
            '?': 191, 'question mark': 191,
            '`': 192, 'grave accent': 192,
            '~': 192, 'tilde': 192,
            '[': 219, 'open bracket': 219,
            '{': 219, 'open brace': 219,
            '\\': 220, 'back slash': 220,
            '|': 220, 'pipe': 220,
            ']': 221, 'close bracket': 221,
            '}': 221, 'close brace': 221,
            '\'': 222, 'single quote': 222,
            '"': 222, 'double quote': 222
        };

        /**
         * @name KeyCodeEventControl
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SimpleEventControl}
         * @implements {plat.controls.IKeyCodeEventControl}
         * 
         * @description
         * Base class used for filtering keys on KeyboardEvents.
         */
        export class KeyCodeEventControl extends SimpleEventControl implements IKeyCodeEventControl {
            /**
             * @name $Regex
             * @memberof plat.controls.KeyCodeEventControl
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.IRegex}
             * 
             * @description
             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.
             */
            $Regex: plat.expressions.IRegex = plat.acquire(__Regex);

            /**
             * @name keyCodes
             * @memberof plat.controls.KeyCodeEventControl
             * @kind property
             * @access public
             * 
             * @type {plat.IObject<{ shifted: boolean; }>}
             * 
             * @description
             * Holds the key mappings to filter for in a KeyboardEvent.
             */
            keyCodes: IObject<{ shifted: boolean; }>;

            /**
             * @name _setListener
             * @memberof plat.controls.KeyCodeEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Checks if the {@link plat.controls.IKeyboardEventInput|IKeyboardEventInput} is an expression object 
             * and sets the necessary listener.
             * 
             * @returns {void}
             */
            _setListener(): void {
                var attr = this.attribute;
                if (isEmpty(this.event) || isEmpty(attr)) {
                    return;
                }

                var expression = (<any>this.attributes)[attr].trim();

                if (expression[0] === '{') {
                    var eventObject: IKeyboardEventInput = this.evaluateExpression(expression) ||
                        { method: '', key: null },
                        key = eventObject.key,
                        keys = eventObject.keys;

                    this._parseArgs(eventObject.method);

                    if (isNull(key) && isNull(keys)) {
                        (<any>this.attributes)[attr] = eventObject.method;

                        this._setKeyCodes();
                        super._setListener();
                        return;
                    }

                    keys = isArray(keys) ? keys : [key];
                    this._setKeyCodes(keys);
                    this.addEventListener(this.element, this.event, this._onEvent, false);

                    return;
                }

                this._setKeyCodes();
                super._setListener();
            }

            /**
             * @name _onEvent
             * @memberof plat.controls.KeyCodeEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Matches the event's keyCode if necessary and then handles the event if 
             * a match is found or if there are no filter keyCodes.
             * 
             * @param {KeyboardEvent} ev The keyboard event object.
             * 
             * @returns {void}
             */
            _onEvent(ev: KeyboardEvent): void {
                var keyCodes = this.keyCodes,
                    code: { shifted?: boolean };

                if (isEmpty(keyCodes)) {
                    super._onEvent(ev);
                } else if (!isUndefined(keyCodes[ev.keyCode])) {
                    code = keyCodes[ev.keyCode];

                    if (!code.shifted || ev.shiftKey) {
                        super._onEvent(ev);
                    }
                }
            }

            /**
             * @name _setKeyCodes
             * @memberof plat.controls.KeyCodeEventControl
             * @kind function
             * @access protected
             * 
             * @description
             * Sets the defined key codes as they correspond to 
             * the {@link plat.controls.KeyCodes|KeyCodes} map.
             * 
             * @param {Array<string>} keys? The array of defined keys to satisfy the 
             * key press condition.
             * 
             * @returns {void}
             */
            _setKeyCodes(keys?: Array<string>): void {
                if (!isArray(keys)) {
                    keys = [];
                }

                var length = keys.length,
                    key: string,
                    keyCodes = this.keyCodes,
                    index: string,
                    shifted = this.$Regex.shiftedKeyRegex;

                if (!isObject(keyCodes)) {
                    keyCodes = this.keyCodes = {};
                }

                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    index = isNumber(key) ? key : (<any>KeyCodes)[key.toLowerCase()];

                    keyCodes[index] = { shifted: shifted.test(key) };
                }
            }
        }

        /**
         * @name IKeyCodeEventControl
         * @memberof plat.controls
         * @kind interface
         * 
         * @extends {plat.controls.ISimpleEventControl}
         * 
         * @description
         * An attribute object that binds to specified key code scenarios.
         */
        export interface IKeyCodeEventControl extends ISimpleEventControl {
            /**
             * @name keyCodes
             * @memberof plat.controls.IKeyCodeEventControl
             * @kind property
             * @access public
             * 
             * @type {plat.IObject<{ shifted: boolean; }>}
             * 
             * @description
             * Holds the key mappings to filter for in a KeyboardEvent.
             */
            keyCodes: IObject<{ shifted: boolean; }>;
        }

        /**
         * @name IKeyboardEventInput
         * @memberof plat.controls
         * @kind interface
         * 
         * @description
         * The available options for {@link plat.controls.KeyCodeEventControl|KeyCodeEventControl}.
         */
        export interface IKeyboardEventInput {
            /**
             * @name method
             * @memberof plat.controls.IKeyboardEventInput
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The method to call when the condition is satisfied.
             */
            method: string;

            /**
             * @name key
             * @memberof plat.controls.IKeyboardEventInput
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The key to satisfy the press condition. Can be specified either as a numeric key code 
             * or a string representation as seen by the KeyCodes mapping.
             */
            key?: string;

            /**
             * @name keys
             * @memberof plat.controls.IKeyboardEventInput
             * @kind property
             * @access public
             * 
             * @type {Array<string>}
             * 
             * @description
             * An optional array of keys if more than one key can satisfy the condition.
             */
            keys?: Array<string>;
        }

        /**
         * @name KeyDown
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.KeyCodeEventControl}
         * 
         * @description
         * Used for filtering keys on keydown events.
         */
        export class KeyDown extends KeyCodeEventControl {
            /**
             * @name event
             * @memberof plat.controls.KeyDown
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'keydown';
        }

        /**
         * @name KeyPress
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.KeyCodeEventControl}
         * 
         * @description
         * Used for filtering only printing keys (a-z, A-Z, 0-9, and special characters) on keydown events.
         */
        export class KeyPress extends KeyCodeEventControl {
            /**
             * @name event
             * @memberof plat.controls.KeyPress
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'keydown';

            /**
             * @name _onEvent
             * @memberof plat.controls.KeyPress
             * @kind function
             * @access protected
             * 
             * @description
             * Filters only 'printing keys' (a-z, A-Z, 0-9, and special characters)
             * 
             * @param {KeyboardEvent} ev The KeyboardEvent object.
             * 
             * @returns {void}
             */
            _onEvent(ev: KeyboardEvent): void {
                var keyCode = ev.keyCode;

                if ((keyCode >= 48 && keyCode <= 90) ||
                    (keyCode >= 186) ||
                    (keyCode >= 96 && keyCode <= 111)) {
                    super._onEvent(ev);
                }
            }
        }

        /**
         * @name KeyUp
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.KeyCodeEventControl}
         * 
         * @description
         * Used for filtering keys on keyup events.
         */
        export class KeyUp extends KeyCodeEventControl {
            /**
             * @name event
             * @memberof plat.controls.KeyDown
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event name.
             */
            event: string = 'keyup';
        }

        register.control(__KeyDown, KeyDown);
        register.control(__KeyPress, KeyPress);
        register.control(__KeyUp, KeyUp);

        /**
         * @name SetAttributeControl
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.AttributeControl}
         * @implements {plat.controls.ISetAttributeControl}
         * 
         * @description
         * An {@link plat.controls.AttributeControl|AttributeControl} that deals with binding to a specified property on its element.
         */
        export class SetAttributeControl extends AttributeControl implements ISetAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.SetAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = '';

            /**
             * @name attribute
             * @memberof plat.controls.SetAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The camel-cased name of the control as it appears as an attribute.
             */
            attribute: string;

            /**
             * @name __removeListener
             * @memberof plat.controls.SetAttributeControl
             * @kind property
             * @access private
             * 
             * @type {IRemoveListener}
             * 
             * @description
             * The function to stop listening for attribute changes.
             */
            private __removeListener: IRemoveListener;

            /**
             * @name loaded
             * @memberof plat.controls.SetAttributeControl
             * @kind function
             * @access public
             * 
             * @description
             * Sets the corresponding attribute {property} value and 
             * observes the attribute for changes.
             * 
             * @returns {void}
             */
            loaded(): void {
                if (isNull(this.element)) {
                    return;
                }

                this.attribute = camelCase(this.type);
                this.setter();
                this.__removeListener = this.attributes.observe(this.attribute, this.setter);
            }

            /**
             * @name contextChanged
             * @memberof plat.controls.SetAttributeControl
             * @kind function
             * @access public
             * 
             * @description
             * Resets the corresponding attribute property value upon 
             * a change of context.
             * 
             * @returns {void}
             */
            contextChanged(): void {
                if (isNull(this.element)) {
                    return;
                }

                this.setter();
            }

            /**
             * @name dispose
             * @memberof plat.controls.SetAttributeControl
             * @kind function
             * @access public
             * 
             * @description
             * Stops listening to attribute changes.
             * 
             * @returns {void}
             */
            dispose(): void {
                if (isFunction(this.__removeListener)) {
                    this.__removeListener();
                    this.__removeListener = null;
                }
            }

            /**
             * @name setter
             * @memberof plat.controls.SetAttributeControl
             * @kind function
             * @access public
             * @virtual
             * 
             * @description
             * The function for setting the corresponding 
             * attribute property value.
             * 
             * @returns {void}
             */
            setter(): void {
                var expression = (<any>this.attributes)[this.attribute];

                postpone(() => {
                    if (!isNode(this.element)) {
                        return;
                    }

                    switch (expression) {
                        case 'false':
                        case '0':
                        case 'null':
                        case '':
                            this.element.setAttribute(this.property, '');
                            (<any>this.element)[this.property] = false;
                            this.element.removeAttribute(this.property);
                            break;
                        default:
                            this.element.setAttribute(this.property, this.property);
                            (<any>this.element)[this.property] = true;
                    }
                });
            }
        }

        /**
         * @name ISetAttributeControl
         * @memberof plat.controls
         * @kind interface
         * 
         * @extends {plat.controls.IAttributeControl}
         * 
         * @description
         * An {@link plat.controls.IAttributeControl|IAttributeControl} that deals with binding to a specified property on its element.
         */
        export interface ISetAttributeControl extends IAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.ISetAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string;

            /**
             * @name attribute
             * @memberof plat.controls.ISetAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The camel-cased name of the control as it appears as an attribute.
             */
            attribute: string;

            /**
             * @name setter
             * @memberof plat.controls.ISetAttributeControl
             * @kind function
             * @access public
             * 
             * @description
             * The function for setting the corresponding 
             * attribute property value.
             * 
             * @returns {void}
             */
            setter(): void;
        }

        /**
         * @name Checked
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SetAttributeControl}
         * 
         * @description
         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'checked' attribute.
         */
        export class Checked extends SetAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.Checked
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = 'checked';
        }

        /**
         * @name Disabled
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SetAttributeControl}
         * 
         * @description
         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'disabled' attribute.
         */
        export class Disabled extends SetAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.Disabled
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = 'disabled';
        }

        /**
         * @name Selected
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SetAttributeControl}
         * 
         * @description
         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'selected' attribute.
         */
        export class Selected extends SetAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.Selected
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = 'selected';
        }

        /**
         * @name ReadOnly
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SetAttributeControl}
         * 
         * @description
         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'readonly' attribute.
         */
        export class ReadOnly extends SetAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.ReadOnly
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = 'readonly';
        }

        /**
         * @name Visible
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SetAttributeControl}
         * 
         * @description
         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'plat-hide' attribute.
         */
        export class Visible extends SetAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.Visible
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = __Hide;

            /**
             * @name initialize
             * @memberof plat.controls.Visible
             * @kind function
             * @access public
             * 
             * @description
             * Hides the element.
             * 
             * @returns {void}
             */
            initialize(): void {
                this.__hide();
            }

            /**
             * @name setter
             * @memberof plat.controls.Visible
             * @kind function
             * @access public
             * 
             * @description
             * Hides or shows the element depending upon the attribute value
             * 
             * @returns {void}
             */
            setter(): void {
                var expression = (<any>this.attributes)[this.attribute];

                postpone(() => {
                    if (!isNode(this.element)) {
                        return;
                    }

                    switch (expression) {
                        case 'false':
                        case '0':
                        case 'null':
                        case '':
                            this.__hide();
                            break;
                        default:
                            this.__show();
                    }
                });
            }

            /**
             * @name __hide
             * @memberof plat.controls.Visible
             * @kind function
             * @access private
             * 
             * @description
             * Hides the element.
             * 
             * @returns {void}
             */
            private __hide(): void {
                if (!this.element.hasAttribute(this.property)) {
                    this.element.setAttribute(this.property, '');
                }
            }

            /**
             * @name __show
             * @memberof plat.controls.Visible
             * @kind function
             * @access private
             * 
             * @description
             * Shows the element.
             * 
             * @returns {void}
             */
            private __show(): void {
                if (this.element.hasAttribute(this.property)) {
                    this.element.removeAttribute(this.property);
                }
            }
        }

        /**
         * @name Style
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SetAttributeControl}
         * 
         * @description
         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'style' attribute.
         */
        export class Style extends SetAttributeControl {
            /**
             * @name setter
             * @memberof plat.controls.Style
             * @kind function
             * @access public
             * 
             * @description
             * Sets the evaluated styles on the element.
             * 
             * @returns {void}
             */
            setter(): void {
                var expression: string = (<any>this.attributes)[this.attribute];

                if (isEmpty(expression)) {
                    return;
                }

                var attributes = expression.split(';'),
                    elementStyle = this.element.style,
                    length = attributes.length,
                    splitStyles: Array<string>,
                    styleType: string,
                    styleValue: string;

                for (var i = 0; i < length; ++i) {
                    splitStyles = attributes[i].split(':');
                    if (splitStyles.length === 2) {
                        styleType = camelCase(splitStyles[0].trim());
                        styleValue = splitStyles[1].trim();

                        if (!isUndefined((<any>elementStyle)[styleType])) {
                            (<any>elementStyle)[styleType] = styleValue;
                        }
                    }
                }
            }
        }

        register.control(__Checked, Checked);
        register.control(__Disabled, Disabled);
        register.control(__Selected, Selected);
        register.control(__ReadOnly, ReadOnly);
        register.control(__Visible, Visible);
        register.control(__Style, Style);

        /**
         * @name ElementPropertyControl
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.SetAttributeControl}
         * 
         * @description
         * Base class used for setting the property of an element (e.g. href for anchor elements).
         */
        export class ElementPropertyControl extends SetAttributeControl {
            /**
             * @name setter
             * @memberof plat.controls.ElementPropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * The function for setting the corresponding 
             * attribute property value to the evaluated expression.
             * 
             * @returns {void}
             */
            setter(): void {
                var element = this.element,
                    elementProperty = this.property,
                    expression = (<any>this.attributes)[this.attribute];

                if (isEmpty(expression) || isNull(element)) {
                    return;
                }

                if (!isUndefined((<any>element)[elementProperty])) {
                    (<any>element)[elementProperty] = expression;
                }
            }
        }

        /**
         * @name Href
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.ElementPropertyControl}
         * 
         * @description
         * A type of {@link plat.controls.ElementPropertyControl|ElementPropertyControl} used to set 'href' on an anchor tag.
         */
        export class Href extends ElementPropertyControl {
            /**
             * @name property
             * @memberof plat.controls.Href
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Used to set the element's href property.
             */
            property: string = 'href';
        }

        /**
         * @name Src
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.ElementPropertyControl}
         * 
         * @description
         * A type of {@link plat.controls.ElementPropertyControl|ElementPropertyControl} used to set 'src' on an anchor tag.
         */
        export class Src extends ElementPropertyControl {
            /**
             * @name property
             * @memberof plat.controls.Src
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * Used to set the element's src property.
             */
            property: string = 'src';
        }

        register.control(__Href, Href);
        register.control(__Src, Src);

        /**
         * @name Bind
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.AttributeControl}
         * 
         * @description
         * Facilitates two-way databinding for HTMLInputElements, HTMLSelectElements, and HTMLTextAreaElements.
         */
        export class Bind extends AttributeControl {
            /**
             * @name $Parser
             * @memberof plat.controls.Bind
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.expressions.IParser}
             * 
             * @description
             * Reference to the {@link plat.expressions.IParser|IParser} injectable.
             */
            $Parser: expressions.IParser = acquire(__Parser);

            /**
             * @name $ContextManagerStatic
             * @memberof plat.controls.Bind
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.observable.IContextManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
             */
            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);

            /**
             * @name $Compat
             * @memberof plat.controls.Bind
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ICompat}
             * 
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            $Compat: ICompat = acquire(__Compat);

            /**
             * @name $document
             * @memberof plat.controls.Bind
             * @kind property
             * @access public
             * @static
             * 
             * @type {Document}
             * 
             * @description
             * Reference to the Document injectable.
             */
            $document: Document = acquire(__Document);

            /**
             * @name priority
             * @memberof plat.controls.Bind
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The priority of Bind is set high to take precede 
             * other controls that may be listening to the same 
             * event.
             */
            priority: number = 100;

            /**
             * @name _addEventType
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * The function used to add the proper event based on the input type.
             * 
             * @returns {void}
             */
            _addEventType: () => void;

            /**
             * @name _getter
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * The function used to get the bound value.
             * 
             * @returns {any} The bound value.
             */
            _getter: () => any;

            /**
             * @name _setter
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * The function used to set the bound value.
             * 
             * @returns {void}
             */
            _setter: (newValue: any, oldValue?: any, firstTime?: boolean) => void;

            /**
             * @name _expression
             * @memberof plat.controls.Bind
             * @kind property
             * @access protected
             * 
             * @type {plat.expressions.IParsedExpression}
             * 
             * @description
             * The expression to evaluate as the bound value.
             */
            _expression: expressions.IParsedExpression;

            /**
             * @name _contextExpression
             * @memberof plat.controls.Bind
             * @kind property
             * @access protected
             * 
             * @type {plat.expressions.IParsedExpression}
             * 
             * @description
             * The IParsedExpression used to evaluate the context 
             * of the bound property.
             */
            _contextExpression: expressions.IParsedExpression;

            /**
             * @name _property
             * @memberof plat.controls.Bind
             * @kind property
             * @access protected
             * 
             * @type {string}
             * 
             * @description
             * The bound property name.
             */
            _property: string;

            /**
             * @name __fileSupported
             * @memberof plat.controls.Bind
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the File API is supported.
             */
            private __fileSupported = (<ICompat>acquire(__Compat)).fileSupported;

            /**
             * @name __fileNameRegex
             * @memberof plat.controls.Bind
             * @kind property
             * @access private
             * 
             * @type {RegExp}
             * 
             * @description
             * Used to grab a filename from input[type="file"].
             */
            private __fileNameRegex = (<expressions.IRegex>acquire(__Regex)).fileNameRegex;

            /**
             * @name __isSelf
             * @memberof plat.controls.Bind
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Used to denote that a property change happened from within this control.
             */
            private __isSelf = false;

            /**
             * @name initialize
             * @memberof plat.controls.Bind
             * @kind function
             * @access public
             * 
             * @description
             * Determines the type of Element being bound to 
             * and sets the necessary handlers.
             * 
             * @returns {void}
             */
            initialize(): void {
                this._determineType();
            }

            /**
             * @name loaded
             * @memberof plat.controls.Bind
             * @kind function
             * @access public
             * 
             * @description
             * Parses and watches the expression being bound to.
             * 
             * @returns {void}
             */
            loaded(): void {
                if (isNull(this.parent) || isNull(this.element)) {
                    return;
                }

                var attr = camelCase(this.type),
                    expression = this._expression = this.$Parser.parse((<any>this.attributes)[attr]);

                var identifiers = expression.identifiers;

                if (identifiers.length !== 1) {
                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                    $exception.warn('Only 1 identifier allowed in a plat-bind expression', $exception.BIND);
                    this._contextExpression = null;
                    return;
                }

                var split = identifiers[0].split('.');

                this._property = split.pop();

                if (split.length > 0) {
                    this._contextExpression = this.$Parser.parse(split.join('.'));
                } else if (expression.aliases.length > 0) {
                    var alias = expression.aliases[0],
                        resourceObj = this.parent.findResource(alias);

                    if (isNull(resourceObj) || resourceObj.resource.type !== 'observable') {
                        return;
                    }

                    this._property = 'value';

                    this._contextExpression = {
                        evaluate: () => {
                            return resourceObj.resource;
                        },
                        aliases: [],
                        identifiers: [],
                        expression: ''
                    };
                } else {
                    this._contextExpression = {
                        evaluate: () => {
                            return this.parent.context;
                        },
                        aliases: [],
                        identifiers: [],
                        expression: ''
                    };
                }

                this._watchExpression();

                if (isNull(this._addEventType)) {
                    return;
                }

                this._addEventType();
            }

            /**
             * @name contextChanged
             * @memberof plat.controls.Bind
             * @kind function
             * @access public
             * 
             * @description
             * Re-observes the expression with the new context.
             * 
             * @returns {void}
             */
            contextChanged(): void {
                this._watchExpression();
            }

            /**
             * @name dispose
             * @memberof plat.controls.Bind
             * @kind function
             * @access public
             * 
             * @description
             * Removes all of the element's event listeners.
             * 
             * @returns {void}
             */
            dispose(): void {
                this._addEventType = null;
            }

            /**
             * @name _addTextEventListener
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Adds a text event as the event listener. 
             * Used for textarea and input[type=text].
             * 
             * @returns {void}
             */
            _addTextEventListener(): void {
                var element = this.element,
                    $compat = this.$Compat,
                    composing = false,
                    timeout: IRemoveListener,
                    eventListener = () => {
                        if (composing) {
                            return;
                        }

                        this._propertyChanged();
                    },
                    postponedEventListener = () => {
                        if (isFunction(timeout)) {
                            return;
                        }

                        timeout = postpone(() => {
                            eventListener();
                            timeout = null;
                        });
                    };

                if (isUndefined($compat.ANDROID)) {
                    this.addEventListener(element, 'compositionstart', () => (composing = true), false);
                    this.addEventListener(element, 'compositionend', () => {
                        composing = false;
                        eventListener();
                    }, false);
                }

                if ($compat.hasEvent('input')) {
                    this.addEventListener(element, 'input', eventListener, false);
                } else {
                    this.addEventListener(element, 'keydown', (ev: KeyboardEvent) => {
                        var key = ev.keyCode,
                            codes = KeyCodes;

                        if (key === codes.lwk ||
                            key === codes.rwk ||
                            (key >= codes.shift && key <= codes.escape) ||
                            (key > codes.space && key <= codes.down)) {
                            return;
                        }

                        postponedEventListener();
                    }, false);
                    this.addEventListener(element, 'cut', postponedEventListener, false);
                    this.addEventListener(element, 'paste', postponedEventListener, false);
                }

                this.addEventListener(element, 'change', eventListener, false);
            }

            /**
             * @name _addChangeEventListener
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Adds a change event as the event listener. 
             * Used for select, input[type=radio], and input[type=range].
             * 
             * @returns {void}
             */
            _addChangeEventListener(): void {
                this.addEventListener(this.element, 'change', this._propertyChanged, false);
            }

            /**
             * @name _addButtonEventListener
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Adds a $tap event as the event listener. 
             * Used for input[type=button] and button.
             * 
             * @returns {void}
             */
            _addButtonEventListener(): void {
                this.addEventListener(this.element, __$tap, this._propertyChanged, false);
            }

            /**
             * @name _getChecked
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Getter for input[type=checkbox] and input[type=radio]
             * 
             * @returns {boolean} Whether or not the input element is checked
             */
            _getChecked(): boolean {
                return (<HTMLInputElement>this.element).checked;
            }

            /**
             * @name _getValue
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Getter for input[type=text], input[type=range], 
             * textarea, and select.
             * 
             * @returns {string} The input value
             */
            _getValue(): string {
                return (<HTMLInputElement>this.element).value;
            }

            /**
             * @name _getTextContent
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Getter for button.
             * 
             * @returns {string} The button textContent
             */
            _getTextContent(): string {
                return (<HTMLInputElement>this.element).textContent;
            }

            /**
             * @name _getFile
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Getter for input[type="file"]. Creates a partial IFile 
             * element if file is not supported.
             * 
             * @returns {plat.controls.IFile} The input file
             */
            _getFile(): IFile {
                var element = <HTMLInputElement>this.element,
                    value = element.value;

                if (this.__fileSupported && element.files.length > 0) {
                    return <IFile>element.files[0];
                }

                return {
                    name: value.replace(this.__fileNameRegex, ''),
                    path: value,
                    lastModifiedDate: undefined,
                    type: undefined,
                    size: undefined,
                    msDetachStream: noop,
                    msClose: noop,
                    slice: () => <Blob>{ }
                };
            }

            /**
             * @name _getFiles
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Getter for input[type="file"]-multiple
             * 
             * @returns {Array<plat.controls.IFile>} The input files
             */
            _getFiles(): Array<IFile> {
                var element = <HTMLInputElement>this.element;

                if (this.__fileSupported) {
                    return Array.prototype.slice.call(element.files);
                }

                // this case should never be hit since ie9 does not support multi-file uploads, 
                // but kept in here for now for consistency's sake
                var filelist = element.value.split(/,|;/g),
                    length = filelist.length,
                    files: Array<IFile> = [],
                    fileValue: string;

                for (var i = 0; i < length; ++i) {
                    fileValue = filelist[i];
                    files.push({
                        name: fileValue.replace(this.__fileNameRegex, ''),
                        path: fileValue,
                        lastModifiedDate: undefined,
                        type: undefined,
                        size: undefined,
                        msDetachStream: noop,
                        msClose: noop,
                        slice: () => <Blob>{}
                    });
                }

                return files;
            }

            /**
             * @name _getSelectedValues
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Getter for select-multiple
             * 
             * @returns {Array<string>} The selected values
             */
            _getSelectedValues(): Array<string> {
                var options = (<HTMLSelectElement>this.element).options,
                    length = options.length,
                    option: HTMLOptionElement,
                    selectedValues: Array<string> = [];

                for (var i = 0; i < length; ++i) {
                    option = options[i];
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                }

                return selectedValues;
            }

            /**
             * @name _setText
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Setter for textarea, input[type=text], 
             * and input[type=button], and select
             * 
             * @param {any} newValue The new value to set
             * @param {any} oldValue? The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and 
             * should thus change the property if null
             * 
             * @returns {void}
             */
            _setText(newValue: any, oldValue?: any, firstTime?: boolean): void {
                if (this.__isSelf) {
                    return;
                }

                if (isNull(newValue)) {
                    newValue = '';

                    if (firstTime === true) {
                        if (isNull((<HTMLInputElement>this.element).value)) {
                            this.__setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }

                this.__setValue(newValue);
            }

            /**
             * @name _setRange
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Setter for input[type=range]
             * 
             * @param {any} newValue The new value to set
             * @param {any} oldValue? The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and 
             * should thus change the property if null
             * 
             * @returns {void}
             */
            _setRange(newValue: any, oldValue?: any, firstTime?: boolean): void {
                if (this.__isSelf) {
                    return;
                }

                if (isEmpty(newValue)) {
                    newValue = 0;

                    if (firstTime === true) {
                        if (isEmpty((<HTMLInputElement>this.element).value)) {
                            this.__setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }

                this.__setValue(newValue);
            }

            /**
             * @name _setChecked
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Setter for input[type=checkbox]
             * 
             * @param {any} newValue The new value to set
             * @param {any} oldValue? The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and 
             * should thus change the property if null
             * 
             * @returns {void}
             */
            _setChecked(newValue: any, oldValue?: any, firstTime?: boolean): void {
                if (this.__isSelf) {
                    return;
                } else if (!isBoolean(newValue)) {
                    if (firstTime === true) {
                        this._propertyChanged();
                        return;
                    }
                    newValue = !!newValue;
                }

                (<HTMLInputElement>this.element).checked = newValue;
            }

            /**
             * @name _setRadio
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Setter for input[type=radio]
             * 
             * @param {any} newValue The new value to set
             * 
             * @returns {void}
             */
            _setRadio(newValue: any): void {
                var element = (<HTMLInputElement>this.element);
                if (this.__isSelf) {
                    return;
                } else if (isNull(newValue) && element.checked) {
                    this._propertyChanged();
                    return;
                }

                element.checked = (element.value === newValue);
            }

            /**
             * @name _setSelectedIndex
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Setter for select
             * 
             * @param {any} newValue The new value to set
             * @param {any} oldValue? The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and 
             * should thus change the property if null
             * 
             * @returns {void}
             */
            _setSelectedIndex(newValue: any, oldValue?: any, firstTime?: boolean): void {
                if (this.__isSelf) {
                    return;
                } else if (firstTime === true && this.__checkAsynchronousSelect()) {
                    if (isNull(newValue)) {
                        this._propertyChanged();
                    }
                    return;
                }

                var element = <HTMLSelectElement>this.element,
                    value = element.value;
                if (isNull(newValue)) {
                    if (firstTime === true || !this.$document.body.contains(element)) {
                        this._propertyChanged();
                        return;
                    }
                    element.selectedIndex = -1;
                    return;
                } else if (!isString(newValue)) {
                    var Exception: IExceptionStatic = acquire(__ExceptionStatic),
                        message: string;
                    if (isNumber(newValue)) {
                        newValue = newValue.toString();
                        message = 'Trying to bind a value of type number to a select element. ' +
                            'The value will implicitly be converted to type string.';
                    } else {
                        message = 'Trying to bind a value that is not a string to a select element. ' +
                            'The element\'s selected index will be set to -1.';
                    }

                    Exception.warn(message, Exception.BIND);
                } else if (value === newValue) {
                    return;
                } else if (!this.$document.body.contains(element)) {
                    element.value = newValue;
                    if (element.value !== newValue) {
                        element.value = value;
                        this._propertyChanged();
                    }
                    return;
                }

                element.value = newValue;
                // check to make sure the user changed to a valid value
                // second boolean argument is an ie fix for inconsistency
                if (element.value !== newValue || element.selectedIndex === -1) {
                    element.selectedIndex = -1;
                }
            }

            /**
             * @name _setSelectedIndices
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Setter for select-multiple
             * 
             * @param {any} newValue The new value to set
             * @param {any} oldValue? The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and 
             * should thus change the property if null
             * 
             * @returns {void}
             */
            _setSelectedIndices(newValue: any, oldValue?: any, firstTime?: boolean): void {
                if (this.__isSelf) {
                    return;
                } else if (firstTime === true && this.__checkAsynchronousSelect()) {
                    return;
                }

                var options = (<HTMLSelectElement>this.element).options,
                    length = isNull(options) ? 0 : options.length,
                    option: HTMLOptionElement,
                    nullValue = isNull(newValue);

                if (nullValue || !isArray(newValue)) {
                    if (firstTime === true) {
                        this._propertyChanged();
                    }
                    // unselects the options unless a match is found
                    while (length-- > 0) {
                        option = options[length];
                        if (!nullValue && option.value === '' + newValue) {
                            option.selected = true;
                            return;
                        }

                        option.selected = false;
                    }
                    return;
                }

                var value: any,
                    numberValue: number;

                while (length-- > 0) {
                    option = options[length];
                    value = option.value;
                    numberValue = Number(value);

                    if (newValue.indexOf(value) !== -1 || (isNumber(numberValue) && newValue.indexOf(numberValue) !== -1)) {
                        option.selected = true;
                        continue;
                    }

                    option.selected = false;
                }
            }

            /**
             * @name _determineType
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Determines the type of Element being bound to 
             * and sets the necessary handlers.
             * 
             * @returns {void}
             */
            _determineType(): void {
                if (!isNull(this.templateControl) && this._observedBindableProperty()) {
                    return;
                }

                var element = this.element;
                if (isNull(element)) {
                    return;
                }

                switch (element.nodeName.toLowerCase()) {
                    case 'textarea':
                        this._addEventType = this._addTextEventListener;
                        this._getter = this._getValue;
                        this._setter = this._setText;
                        break;
                    case 'input':
                        switch ((<HTMLInputElement>element).type) {
                            case 'button':
                            case 'submit':
                            case 'reset':
                                this._addEventType = this._addButtonEventListener;
                                this._getter = this._getValue;
                                break;
                            case 'checkbox':
                                this._addEventType = this._addChangeEventListener;
                                this._getter = this._getChecked;
                                this._setter = this._setChecked;
                                break;
                            case 'radio':
                                this.__initializeRadio();
                                break;
                            case 'range':
                                this._addEventType = this._addChangeEventListener;
                                this._getter = this._getValue;
                                this._setter = this._setRange;
                                break;
                            case 'file':
                                var multi = (<HTMLInputElement>element).multiple;
                                this._addEventType = this._addChangeEventListener;
                                this._getter = multi ? this._getFiles : this._getFile;
                                break;
                            default:
                                this._addEventType = this._addTextEventListener;
                                this._getter = this._getValue;
                                this._setter = this._setText;
                                break;
                        }
                        break;
                    case 'select':
                        this.__initializeSelect();
                        break;
                    case 'button':
                        this._addEventType = this._addButtonEventListener;
                        this._getter = this._getTextContent;
                        break;
                }
            }

            /**
             * @name _watchExpression
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Observes the expression to bind to.
             * 
             * @returns {void}
             */
            _watchExpression(): void {
                var contextExpression = this._contextExpression,
                    context = this.evaluateExpression(contextExpression);

                if (!isObject(context)) {
                    if (isNull(context) && contextExpression.identifiers.length > 0) {
                        context = this.$ContextManagerStatic.createContext(this.parent,
                            contextExpression.identifiers[0]);
                    } else {
                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);
                        Exception.warn('plat-bind is trying to index into a primitive type. ' +
                            this._contextExpression.expression + ' is already defined and not ' +
                            'an object when trying to evaluate plat-bind="' +
                            this._expression.expression + '"', Exception.BIND);
                    }
                }

                var property: string;
                if (!isFunction(this._setter)) {
                    return;
                } else if (this._setter === this._setSelectedIndices) {
                    property = this._property;
                    if (isNull(context[property])) {
                        context[property] = [];
                    }
                    this.observeArray(context, property, (arrayInfo: observable.IArrayMethodInfo<string>) => {
                        this._setter(arrayInfo.newArray, arrayInfo.oldArray, true);
                    });
                }

                var expression = this._expression;

                this.observeExpression(expression, this._setter);
                this._setter(this.evaluateExpression(expression), undefined, true);
            }

            /**
             * @name _propertyChanged
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Sets the context property being bound to when the 
             * element's property is changed.
             * 
             * @returns {void}
             */
            _propertyChanged(): void {
                if (isNull(this._contextExpression)) {
                    return;
                }

                var context = this.evaluateExpression(this._contextExpression),
                    property = this._property;

                var newValue = this._getter();

                if (isNull(context) || context[property] === newValue) {
                    return;
                }

                // set flag to let setter functions know we changed the property
                this.__isSelf = true;
                context[property] = newValue;
                this.__isSelf = false;
            }

            /**
             * @name _observedBindableProperty
             * @memberof plat.controls.Bind
             * @kind function
             * @access protected
             * 
             * @description
             * Checks if the associated {@link plat.ui.TemplateControl|TemplateControl} is a 
             * {@link plat.ui.BindablePropertyControl|BindablePropertyControl} and 
             * initializes all listeners accordingly.
             * 
             * @returns {boolean} Whether or not the associated {@link plat.ui.TemplateControl|TemplateControl} 
             * is a {@link plat.ui.BindablePropertyControl|BindablePropertyControl}
             */
            _observedBindableProperty(): boolean {
                var templateControl = <ui.IBindablePropertyControl>this.templateControl;

                if (isFunction(templateControl.observeProperty) &&
                    isFunction(templateControl.setProperty)) {
                    templateControl.observeProperty((newValue: any) => {
                        this._getter = () => newValue;
                        this._propertyChanged();
                    });

                    this._setter = this.__setBindableProperty;
                    return true;
                }

                return false;
            }

            /**
             * @name __setBindableProperty
             * @memberof plat.controls.Bind
             * @kind function
             * @access private
             * 
             * @description
             * Sets the value on a {@link plat.ui.BindablePropertyControl|BindablePropertyControl}.
             * 
             * @param {any} newValue The new value to set
             * @param {any} oldValue? The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and 
             * should thus change the property if null
             * 
             * @returns {void}
             */
            private __setBindableProperty(newValue: any, oldValue?: any, firstTime?: boolean): void {
                if (this.__isSelf) {
                    return;
                }

                (<ui.IBindablePropertyControl>this.templateControl).setProperty(newValue, oldValue, firstTime);
            }

            /**
             * @name __setValue
             * @memberof plat.controls.Bind
             * @kind function
             * @access private
             * 
             * @description
             * Sets the value on an element.
             * 
             * @param {any} newValue The new value to set
             * 
             * @returns {void}
             */
            private __setValue(newValue: any): void {
                var element = <HTMLInputElement>this.element;
                if (element.value === newValue) {
                    return;
                }

                element.value = newValue;
            }

            /**
             * @name __setValue
             * @memberof plat.controls.Bind
             * @kind function
             * @access private
             * 
             * @description
             * Normalizes input[type="radio"] for cross-browser compatibility.
             * 
             * @returns {void}
             */
            private __initializeRadio(): void {
                var element = this.element;

                this._addEventType = this._addChangeEventListener;
                this._getter = this._getValue;
                this._setter = this._setRadio;

                if (!element.hasAttribute('name')) {
                    var attr = camelCase(this.type),
                        expression = (<any>this.attributes)[attr];

                    element.setAttribute('name', expression);
                }

                if (element.hasAttribute('value')) {
                    return;
                }

                element.setAttribute('value', '');
            }

            /**
             * @name __initializeSelect
             * @memberof plat.controls.Bind
             * @kind function
             * @access private
             * 
             * @description
             * Normalizes HTMLSelectElements for cross-browser compatibility.
             * 
             * @returns {void}
             */
            private __initializeSelect(): void {
                var element = <HTMLSelectElement>this.element,
                    multiple = element.multiple,
                    options = element.options,
                    length = options.length,
                    option: HTMLSelectElement;

                this._addEventType = this._addChangeEventListener;
                if (multiple) {
                    this._getter = this._getSelectedValues;
                    this._setter = this._setSelectedIndices;
                } else {
                    this._getter = this._getValue;
                    this._setter = this._setSelectedIndex;
                }

                for (var i = 0; i < length; ++i) {
                    option = options[i];
                    if (!option.hasAttribute('value')) {
                        option.setAttribute('value', option.textContent);
                    }
                }
            }

            /**
             * @name __checkAsynchronousSelect
             * @memberof plat.controls.Bind
             * @kind function
             * @access private
             * 
             * @description
             * Checks to see if a {@link plat.ui.control.Select|Select} is loading items.
             * 
             * @returns {boolean} Whether or not the select is loading items.
             */
            private __checkAsynchronousSelect(): boolean {
                var select = <ui.controls.Select>this.templateControl;
                if (!isNull(select) && (select.type === __Select || select.type === __ForEach) && isPromise(select.itemsLoaded)) {
                    var split = select.absoluteContextPath.split('.'),
                        key = split.pop();

                    this.observeArray(this.$ContextManagerStatic.getContext(this.parent, split), key,
                        (ev: observable.IArrayMethodInfo<any>) => {
                            select.itemsLoaded.then(() => {
                                this._setter(this.evaluateExpression(this._expression));
                            });
                        });

                    select.itemsLoaded.then(() => {
                        this._setter(this.evaluateExpression(this._expression));
                    });

                    return true;
                }

                return false;
            }
        }

        register.control(__Bind, Bind);

        /**
         * @name IFile
         * @memberof plat.controls
         * @kind interface
         * 
         * @extends {File}
         * 
         * @description
         * A file interface for browsers that do not support the 
         * File API.
         */
        export interface IFile extends File {
            /**
             * @name string
             * @memberof plat.controls.IFile
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * An absolute path to the file. The property is not added to 
             * File types.
             */
            path?: string;
        }

        /**
         * @name ObservableAttributeControl
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.AttributeControl}
         * @implements {plat.controls.IObservableAttributeControl}
         * 
         * @description
         * An {@link plat.controls.AttributeControl|AttributeControl} that deals with observing changes for a specified property.
         */
        export class ObservableAttributeControl extends AttributeControl implements IObservableAttributeControl {
            /**
             * @name $ContextManagerStatic
             * @memberof plat.controls.ObservableAttributeControl
             * @kind property
             * @access public
             * 
             * @type {plat.observable.IContextManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
             */
            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);

            /**
             * @name property
             * @memberof plat.controls.ObservableAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = '';

            /**
             * @name attribute
             * @memberof plat.controls.ObservableAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The camel-cased name of the control as it appears as an attribute.
             */
            attribute: string;

            /**
             * @name priority
             * @memberof plat.controls.ObservableAttributeControl
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * This control needs to load before its templateControl
             */
            priority = 200;

            /**
             * @name _listeners
             * @memberof plat.controls.ObservableAttributeControl
             * @kind property
             * @access protected
             * 
             * @type {Array<plat.IPropertyChangedListener>}
             * 
             * @description
             * The set of functions added by the Template Control that listens 
             * for property changes.
             */
            _listeners: Array<(newValue: any, oldValue?: any) => void> = [];

            /**
             * @name _removeListener
             * @memberof plat.controls.ObservableAttributeControl
             * @kind property
             * @access protected
             * 
             * @type {IRemoveListener}
             * 
             * @description
             * The function to stop listening for property changes.
             */
            _removeListener: IRemoveListener;

            /**
             * @name initialize
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access public
             * 
             * @description
             * Sets the initial value of the property on 
             * the Template Control.
             * 
             * @returns {void}
             */
            initialize(): void {
                this.attribute = camelCase(this.type);
                this._setProperty(this._getValue());
            }

            /**
             * @name loaded
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access public
             * 
             * @description
             * Observes the property and resets the value.
             * 
             * @returns {void}
             */
            loaded(): void {
                this._observeProperty();
                this._setProperty(this._getValue());
            }

            /**
             * @name dispose
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access public
             * 
             * @description
             * Stops listening for changes to the evaluated 
             * expression and removes references to the listeners 
             * defined by the Template Control.
             * 
             * @returns {void}
             */
            dispose(): void {
                if (isFunction(this._removeListener)) {
                    this._removeListener();
                }

                this._listeners = [];
            }

            /**
             * @name _setProperty
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access protected
             * 
             * @description
             * Sets the property on the Template Control.
             * 
             * @param {any} value The new value of the evaluated expression.
             * @param {any} oldValue? The old value of the evaluated expression.
             * 
             * @returns {void}
             */
            _setProperty(value: any, oldValue?: any): void {
                var templateControl = this.templateControl;

                if (isNull(templateControl)) {
                    return;
                }

                this.$ContextManagerStatic.defineGetter(templateControl, this.property, <observable.IObservableProperty<any>>{
                    value: value,
                    observe: this._addListener.bind(this)
                }, true, true);
                this._callListeners(value, oldValue);
            }

            /**
             * @name _callListeners
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access protected
             * 
             * @description
             * Calls the listeners defined by the Template Control.
             * 
             * @param {any} value The new value of the evaluated expression.
             * @param {any} oldValue The old value of the evaluated expression.
             * 
             * @returns {void}
             */
            _callListeners(newValue: any, oldValue: any): void {
                var listeners = this._listeners,
                    length = listeners.length,
                    templateControl = this.templateControl;

                for (var i = 0; i < length; ++i) {
                    listeners[i].call(templateControl, newValue, oldValue);
                }
            }

            /**
             * @name _addListener
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access protected
             * 
             * @description
             * Adds a listener as defined by the Template Control.
             * 
             * @param {plat.IPropertyChangedListener} listener The listener added by the Template Control.
             */
            _addListener(listener: (newValue: any, oldValue: any) => void): IRemoveListener {
                var listeners = this._listeners,
                    index = listeners.length;

                listeners.push(listener);

                return () => {
                    listeners.splice(index, 1);
                };
            }

            /**
             * @name _getValue
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access protected
             * 
             * @description
             * Evaluates the attribute's value.
             * 
             * @returns {any}
             */
            _getValue(): any {
                var expression = (<any>this.attributes)[this.attribute],
                    templateControl = this.templateControl;

                if (isNull(templateControl)) {
                    return;
                }

                return this.evaluateExpression(expression);
            }

            /**
             * @name _observeProperty
             * @memberof plat.controls.ObservableAttributeControl
             * @kind function
             * @access protected
             * 
             * @description
             * Observes the attribute's value.
             * 
             * @returns {void}
             */
            _observeProperty(): void {
                var expression = (<any>this.attributes)[this.attribute],
                    templateControl = this.templateControl;

                if (isNull(templateControl)) {
                    return;
                }

                this._removeListener = this.observeExpression(expression, this._setProperty);
            }
        }

        /**
         * @name IObservableAttributeControl
         * @memberof plat.controls
         * @kind interface
         * 
         * @extends {plat.controls.IAttributeControl}
         * 
         * @description
         * An {@link plat.controls.IAttributeControl|IAttributeControl} that deals with observing changes for a specified property.
         */
        export interface IObservableAttributeControl extends IAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.IObservableAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string;

            /**
             * @name attribute
             * @memberof plat.controls.IObservableAttributeControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The camel-cased name of the control as it appears as an attribute.
             */
            attribute: string;
        }

        /**
         * @name Options
         * @memberof plat.controls
         * @kind class
         * 
         * @extends {plat.controls.ObservableAttributeControl}
         * 
         * @description
         * An {@link plat.controls.ObservableAttributeControl|ObservableAttributeControl} that sets 'options' as the 
         * associated property.
         */
        export class Options extends ObservableAttributeControl {
            /**
             * @name property
             * @memberof plat.controls.Options
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The property to set on the associated template control.
             */
            property: string = 'options';
        }

        register.control(__Options, Options);
    }
    /**
     * @name ui
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds all the classes and interfaces related to UI components for platypus.
     */
    export module ui {
        /**
         * @name TemplateControl
         * @memberof plat.ui
         * @kind class
         * 
         * @extends {plat.Control}
         * @implements {plat.ui.ITemplateControl}
         * 
         * @description
         * The base control for any control that affects the UI. They provide properties for the control to use
         * to manage its body HTML.
         */
        export class TemplateControl extends Control implements ITemplateControl {
            /**
             * @name $ResourcesFactory
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ui.IResourcesFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.IResourcesFactory|IResourcesFactory} injectable.
             */
            static $ResourcesFactory: IResourcesFactory;
            /**
             * @name $BindableTemplatesFactory
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ui.IBindableTemplatesFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.IBindableTemplatesFactory|IBindableTemplatesFactory} injectable.
             */
            static $BindableTemplatesFactory: IBindableTemplatesFactory;
            /**
             * @name $ManagerCache
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.storage.ICache<processing.IElementManager>}
             * 
             * @description
             * Reference to a cache injectable that stores {@link plat.processing.IElementManager|IElementManagers}.
             */
            static $ManagerCache: storage.ICache<processing.IElementManager>;
            /**
             * @name $TemplateCache
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.storage.ITemplateCache}
             * 
             * @description
             * Reference to a cache injectable that stores and retrieves HTML templates.
             */
            static $TemplateCache: storage.ITemplateCache;
            /**
             * @name $Parser
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.expressions.IParser}
             * 
             * @description
             * Reference to the {@link plat.expressions.IParser|IParser} injectable.
             */
            static $Parser: expressions.IParser;
            /**
             * @name $Http
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.async.IHttp}
             * 
             * @description
             * Reference to the {@link plat.async.IHttp|IHttp} injectable.
             */
            static $Http: async.IHttp;
            /**
             * @name $Promise
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.async.IPromise}
             * 
             * @description
             * Reference to the {@link plat.async.IPromise|IPromise} injectable.
             */
            static $Promise: async.IPromise;

            /**
             * @name evaluateExpression
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Evaluates an expression string with a given control and optional control's context and aliases.
             * 
             * @param {string} expression The expression string (e.g. 'foo + foo').
             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.
             * @param {any} aliases? An optional alias object containing resource alias values
             * 
             * @returns {any} The evaluated object.
             */
            static evaluateExpression(expression: string, control?: ITemplateControl, aliases?: any): any;
            /**
             * @name evaluateExpression
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Evaluates an expression string with a given control and optional control's context and aliases.
             * 
             * @param {plat.expressions.IParsedExpression} expression A parsed expression object created using the 
             * plat.expressions.IParser injectable.
             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.
             * @param {any} aliases? An optional alias object containing resource alias values
             * 
             * @returns {any} The evaluated object.
             */
            static evaluateExpression(expression: expressions.IParsedExpression, control?: ITemplateControl, aliases?: any): any;
            static evaluateExpression(expression: any, control?: ITemplateControl, aliases?: any): any {
                if (isNull(expression)) {
                    return;
                } else if (!(isString(expression) || isFunction(expression.evaluate))) {
                    return;
                }

                expression = isString(expression) ? TemplateControl.$Parser.parse(expression) : expression;

                if (isNull(control)) {
                    return expression.evaluate(null, aliases);
                }

                if (expression.aliases.length > 0) {
                    aliases = TemplateControl.getResources(control, expression.aliases, aliases);
                }

                return expression.evaluate(control.context, aliases);
            }

            /**
             * @name getResources
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Given a control and Array of aliases, finds the associated resources and builds a context object containing
             * the values. Returns the object.
             * 
             * @param {plat.ui.ITemplateControl} control The control used as the starting point for finding resources.
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.
             * 
             * @returns {IObject<any>} An object representing a set of resources.
             */
            static getResources(control: ITemplateControl, aliases: Array<string>, resources?: any): IObject<any> {
                if (isNull(control)) {
                    return {};
                }

                var length = aliases.length,
                    alias: string,
                    resourceObj: {
                        control: ITemplateControl;
                        resource: IResource;
                    },
                    cache = TemplateControl.__resourceCache[control.uid];

                if (isNull(cache)) {
                    cache = TemplateControl.__resourceCache[control.uid] = {};
                }

                resources = resources || {};

                for (var i = 0; i < length; ++i) {
                    alias = aliases[i];

                    if (alias[0] === '@') {
                        alias = alias.slice(1);
                    }

                    if (!isNull(resources[alias])) {
                        continue;
                    } else if (!isNull(cache[alias])) {
                        var resourceControl = cache[alias].control,
                            controlResources = resourceControl.resources;

                        if (isNull(controlResources)) {
                            resourceObj = TemplateControl.findResource(control, alias);
                        } else {
                            resourceObj = {
                                control: resourceControl,
                                resource: controlResources[alias]
                            };
                        }
                    } else {
                        resourceObj = TemplateControl.findResource(control, alias);
                    }

                    if (isNull(resourceObj)) {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.warn('Attempting to use a resource that is not defined.', $exception.CONTEXT);
                        continue;
                    }

                    cache[alias] = resourceObj;
                    resources['@' + alias] = isNull(resourceObj.resource) ? resourceObj.resource : resourceObj.resource.value;
                }

                return resources;
            }

            /**
             * @name findResource
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Starts at a control and searches up its parent chain for a particular resource alias. 
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * 
             * @param {plat.ui.ITemplateControl} control The control on which to start searching for the resource alias.
             * @param {string} alias The alias to search for.
             * 
             * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the 
             * found resource along with its corresponding control.
             */
            static findResource(control: ITemplateControl, alias: string): { resource: IResource; control: ITemplateControl; } {
                var resource: IResource;

                if (isNull(control) || isNull(control.resources) || !isString(alias) || isEmpty(alias)) {
                    return null;
                }

                if (alias[0] === '@') {
                    alias = alias.slice(1);
                }

                if (alias === 'rootContext') {
                    control = Control.getRootControl(control);
                    return {
                        resource: (<any>control.resources)[alias],
                        control: control
                    };
                } else if (alias === 'context' || alias === 'control') {
                    return {
                        resource: (<any>control.resources)[alias],
                        control: control
                    };
                }

                while (!isNull(control)) {
                    resource = (<any>control.resources)[alias];
                    if (!isNull(resource)) {
                        return {
                            resource: resource,
                            control: control
                        };
                    }
                    control = control.parent;
                }
            }

            /**
             * @name dispose
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Recursively disposes a control and its children.
             * 
             * @param {plat.ui.ITemplateControl} control A control to dispose.
             * 
             * @returns {void}
             */
            static dispose(control: ITemplateControl): void {
                if (isNull(control)) {
                    return;
                }

                var uid = control.uid,
                    childControls = control.controls,
                    controls = (childControls && childControls.slice(0)),
                    ContextManager = Control.$ContextManagerStatic,
                    define = ContextManager.defineProperty;

                if (!isNull(controls)) {
                    var length = controls.length - 1;

                    for (var i = length; i >= 0; --i) {
                        Control.dispose(controls[i]);
                    }
                }

                if (isFunction(control.dispose)) {
                    control.dispose();
                }

                Control.removeEventListeners(control);
                TemplateControl.removeElement(control);

                TemplateControl.$ResourcesFactory.dispose(control);
                TemplateControl.$BindableTemplatesFactory.dispose(control);

                deleteProperty(TemplateControl.__resourceCache, control.uid);

                ContextManager.dispose(control);
                events.EventManager.dispose(control.uid);

                TemplateControl.$ManagerCache.remove(uid);
                Control.removeParent(control);

                define(control, 'context', null, true, true);
                define(control, 'resources', null, true, true);
                control.attributes = null;
                control.bindableTemplates = null;
                control.controls = [];
                control.root = null;
                control.innerTemplate = null;
            }

            /**
             * @name loadControl
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Loads the control tree depth first (visit children, then visit self).
             * 
             * @param {plat.ui.ITemplateControl} control The control serving as the root control to load.
             * 
             * @returns {void}
             */
            static loadControl(control: ITemplateControl): void {
                var children = control.controls,
                    length = children.length,
                    child: ITemplateControl;

                for (var i = 0; i < length; ++i) {
                    child = <ITemplateControl>children[i];
                    if (!isNull(child.controls)) {
                        TemplateControl.loadControl(child);
                    } else {
                        child.loaded();
                    }
                }

                control.loaded();
            }

            /**
             * @name contextChanged
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Notifies a control that its context has been changed by 
             * calling the "control.contextChanged" method if it exists.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose context changed.
             * @param {any} newValue The new value of the control's context.
             * @param {any} oldValue The old value of the control's context.
             * 
             * @returns {void}
             */
            static contextChanged(control: ITemplateControl, newValue: any, oldValue: any): void {
                control.context = newValue;

                TemplateControl.setContextResources(control);

                if (isFunction(control.contextChanged)) {
                    control.contextChanged(newValue, oldValue);
                }
            }

            /**
             * @name setContextResources
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Sets the 'context' resource value on a {@link plat.ui.ITemplateControl|ITemplateControl}. If the control specifies 
             * hasOwnContext as true, the 'rootContext' resource value will be set.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose context resources will be set.
             * 
             * @returns {void}
             */
            static setContextResources(control: ITemplateControl): void {
                var value = control.context;

                if (isNull(control.resources)) {
                    control.resources = TemplateControl.$ResourcesFactory.getInstance();
                    control.resources.initialize(control);
                }

                if (control.hasOwnContext) {
                    if (isNull((<any>control.resources).rootContext)) {
                        control.resources.add({
                            root: {
                                type: 'observable',
                                value: value
                            }
                        });
                    } else {
                        (<any>control.resources).rootContext.value = value;
                    }
                }

                if (isNull((<any>control.resources).context)) {
                    control.resources.add({
                        context: {
                            type: 'observable',
                            value: value
                        }
                    });

                    return;
                }

                (<any>control.resources).context.value = value;
            }

            /**
             * @name removeElement
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Completely removes a control's element from its parentNode. If the 
             * control implements replaceWith=null, All of its nodes between its 
             * startNode and endNode (inclusive) will be removed.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose element should be removed.
             * 
             * @returns {void}
             */
            static removeElement(control: ITemplateControl): void {
                if (isNull(control)) {
                    return;
                }

                var dom = control.dom,
                    element = control.element,
                    parentNode: Node;

                if (control.replaceWith === null ||
                control.replaceWith === '' ||
                isDocumentFragment(element)) {
                    dom.removeAll(control.startNode, control.endNode);
                    control.elementNodes = control.startNode = control.endNode = null;
                    return;
                } else if (isNull(element)) {
                    return;
                }

                parentNode = element.parentNode;

                if (!isNull(parentNode)) {
                    parentNode.removeChild(element);
                }

                control.element = null;
            }

            /**
             * @name setAbsoluteContextPath
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Sets the absoluteContextPath read-only property on a control.
             * 
             * @param {plat.ui.ITemplateControl} control The control on which to set the absoluteContextPath.
             * @param {string} path The path to set on the control.
             * 
             * @returns {void}
             */
            static setAbsoluteContextPath(control: ITemplateControl, path: string): void {
                Control.$ContextManagerStatic.defineGetter(control, 'absoluteContextPath', path, false, true);
            }

            /**
             * @name determineTemplate
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines the template for a control by searching for a templateUrl, 
             * using the provided templateUrl, or serializing the control's templateString.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose template is being determined.
             * @param {string} templateUrl? The potential template URL to use to grab the template.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves to the proper template.
             */
            static determineTemplate(control: ITemplateControl, templateUrl?: string): async.IThenable<DocumentFragment> {
                var template: any,
                    templateCache = TemplateControl.$TemplateCache,
                    dom = control.dom,
                    Promise = TemplateControl.$Promise;

                if (!isNull(templateUrl)) {
                    // do nothing
                } else if (!isNull(control.templateUrl)) {
                    templateUrl = control.templateUrl;
                } else if (!isNull(control.templateString)) {
                    var type = control.type;

                    return templateCache.read(type).catch((template: any) => {
                        if (isNull(template)) {
                            template = dom.serializeHtml(control.templateString);
                    }

                    return templateCache.put(type, template);
                    });
                } else {
                    return <any>Promise.reject(null);
                }

                var $exception: IExceptionStatic;

                return templateCache.put(templateUrl, templateCache.read(templateUrl).catch((error) => {
                    if (isNull(error)) {
                        return TemplateControl.$Http.ajax<string>({ url: templateUrl });
                    }
                }).then<DocumentFragment>((success) => {
                    if (isDocumentFragment(success)) {
                        return templateCache.put(templateUrl, <any>success);
                    } else if (!isObject(success) || !isString(success.response)) {
                        $exception = acquire(__ExceptionStatic);
                        $exception.warn('No template found at ' + templateUrl, $exception.AJAX);
                        return templateCache.put(templateUrl, dom.serializeHtml());
                    }

                    var templateString = success.response;

                    if (isEmpty(templateString.trim())) {
                        return templateCache.put(templateUrl, dom.serializeHtml());
                    }

                    return templateCache.put(templateUrl, dom.serializeHtml(templateString));
                }).catch((error) => {
                    postpone(() => {
                        $exception = acquire(__ExceptionStatic);
                        $exception.fatal('Failure to get template from ' + templateUrl + '.',
                            $exception.TEMPLATE);
                    });
                    return error;
                }));
            }

            /**
             * @name detach
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Detaches a {@link plat.ui.TemplateControl|TemplateControl}. Disposes its children, 
             * but does not dispose the {@link plat.ui.TemplateControl|TemplateControl}.
             * 
             * @param {plat.ui.ITemplateControl} control The control to be detached.
             * 
             * @returns {void}
             */
            static detach(control: ITemplateControl): void {
                if (isNull(control) || isNull(control.controls)) {
                    return;
                }

                var controls = control.controls.slice(0),
                    length = controls.length;

                for (var i = 0; i < length; ++i) {
                    Control.dispose(controls[i]);
                }

                TemplateControl.removeElement(control);

                TemplateControl.$ResourcesFactory.dispose(control, true);

                deleteProperty(TemplateControl.__resourceCache, control.uid);

                Control.$ContextManagerStatic.dispose(control, true);
                events.EventManager.dispose(control.uid);

                TemplateControl.$ManagerCache.remove(control.uid);
                Control.removeParent(control);

                control.controls = [];
                control.attributes = null;
            }

            /**
             * @name getInstance
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of {@link plat.ui.TemplateControl|TemplateControl}.
             * 
             * @returns {plat.ui.ITemplateControl} The new {@link plat.ui.TemplateControl|TemplateControl} instance.
             */
            static getInstance(): ITemplateControl {
                return new TemplateControl();
            }

            /**
             * @name __resourceCache
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access private
             * @static
             * 
             * @type {any}
             * 
             * @description
             * An object for quickly retrieving previously accessed resources.
             */
            private static __resourceCache: any = {};

            /**
             * @name priority
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * By default {@link plat.ui.TemplateControl|TemplateControls} have a priority of 100.
             */
            priority = 100;

            /**
             * @name context
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The context of an {@link plat.ui.ITemplateControl|ITemplateControl}, used for inheritance and data-binding.
             */
            context: any = null;

            /**
             * @name name
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The name of a {@link plat.ui.ITemplateControl|ITemplateControl} if a {@link plat.controls.Name|Name} 
             * control is involved.
             */
            name: string;

            /**
             * @name absoluteContextPath
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies the absolute path from where the context was created to this IControl's context.
             * Used by the {@link plat.observable.ContextManager|ContextManager} for maintaining context parity 
             * (e.g. 'context.childContextProperty.grandChildContextProperty').
             */
            absoluteContextPath: string = null;

            /**
             * @name resources
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IResources}
             * 
             * @description
             * Resources are used for providing aliases to use in markup expressions. They 
             * are particularly useful when trying to access properties outside of the 
             * current context, as well as reassigning context at any point in an app.
             * 
             * @remarks
             * By default, every control has a resource for '@control' and '@context'.
             * {@link plat.ui.IViewControl|IViewControl} objects also have a resource for '@root' and '@rootContext', 
             * which is a reference to their root control and root context.
             * 
             * Resources can be created in HTML, or through the exposed control.resources 
             * object. If specified in HTML, they must be the first element child of the 
             * control upon which the resources will be placed. IViewControls that use a 
             * templateUrl can have resources as their first element in the templateUrl.
             * 
             * In the provided example, the resources can be accessed by using '@Cache' and '@testObj'.
             * The type of resource is denoted by the element name.
             * 
             * Only resources of type 'observable' will have data binding. The types of resources are:
             * function, injectable, observable, and object. Resources of type 'function' will have their
             * associated function context bound to the control that contains the resource.
             * 
             * When an alias is found in a markup expression, the framework will search up the control chain 
             * to find the alias on a control's resources. This first matching alias will be used.
             * 
             * @example
             * <custom-control>
             *     <plat-resources>
             *         <injectable alias="Cache">$CacheFactory</injectable>
             *         <observable alias="testObj">
             *              { 
             *                  foo: 'foo', 
             *                  bar: 'bar', 
             *                  baz: 2 
             *              }
             *         </observable>
             *     </plat-resources>
             * </custom-control>
             */
            resources: IResources;

            /**
             * @name hasOwnContext
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Flag indicating whether or not the {@link plat.ui.ITemplateControl|ITemplateControl} defines the context property.
             */
            hasOwnContext: boolean = false;

            /**
             * @name templateString
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A string representing the DOM template for this control. If this property is
             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the 
             * control's element prior to calling the 'setTemplate' method.
             */
            templateString: string;

            /**
             * @name templateUrl
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A url containing a string representing the DOM template for this control. If this property is
             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the 
             * control's element prior to calling the 'setTemplate' method. This property takes 
             * precedence over templateString. In the event that both are defined, templateString
             * will be ignored.
             */
            templateUrl: string;

            /**
             * @name innerTemplate
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {DocumentFragment}
             * 
             * @description
             * A DocumentFragment representing the innerHTML that existed when this control was instantiated.
             * This property will only contain the innerHTML when either a templateString or templateUrl is
             * defined. Its important to clone this property when injecting it somewhere, else its childNodes
             * will disappear.
             * 
             * @example this.innerTemplate.cloneNode(true); //Useful if this is not a one-time injection.
             */
            innerTemplate: DocumentFragment;

            /**
             * @name bindableTemplates
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IBindableTemplates}
             * 
             * @description
             * An {@link plat.ui.IBindableTemplates|IBindableTemplates} object used for binding a data context to a template. 
             * This is an advanced function of a {@link plat.ui.ITemplateControl|ITemplateControl}.
             */
            bindableTemplates: IBindableTemplates;

            /**
             * @name controls
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {Array<plat.IControl>}
             * 
             * @description
             * An array of child controls. Any controls created by this control can be found in this array. The controls in
             * this array will have reference to this control in their parent property.
             */
            controls: Array<IControl>;

            /**
             * @name elementNodes
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {Array<Node>}
             * 
             * @description
             * A Node array for managing the {@link plat.ui.ITemplateControl|ITemplateControl's} childNodes in the event that this control 
             * replaces its element. This property will only exist/be of use for a {@link plat.ui.ITemplateControl|ITemplateControl} that 
             * implements the replaceWith property.
             */
            elementNodes: Array<Node>;

            /**
             * @name startNode
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {Node}
             * 
             * @description
             * The first node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the 
             * control implements replaceWith = null, otherwise it will be null. This property allows an 
             * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.
             * 
             * @example this.startNode.parentNode.insertBefore(node, this.startNode.nextSibling);
             */
            startNode: Node;

            /**
             * @name endNode
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {Node}
             * 
             * @description
             * The last node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the 
             * control implements the replaceWith property, otherwise it will be null. This property allows a 
             * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.
             * 
             * @example this.endNode.parentNode.insertBefore(node, this.endNode);
             */
            endNode: Node;

            /**
             * @name replaceWith
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Allows a {@link plat.ui.ITemplateControl|ITemplateControl} to either swap its element with another element (e.g. plat-select), 
             * or replace its element altogether. If null or empty string, the element will be removed from the DOM, and the 
             * childNodes of the element will be in its place. In addition, when the element is placed startNode and endNode Comments 
             * are created, and the childNodes are added to the elementNodes property on the control. The replaceWith 
             * property can be any property that works with document.createElement(). If the control's element had 
             * attributes (as well as attribute IControls), those attributes will be carried to the swapped element. The default 
             * replaceWith is 'any,' meaning it will default to a 'div' in the case that the control type is used as the 
             * element's nodename (e.g. <plat-foreach plat-context="..."></plat-foreach>), but will maintain whatever element type 
             * is used otherwise (e.g. <tr plat-control="plat-foreach" plat-context="..."></tr>).
             */
            replaceWith = 'any';

            /**
             * @name root
             * @memberof plat.ui.TemplateControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * Set to the root ancestor control from which this control inherits its context. This value
             * can be equal to this control.
             */
            root: ITemplateControl;

            /**
             * @name contextChanged
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * This event is fired when an {@link plat.ui.ITemplateControl|ITemplateControl's} context property 
             * is changed by an ancestor control.
             * 
             * @param {any} newValue? The new value of the context.
             * @param {any} oldValue? The old value of the context.
             * 
             * @returns {void}
             */
            contextChanged(newValue?: any, oldValue?: any): void { }

            /**
             * @name setTemplate
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * A method called for {@link plat.ui.ITemplateControl|ITemplateControls} to set their template. 
             * During this method a control should ready its template for compilation. Whatever is in the control's 
             * element (or elementNodes if replaceWith is implemented) after this method's execution will be compiled 
             * and appear on the DOM.
             * 
             * @returns {void}
             */
            setTemplate(): void { }

            /**
             * @name getIdentifier
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Finds the identifier string associated with the given context object. The string returned
             * is the path from a control's context.
             * 
             * @param {any} context The object/primitive to locate on the control's context.
             * 
             * @returns {string} The input context's identifier string.
             * 
             * @example 
             *     // returns 'title.font'
             *     this.getIdentifier(this.context.title.font);
             */
            getIdentifier(context: any): string {
                var queue: Array<{ context: any; identifier: string; }> = [],
                    dataContext = this.context,
                    found = false,
                    obj = {
                        context: dataContext,
                        identifier: ''
                    },
                    length: number,
                    keys: Array<string>,
                    key: string,
                    newObj: any;

                if (dataContext === context) {
                    found = true;
                } else {
                    queue.push(obj);
                }

                while (queue.length > 0) {
                    obj = queue.pop();

                    if (!isObject(obj.context)) {
                        continue;
                    }

                    keys = Object.keys(obj.context);
                    length = keys.length;

                    for (var i = 0; i < length; ++i) {
                        key = keys[i];
                        newObj = obj.context[key];

                        if (newObj === context) {
                            return (obj.identifier !== '') ? (obj.identifier + '.' + key) : key;
                        }

                        queue.push({
                            context: newObj,
                            identifier: (obj.identifier !== '') ? (obj.identifier + '.' + key) : key
                        });
                    }
                }
                if (!found) {
                    return;
                }

                return obj.identifier;
            }

            /**
             * @name getAbsoluteIdentifier
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Finds the absolute identifier string associated with the given context object. The string returned
             * is the path from a control's root ancestor's context.
             * 
             * @param {any} context The object/primitive to locate on the root control's context.
             * 
             * @returns {string} The input context's identifier string as seen from the root context object.
             */
            getAbsoluteIdentifier(context: any): string {
                if (context === this.context) {
                    return this.absoluteContextPath;
                }

                var localIdentifier = this.getIdentifier(context);
                if (isNull(localIdentifier)) {
                    return localIdentifier;
                }

                return this.absoluteContextPath + '.' + localIdentifier;
            }

            /**
             * @name getResources
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Finds the associated resources and builds a context object containing
             * the values.
             * 
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.
             * 
             * @returns {IObject<any>} The context object containing the values of the associated resources.
             */
            getResources(aliases: Array<string>, resources?: any): IObject<any> {
                return TemplateControl.getResources(this, aliases, resources);
            }

            /**
             * @name findResource
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Starts at a control and searches up its parent chain for a particular resource alias. 
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * 
             * @param {string} alias The alias to search for.
             * 
             * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the 
             * found resource along with its corresponding control.
             */
            findResource(alias: string): { resource: IResource; control: ITemplateControl; } {
                return TemplateControl.findResource(this, alias);
            }

            /**
             * @name evaluateExpression
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Evaluates an expression string, using the input context or control.context.
             * 
             * @param {string} expression The expression string to evaluate.
             * @param {any} context? An optional context with which to parse. If 
             * no context is specified, the control.context will be used.
             * 
             * @returns {any} The evaluated object/primitive.
             */
            evaluateExpression(expression: string, context?: any): any;
            /**
             * @name evaluateExpression
             * @memberof plat.ui.TemplateControl
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Evaluates an expression string, using the input context or control.context.
             * 
             * @param {plat.expressions.IParsedExpression} expression The previously parsed expression to evaluate.
             * @param {any} context? An optional context with which to parse. If 
             * no context is specified, the control.context will be used.
             * 
             * @returns {any} The evaluated object/primitive.
             */
            evaluateExpression(expression: expressions.IParsedExpression, context?: any): any;
            evaluateExpression(expression: any, context?: any): any {
                return TemplateControl.evaluateExpression(expression, this, context);
            }
        }

        /**
         * The Type for referencing the '$TemplateControlFactory' injectable as a dependency.
         */
        export function ITemplateControlFactory(
            $ResourcesFactory?: IResourcesFactory,
            $BindableTemplatesFactory?: IBindableTemplatesFactory,
            $ManagerCache?: storage.ICache<processing.IElementManager>,
            $TemplateCache?: storage.ITemplateCache,
            $Parser?: expressions.IParser,
            $Http?: async.IHttp,
            $Promise?: async.IPromise): ITemplateControlFactory {
                TemplateControl.$ResourcesFactory = $ResourcesFactory;
                TemplateControl.$BindableTemplatesFactory = $BindableTemplatesFactory;
                TemplateControl.$ManagerCache = $ManagerCache;
                TemplateControl.$TemplateCache = $TemplateCache;
                TemplateControl.$Parser = $Parser;
                TemplateControl.$Http = $Http;
                TemplateControl.$Promise = $Promise;
                return TemplateControl;
        }

        register.injectable(__TemplateControlFactory, ITemplateControlFactory, [
            __ResourcesFactory,
            __BindableTemplatesFactory,
            __ManagerCache,
            __TemplateCache,
            __Parser,
            __Http,
            __Promise
        ], __FACTORY);

        /**
         * @name ITemplateControlFactory
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Creates and manages {@link plat.ui.ITemplateControl|ITemplateControls}.
         */
        export interface ITemplateControlFactory {
            /**
             * @name evaluateExpression
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Evaluates an expression string with a given control and optional control's context and aliases.
             * 
             * @param {string} expression The expression string (e.g. 'foo + foo').
             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.
             * @param {any} aliases? An optional alias object containing resource alias values
             * 
             * @returns {any} The evaluated object.
             */
            evaluateExpression(expression: string, control?: ITemplateControl, aliases?: any): any;
            /**
             * @name evaluateExpression
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Evaluates an expression string with a given control and optional control's context and aliases.
             * 
             * @param {plat.expressions.IParsedExpression} expression A parsed expression object created using the 
             * plat.expressions.IParser injectable.
             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.
             * @param {any} aliases? An optional alias object containing resource alias values
             * 
             * @returns {any} The evaluated object.
             */
            evaluateExpression(expression: expressions.IParsedExpression, control?: ITemplateControl, aliases?: any): any;

            /**
             * @name getResources
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Given a control and Array of aliases, finds the associated resources and builds a context object containing
             * the values. Returns the object.
             * 
             * @param {plat.ui.ITemplateControl} control The control used as the starting point for finding resources.
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.
             * 
             * @returns {IObject<any>} An object representing a set of resources.
             */
            getResources(control: ITemplateControl, aliases: Array<string>, resources?: any): IObject<any>;

            /**
             * @name findResource
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Starts at a control and searches up its parent chain for a particular resource alias. 
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * 
             * @param {plat.ui.ITemplateControl} control The control on which to start searching for the resource alias.
             * @param {string} alias The alias to search for.
             * 
             * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the 
             * found resource along with its corresponding control.
             */
            findResource(control: ITemplateControl, alias: string): { resource: IResource; control: ITemplateControl; };

            /**
             * @name dispose
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Recursively disposes a control and its children.
             * 
             * @param {plat.ui.ITemplateControl} control A control to dispose.
             * 
             * @returns {void}
             */
            dispose(control: ITemplateControl): void;

            /**
             * @name loadControl
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Loads the control tree depth first (visit children, then visit self).
             * 
             * @param {plat.ui.ITemplateControl} control The control serving as the root control to load.
             * 
             * @returns {void}
             */
            loadControl(control: ITemplateControl): void;

            /**
             * @name contextChanged
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Notifies a control that its context has been changed by 
             * calling the "control.contextChanged" method if it exists.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose context changed.
             * @param {any} newValue The new value of the control's context.
             * @param {any} oldValue The old value of the control's context.
             * 
             * @returns {void}
             */
            contextChanged(control: ITemplateControl, newValue: any, oldValue: any): void;

            /**
             * @name setContextResources
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Sets the 'context' resource value on a {@link plat.ui.ITemplateControl|ITemplateControl}. If the control specifies 
             * hasOwnContext as true, the 'rootContext' resource value will be set.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose context resources will be set.
             * 
             * @returns {void}
             */
            setContextResources(control: ITemplateControl): void;

            /**
             * @name removeElement
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Completely removes a control's element from its parentNode. If the 
             * control implements replaceWith=null, All of its nodes between its 
             * startNode and endNode (inclusive) will be removed.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose element should be removed.
             * 
             * @returns {void}
             */
            removeElement(control: ITemplateControl): void;

            /**
             * @name setAbsoluteContextPath
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Sets the absoluteContextPath read-only property on a control.
             * 
             * @param {plat.ui.ITemplateControl} control The control on which to set the absoluteContextPath.
             * @param {string} path The path to set on the control.
             * 
             * @returns {void}
             */
            setAbsoluteContextPath(control: ITemplateControl, path: string): void;

            /**
             * @name determineTemplate
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines the template for a control by searching for a templateUrl, 
             * using the provided templateUrl, or serializing the control's templateString.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose template is being determined.
             * @param {string} templateUrl? The potential template URL to use to grab the template.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves to the proper template.
             */
            determineTemplate(control: ITemplateControl, templateUrl?: string): async.IThenable<DocumentFragment>;

            /**
             * @name detach
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Detaches a {@link plat.ui.TemplateControl|TemplateControl}. Disposes its children, 
             * but does not dispose the {@link plat.ui.TemplateControl|TemplateControl}.
             * 
             * @param {plat.ui.ITemplateControl} control The control to be detached.
             * 
             * @returns {void}
             */
            detach(control: ITemplateControl): void;

            /**
             * @name getInstance
             * @memberof plat.ui.ITemplateControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of {@link plat.ui.TemplateControl|TemplateControl}.
             * 
             * @returns {plat.ui.ITemplateControl} The new {@link plat.ui.TemplateControl|TemplateControl} instance.
             */
            getInstance(): ITemplateControl;
        }

        /**
         * @name ITemplateControl
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.IControl}
         * 
         * @description
         * Describes a control which provides properties and methods for managing its body HTML.
         */
        export interface ITemplateControl extends IControl {
            /**
             * @name context
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The context of an {@link plat.ui.ITemplateControl|ITemplateControl}, used for inheritance and data-binding.
             */
            context?: any;

            /**
             * @name name
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * The name of a {@link plat.ui.ITemplateControl|ITemplateControl} if a {@link plat.controls.Name|Name} 
             * control is involved and placed on its element.
             */
            name?: string;

            /**
             * @name absoluteContextPath
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies the absolute path from where the context was created to this IControl's context.
             * Used by the {@link plat.observable.ContextManager|ContextManager} for maintaining context parity 
             * (e.g. 'context.childContextProperty.grandChildContextProperty').
             */
            absoluteContextPath?: string;

            /**
             * @name resources
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IResources}
             * 
             * @description
             * Resources are used for providing aliases to use in markup expressions. They 
             * are particularly useful when trying to access properties outside of the 
             * current context, as well as reassigning context at any point in an app.
             * 
             * @remarks
             * By default, every control has a resource for '@control' and '@context'.
             * {@link plat.ui.IViewControl|IViewControl} objects also have a resource for '@root' and '@rootContext', 
             * which is a reference to their root control and root context.
             * 
             * Resources can be created in HTML, or through the exposed control.resources 
             * object. If specified in HTML, they must be the first element child of the 
             * control upon which the resources will be placed. IViewControls that use a 
             * templateUrl can have resources as their first element in the templateUrl.
             * 
             * In the provided example, the resources can be accessed by using '@Cache' and '@testObj'.
             * The type of resource is denoted by the element name.
             * 
             * Only resources of type 'observable' will have data binding. The types of resources are:
             * function, injectable, observable, and object. Resources of type 'function' will have their
             * associated function context bound to the control that contains the resource.
             * 
             * When an alias is found in a markup expression, the framework will search up the control chain 
             * to find the alias on a control's resources. This first matching alias will be used.
             * 
             * @example
             * <custom-control>
             *     <plat-resources>
             *         <injectable alias="Cache">$CacheFactory</injectable>
             *         <observable alias="testObj">
             *              { 
             *                  foo: 'foo', 
             *                  bar: 'bar', 
             *                  baz: 2 
             *              }
             *         </observable>
             *     </plat-resources>
             * </custom-control>
             */
            resources?: IResources;

            /**
             * @name hasOwnContext
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Flag indicating whether or not the {@link plat.ui.ITemplateControl|ITemplateControl} defines the context property.
             */
            hasOwnContext?: boolean;

            /**
             * @name templateString
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A string representing the DOM template for this control. If this property is
             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the 
             * control's element prior to calling the 'setTemplate' method.
             */
            templateString?: string;

            /**
             * @name templateUrl
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A url containing a string representing the DOM template for this control. If this property is
             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the 
             * control's element prior to calling the 'setTemplate' method. This property takes 
             * precedence over templateString. In the event that both are defined, templateString
             * will be ignored.
             */
            templateUrl?: string;

            /**
             * @name innerTemplate
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {DocumentFragment}
             * 
             * @description
             * A DocumentFragment representing the innerHTML that existed when this control was instantiated.
             * This property will only contain the innerHTML when either a templateString or templateUrl is
             * defined. Its important to clone this property when injecting it somewhere, else its childNodes
             * will disappear.
             * 
             * @example this.innerTemplate.cloneNode(true); //Useful if this is not a one-time injection.
             */
            innerTemplate?: DocumentFragment;

            /**
             * @name bindableTemplates
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IBindableTemplates}
             * 
             * @description
             * An {@link plat.ui.IBindableTemplates|IBindableTemplates} object used for binding a data context to a template. 
             * This is an advanced function of a {@link plat.ui.ITemplateControl|ITemplateControl}.
             */
            bindableTemplates?: IBindableTemplates;

            /**
             * @name controls
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {Array<plat.IControl>}
             * 
             * @description
             * An array of child controls. Any controls created by this control can be found in this array. The controls in
             * this array will have reference to this control in their parent property.
             */
            controls?: Array<IControl>;

            /**
             * @name elementNodes
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {Array<Node>}
             * 
             * @description
             * A Node array for managing the {@link plat.ui.ITemplateControl|ITemplateControl's} childNodes in the event that this control 
             * replaces its element. This property will only exist/be of use for a {@link plat.ui.ITemplateControl|ITemplateControl} that 
             * implements the replaceWith property.
             */
            elementNodes?: Array<Node>;

            /**
             * @name startNode
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {Node}
             * 
             * @description
             * The first node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the 
             * control implements replaceWith = null, otherwise it will be null. This property allows an 
             * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.
             * 
             * @example this.startNode.parentNode.insertBefore(node, this.startNode.nextSibling);
             */
            startNode?: Node;

            /**
             * @name endNode
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {Node}
             * 
             * @description
             * The last node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the 
             * control implements the replaceWith property, otherwise it will be null. This property allows a 
             * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.
             * 
             * @example this.endNode.parentNode.insertBefore(node, this.endNode);
             */
            endNode?: Node;

            /**
             * @name replaceWith
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Allows a {@link plat.ui.ITemplateControl|ITemplateControl} to either swap its element with another element (e.g. plat-select), 
             * or replace its element altogether. If null or empty string, the element will be removed from the DOM, and the 
             * childNodes of the element will be in its place. In addition, when the element is placed startNode and endNode Comments 
             * are created, and the childNodes are added to the elementNodes property on the control. The replaceWith 
             * property can be any property that works with document.createElement(). If the control's element had 
             * attributes (as well as attribute IControls), those attributes will be carried to the swapped element. The default 
             * replaceWith is 'any,' meaning it will default to a 'div' in the case that the control type is used as the 
             * element's nodename (e.g. <plat-foreach plat-context="..."></plat-foreach>), but will maintain whatever element type 
             * is used otherwise (e.g. <tr plat-control="plat-foreach" plat-context="..."></tr>).
             */
            replaceWith?: string;

            /**
             * @name root
             * @memberof plat.ui.ITemplateControl
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * Set to the root ancestor control from which this control inherits its context. This value
             * can be equal to this control.
             */
            root?: ITemplateControl;

            /**
             * @name setTemplate
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * A method called for {@link plat.ui.ITemplateControl|ITemplateControls} to set their template. 
             * During this method a control should ready its template for compilation. Whatever is in the control's 
             * element (or elementNodes if replaceWith is implemented) after this method's execution will be compiled 
             * and appear on the DOM.
             * 
             * @returns {void}
             */
            setTemplate? (): void;

            /**
             * @name contextChanged
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * This event is fired when an {@link plat.ui.ITemplateControl|ITemplateControl's} context property 
             * is changed by an ancestor control.
             * 
             * @param {any} newValue? The new value of the context.
             * @param {any} oldValue? The old value of the context.
             * 
             * @returns {void}
             */
            contextChanged? (newValue: any, oldValue: any): void;

            /**
             * @name getIdentifier
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Finds the identifier string associated with the given context object. The string returned
             * is the path from a control's context.
             * 
             * @param {any} context The object/primitive to locate on the control's context.
             * 
             * @returns {string} The input context's identifier string.
             * 
             * @example 
             *     // returns 'title.font'
             *     this.getIdentifier(this.context.title.font);
             */
            getIdentifier? (context: any): string;

            /**
             * @name getAbsoluteIdentifier
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Finds the absolute identifier string associated with the given context object. The string returned
             * is the path from a control's root ancestor's context.
             * 
             * @param {any} context The object/primitive to locate on the root control's context.
             * 
             * @returns {string} The input context's identifier string as seen from the root context object.
             */
            getAbsoluteIdentifier? (context: any): string;

            /**
             * @name getResources
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Finds the associated resources and builds a context object containing
             * the values.
             * 
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.
             * 
             * @returns {IObject<any>} The context object containing the values of the associated resources.
             */
            getResources? (aliases: Array<string>, resources?: any): IObject<any>;

            /**
             * @name findResource
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * 
             * @description
             * Starts at a control and searches up its parent chain for a particular resource alias. 
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * 
             * @param {string} alias The alias to search for.
             * 
             * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the 
             * found resource along with its corresponding control.
             */
            findResource? (alias: string): { resource: IResource; control: ITemplateControl; };

            /**
             * @name evaluateExpression
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Evaluates an expression string, using the input context or control.context.
             * 
             * @param {string} expression The expression string to evaluate.
             * @param {any} context? An optional context with which to parse. If 
             * no context is specified, the control.context will be used.
             * 
             * @returns {any} The evaluated object/primitive.
             */
            evaluateExpression? (expression: string, context?: any): any;
            /**
             * @name evaluateExpression
             * @memberof plat.ui.ITemplateControl
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Evaluates an expression string, using the input context or control.context.
             * 
             * @param {plat.expressions.IParsedExpression} expression The previously parsed expression to evaluate.
             * @param {any} context? An optional context with which to parse. If 
             * no context is specified, the control.context will be used.
             * 
             * @returns {any} The evaluated object/primitive.
             */
            evaluateExpression? (expression: expressions.IParsedExpression, context?: any): any;
        }

        /**
         * @name BindablePropertyControl
         * @memberof plat.ui
         * @kind class
         * 
         * @extends {plat.ui.TemplateControl}
         * @implements {plat.ui.IBindablePropertyControl}
         * 
         * @description
         * An extended {@link plat.ui.TemplateControl|TemplateControl} that allows for the binding of a value to 
         * another listening control (e.g. {@link plat.controls.Bind|plat-bind} control).
         */
        export class BindablePropertyControl extends TemplateControl implements IBindablePropertyControl {
            /**
             * @name _listeners
             * @memberof plat.ui.BindablePropertyControl
             * @kind property
             * @access protected
             * 
             * @type {Array<plat.IPropertyChangedListener>}
             * 
             * @description
             * The set of functions added externally that listens 
             * for property changes.
             */
            _listeners: Array<(newValue: any, oldValue?: any) => void> = [];

            /**
             * @name observeProperty
             * @memberof plat.ui.BindablePropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * Adds a listener to be called when the bindable property changes.
             * 
             * @param {plat.IPropertyChangedListener} listener The function that acts as a listener.
             * 
             * @returns {plat.IRemoveListener} A function to stop listening for property changes.
             */
            observeProperty(listener: (newValue: any, oldValue?: any) => void): IRemoveListener {
                var listeners = this._listeners,
                    length = listener.length;

                listeners.push(listener);

                return () => {
                    listeners.splice(length, 1);
                };
            }
        
            /**
             * @name setProperty
             * @memberof plat.ui.BindablePropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * A function that lets this control know when the context's value of the bindable 
             * property has changed.
             * 
             * @param {any} newValue The new value of the bindable property.
             * @param {any} oldValue? The old value of the bindable property.
             * @param {boolean} firstTime? A boolean signifying whether this is the first set of the property.
             * 
             * @returns {void}
             */
            setProperty(newValue: any, oldValue?: any, firstTime?: boolean): void { }
        
            /**
             * @name propertyChanged
             * @memberof plat.ui.BindablePropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * A function that signifies when this control's bindable property has changed.
             * 
             * @param {any} newValue The new value of the property after the change.
             * @param {any} oldValue? The old value of the property prior to the change.
             * 
             * @returns {void}
             */
            propertyChanged(newValue: any, oldValue?: any): void {
                if (newValue === oldValue) {
                    return;
                }

                var listeners = this._listeners,
                    length = listeners.length;

                for (var i = 0; i < length; ++i) {
                    listeners[i](newValue, oldValue);
                }
            }
        
            /**
             * @name dispose
             * @memberof plat.ui.BindablePropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * Removes references to the listeners 
             * defined externally.
             * 
             * @returns {void}
             */
            dispose(): void {
                this._listeners = [];
            }
        }
    
        /**
         * @name IBindablePropertyControl
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.ui.ITemplateControl}
         * 
         * @description
         * Describes an object that allows for the binding of a value to 
         * another listening control.
         */
        export interface IBindablePropertyControl extends ITemplateControl {
            /**
             * @name observeProperty
             * @memberof plat.ui.IBindablePropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * Adds a listener to be called when the bindable property changes.
             * 
             * @param {plat.IPropertyChangedListener} listener The function that acts as a listener.
             * 
             * @returns {plat.IRemoveListener} A function to stop listening for property changes.
             */
            observeProperty(listener: (newValue: any, oldValue?: any) => void): IRemoveListener;

            /**
             * @name setProperty
             * @memberof plat.ui.IBindablePropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * A function that lets this control know when the context's value of the bindable 
             * property has changed.
             * 
             * @param {any} newValue The new value of the bindable property.
             * @param {any} oldValue? The old value of the bindable property.
             * @param {boolean} firstTime? A boolean signifying whether this is the first set of the property.
             * 
             * @returns {void}
             */
            setProperty(newValue: any, oldValue?: any, firstTime?: boolean): void;

            /**
             * @name propertyChanged
             * @memberof plat.ui.IBindablePropertyControl
             * @kind function
             * @access public
             * 
             * @description
             * A function that signifies when this control's bindable property has changed.
             * 
             * @param {any} newValue The new value of the property after the change.
             * @param {any} oldValue? The old value of the property prior to the change.
             * 
             * @returns {void}
             */
            propertyChanged(newValue: any, oldValue?: any): void;
        }

        /**
         * @name BaseViewControl
         * @memberof plat.ui
         * @kind class
         * 
         * @extends {plat.ui.TemplateControl}
         * @implements {plat.ui.IBaseViewControl}
         * 
         * @description
         * A control used in a {@link plat.ui.controls.IBaseport|IBaseport} for simulated page navigation. The 
         * control has navigation events that are called when navigating to and from the control.
         */
        export class BaseViewControl extends TemplateControl implements IBaseViewControl {
            /**
             * @name detach
             * @memberof plat.ui.BaseViewControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Detaches a {@link plat.ui.BaseViewControl|BaseViewControl}. Disposes its children, but does not dispose the 
             * {@link plat.ui.BaseViewControl|BaseViewControl}. Useful for the Navigator when storing the 
             * {@link plat.ui.BaseViewControl|BaseViewControl} in history.
             * 
             * @param {plat.ui.BaseViewControl} control The control to be detached.
             * 
             * @returns {void}
             */
            static detach(control: IBaseViewControl): void {
                TemplateControl.detach(control);
            }

            /**
             * @name dispose
             * @memberof plat.ui.BaseViewControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Recursively disposes a {@link plat.ui.BaseViewControl|BaseViewControl} and its children.
             * 
             * @param {plat.ui.BaseViewControl} control A control to dispose.
             * 
             * @returns {void}
             */
            static dispose(control: IBaseViewControl): void {
                TemplateControl.dispose(control);
            }

            /**
             * @name getInstance
             * @memberof plat.ui.BaseViewControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of a {@link plat.ui.BaseViewControl|BaseViewControl}.
             * 
             * @returns {plat.ui.BaseViewControl} A new {@link plat.ui.BaseViewControl|BaseViewControl} instance.
             */
            static getInstance(): IBaseViewControl {
                return new BaseViewControl();
            }

            /**
             * @name hasOwnContext
             * @memberof plat.ui.BaseViewControl
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Specifies that this control will have its own context, and it should not inherit a context.
             */
            hasOwnContext: boolean = true;

            /**
             * @name navigator
             * @memberof plat.ui.BaseViewControl
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.IBaseNavigator}
             * 
             * @description
             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IBaseViewControl|IBaseViewControls}
             * in a {plat.ui.controls.IBaseport|IBaseport}.
             */
            navigator: navigation.IBaseNavigator;

            /**
             * @name navigatedTo
             * @memberof plat.ui.BaseViewControl
             * @kind function
             * @access public
             * 
             * @description
             * This event is fired when this control has been navigated to.
             * 
             * @param {any} parameter? A navigation parameter sent from the previous 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @returns {void}
             */
            navigatedTo(parameter?: any): void { }

            /**
             * @name navigatingFrom
             * @memberof plat.ui.BaseViewControl
             * @kind function
             * @access public
             * 
             * @description
             * This event is fired when this control is being navigated away from.
             * 
             * @returns {void}
             */
            navigatingFrom(): void { }
        }

        /**
         * The Type for referencing the '$ViewControlFactory' injectable as a dependency.
         */
        export function IBaseViewControlFactory(): IBaseViewControlFactory {
            return BaseViewControl;
        }

        register.injectable(__BaseViewControlFactory, IBaseViewControlFactory, null, __FACTORY);

        /**
         * @name IBaseViewControlFactory
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Creates and manages {@link plat.ui.IBaseViewControl|IBaseViewControls}.
         */
        export interface IBaseViewControlFactory {
            /**
             * @name detach
             * @memberof plat.ui.IBaseViewControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Detaches a {@link plat.ui.BaseViewControl|BaseViewControl}. Disposes its children, but does not dispose the 
             * {@link plat.ui.BaseViewControl|BaseViewControl}. Useful for the Navigator when storing the 
             * {@link plat.ui.BaseViewControl|BaseViewControl} in history.
             * 
             * @param {plat.ui.BaseViewControl} control The control to be detached.
             * 
             * @returns {void}
             */
            detach(control: IBaseViewControl): void;

            /**
             * @name dispose
             * @memberof plat.ui.IBaseViewControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Recursively disposes a {@link plat.ui.BaseViewControl|BaseViewControl} and its children.
             * 
             * @param {plat.ui.BaseViewControl} control A control to dispose.
             * 
             * @returns {void}
             */
            dispose(control: IBaseViewControl): void;

            /**
             * @name getInstance
             * @memberof plat.ui.IBaseViewControlFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of a {@link plat.ui.BaseViewControl|BaseViewControl}.
             * 
             * @returns {plat.ui.BaseViewControl} A new {@link plat.ui.BaseViewControl|BaseViewControl} instance.
             */
            getInstance(): IBaseViewControl;
        }

        /**
         * @name IBaseViewControl
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.ui.ITemplateControl}
         * 
         * @description
         * Describes a control used in a {@link plat.ui.controls.IBaseport|IBaseport} for simulated page navigation. The 
         * control has navigation events that are called when navigating to and from the control.
         */
        export interface IBaseViewControl extends ITemplateControl {
            /**
             * @name hasOwnContext
             * @memberof plat.ui.IBaseViewControl
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Specifies that this control will have its own context, and it should not inherit a context.
             */
            hasOwnContext?: boolean;

            /**
             * @name navigator
             * @memberof plat.ui.IBaseViewControl
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.IBaseNavigator}
             * 
             * @description
             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IBaseViewControl|IBaseViewControls}
             * in a {plat.ui.controls.IBaseport|IBaseport}.
             */
            navigator?: navigation.IBaseNavigator;

            /**
             * @name navigatedTo
             * @memberof plat.ui.IBaseViewControl
             * @kind function
             * @access public
             * 
             * @description
             * This event is fired when this control has been navigated to.
             * 
             * @param {any} parameter? A navigation parameter sent from the previous 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @returns {void}
             */
            navigatedTo? (parameter?: any): void;

            /**
             * @name navigatingFrom
             * @memberof plat.ui.IBaseViewControl
             * @kind function
             * @access public
             * 
             * @description
             * This event is fired when this control is being navigated away from.
             * 
             * @returns {void}
             */
            navigatingFrom? (): void;
        }

        /**
         * @name ViewControl
         * @memberof plat.ui
         * @kind class
         * 
         * @extends {plat.ui.BaseViewControl}
         * @implements {plat.ui.IViewControl}
         * 
         * @description
         * A control used in a {@link plat.ui.controls.Viewport|Viewport} for simulated page navigation. The 
         * control has navigation events that are called when navigating to and from the control.
         */
        export class ViewControl extends BaseViewControl implements IViewControl {
            /**
             * @name navigator
             * @memberof plat.ui.ViewControl
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.INavigatorInstance}
             * 
             * @description
             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IViewControl|IViewControls} 
             * in a {@link plat.ui.controls.Viewport|Viewport}.
             */
            navigator: navigation.INavigatorInstance;
        }

        /**
         * @name IViewControl
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.ui.IBaseViewControl}
         * 
         * @description
         * Describes a control used in a {@link plat.ui.controls.Viewport|Viewport} for simulated page navigation. The 
         * control has navigation events that are called when navigating to and from the control.
         */
        export interface IViewControl extends IBaseViewControl {
            /**
             * @name navigator
             * @memberof plat.ui.IViewControl
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.INavigatorInstance}
             * 
             * @description
             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IViewControl|IViewControls} 
             * in a {@link plat.ui.controls.Viewport|Viewport}.
             */
            navigator?: navigation.INavigatorInstance;
        }

        /**
         * @name WebViewControl
         * @memberof plat.ui
         * @kind class
         * 
         * @extends {plat.ui.BaseViewControl}
         * @implements {plat.ui.IWebViewControl}
         * 
         * @description
         * A control used in a {@link plat.ui.controls.Routeport|Routeport} for simulated page navigation. The 
         * control has navigation events that are called when navigating to and from the control.
         * It also provides functionality for setting the title of a page.
         */
        export class WebViewControl extends BaseViewControl implements IWebViewControl {
            /**
             * @name titleElement
             * @memberof plat.ui.WebViewControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {HTMLTitleElement}
             * 
             * @description
             * The title of the HTML web page.
             */
            static titleElement: HTMLTitleElement;
            /**
             * @name descriptionElement
             * @memberof plat.ui.WebViewControl
             * @kind property
             * @access public
             * @static
             * 
             * @type {HTMLMetaElement}
             * 
             * @description
             * The description meta tag.
             */
            static descriptionElement: HTMLMetaElement;

            /**
             * @name setTitle
             * @memberof plat.ui.WebViewControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Sets the title programmatically and has it reflect in the browser title.
             * 
             * @param {string} title The title to set.
             * 
             * @returns {void}
             */
            static setTitle(title: string): void {
                var element = WebViewControl.titleElement;

                if (!isNode(element)) {
                    var $document = plat.acquire(plat.Document);
                    element = WebViewControl.titleElement = <HTMLTitleElement>$document.head.querySelector('title');

                    if (!isNode(element)) {
                        element = WebViewControl.titleElement = <HTMLTitleElement>$document.head.appendChild($document.createElement('title'));
                    }
                }

                element.textContent = title.replace(/\//g, ' ');
            }

            /**
             * @name setDescription
             * @memberof plat.ui.WebViewControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Sets the meta description programmatically.
             * 
             * @param {string} description The description to set.
             * 
             * @returns {void}
             */
            static setDescription(description: string): void {
                var element = WebViewControl.descriptionElement;

                if (!isNode(element)) {
                    var $document = plat.acquire(plat.Document);
                    element = WebViewControl.descriptionElement = <HTMLMetaElement>$document.head.querySelector('meta[name="description"]');

                    if (!isNode(element)) {
                        element = WebViewControl.descriptionElement =
                            <HTMLMetaElement>$document.head.appendChild($document.createElement('meta'));
                        element.setAttribute('name', 'description');
                    }
                }

                element.setAttribute('content', description.replace(/\//g, ' '));
            }

            /**
             * @name title
             * @memberof plat.ui.WebViewControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The title of the page, corresponds to the textContent of the title element in the HTML head.
             */
            title = '';

            /**
             * @name description
             * @memberof plat.ui.WebViewControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The title of the page, corresponds to the content of the description meta element in the HTML head.
             */
            description = '';

            /**
             * @name navigator
             * @memberof plat.ui.WebViewControl
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.IRoutingNavigator}
             * 
             * @description
             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IWebViewControl|IWebViewControls} 
             * in a {@link plat.ui.controls.Routeport|Routeport}.
             */
            navigator: navigation.IRoutingNavigator;

            /**
             * @name constructor
             * @memberof plat.ui.WebViewControl
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.ui.WebViewControl|WebViewControl}. Sets the page title and description 
             * upon the navigation event occurring.
             * 
             * @returns {plat.ui.WebViewControl} A {@link plat.ui.WebViewControl|WebViewControl} instance.
             */
            constructor() {
                super();
                this.on('navigated', () => {
                    if (isEmpty(this.title)) {
                        this.title = '';
                    }

                    if (isEmpty(this.description)) {
                        this.description = '';
                    }

                    WebViewControl.setTitle(this.title);
                    WebViewControl.setDescription(this.description);
                });
            }

            /**
             * @name setTitle
             * @memberof plat.ui.WebViewControl
             * @kind function
             * @access public
             * 
             * @description
             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its title programmatically and 
             * have it reflect in the browser title.
             * 
             * @param {string} title The title to set.
             * 
             * @returns {void}
             */
            setTitle(title: string): void {
                this.title = title;
                WebViewControl.setTitle(title);
            }

            /**
             * @name setDescription
             * @memberof plat.ui.WebViewControl
             * @kind function
             * @access public
             * 
             * @description
             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its description programmatically and 
             * have it reflect in the browser meta description tag.
             * 
             * @param {string} description The description to set.
             * 
             * @returns {void}
             */
            setDescription(description: string): void {
                this.description = description;
                WebViewControl.setDescription(description);
            }
        }

        /**
         * @name IWebViewControl
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.ui.IBaseViewControl}
         * 
         * @description
         * Defines an object intended to be used inside of a {@link plat.ui.controls.Routeport|Routeport} 
         * to simulate page navigation.
         */
        export interface IWebViewControl extends IBaseViewControl {
            /**
             * @name title
             * @memberof plat.ui.IWebViewControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The title of the page, corresponds to the textContent of the title element in the HTML head.
             */
            title?: string;

            /**
             * @name description
             * @memberof plat.ui.IWebViewControl
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The title of the page, corresponds to the content of the description meta element in the HTML head.
             */
            description?: string;

            /**
             * @name navigator
             * @memberof plat.ui.IWebViewControl
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.IRoutingNavigator}
             * 
             * @description
             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IWebViewControl|IWebViewControls} 
             * in a {@link plat.ui.controls.Routeport|Routeport}.
             */
            navigator?: navigation.IRoutingNavigator;

            /**
             * @name setTitle
             * @memberof plat.ui.IWebViewControl
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its title programmatically and 
             * have it reflect in the browser title.
             * 
             * @param {string} title The title to set.
             * 
             * @returns {void}
             */
            setTitle? (title: string): void;

            /**
             * @name setDescription
             * @memberof plat.ui.IWebViewControl
             * @kind function
             * @access public
             * 
             * @description
             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its description programmatically and 
             * have it reflect in the browser meta description tag.
             * 
             * @param {string} description The description to set.
             * 
             * @returns {void}
             */
            setDescription(description: string): void;
        }

        /**
         * @name Dom
         * @memberof plat.ui
         * @kind class
         * 
         * @implements {plat.ui.IDom}
         * 
         * @description
         * An extensible class dealing with the creation, deletion, and modification 
         * of DOM.
         */
        export class Dom implements IDom {
            /**
             * @name $DomEvents
             * @memberof plat.ui.Dom
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IDomEvents}
             * 
             * @description
             * Reference to the {@link plat.ui.IDomEvents|IDomEvents} injectable.
             */
            $DomEvents: ui.IDomEvents = acquire(__DomEvents);

            /**
             * @name addEventListener
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Node} element The element to add the event listener to.
             * @param {string} type The type of event to listen to.
             * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Node, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event to listen to.
             * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Window, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Node} element The element to add the event listener to.
             * @param {string} type The type of event to listen to.
             * @param {EventListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Node, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event to listen to.
             * @param {EventListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Window, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;
            addEventListener(element: any, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener {
                return this.$DomEvents.addEventListener(element, type, listener, useCapture);
            }

            /**
             * @name appendChildren
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes a Node Array and creates a DocumentFragment and adds the nodes to the Fragment.
             * 
             * @param {Array<Node>} nodeList A Node Array to be appended to the DocumentFragment
             * 
             * @returns {DocumentFragment} A DocumentFragment.
             */
            appendChildren(nodeList: Array<Node>): DocumentFragment;
            /**
             * @name appendChildren
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes a NodeList and creates a DocumentFragment and adds the NodeList to the Fragment.
             * 
             * @param {NodeList} nodeList A NodeList to be appended to the DocumentFragment
             * 
             * @returns {DocumentFragment} A DocumentFragment.
             */
            appendChildren(nodeList: NodeList): DocumentFragment;
            /**
             * @name appendChildren
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes a Node Array and either adds it to the passed in Node,
             * or creates a DocumentFragment and adds the nodes to the
             * Fragment.
             * 
             * @param {NodeList} nodeList A NodeList to be appended to the root/DocumentFragment.
             * @param {Node} root? An optional Node to append the nodeList.
             * 
             * @returns {Node} The root Node or a DocumentFragment.
             */
            appendChildren(nodeList: Array<Node>, root?: Node): Node;
            /**
             * @name appendChildren
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Takes a NodeList and either adds it to the passed in Node,
             * or creates a DocumentFragment and adds the NodeList to the
             * Fragment.
             * 
             * @param {NodeList} nodeList A NodeList to be appended to the root/DocumentFragment.
             * @param {Node} root? An optional Node to append the nodeList.
             * 
             * @returns {Node} The root Node or a DocumentFragment.
             */
            appendChildren(nodeList: NodeList, root?: Node): Node;
            appendChildren(nodeList: any, root?: Node): any {
                return appendChildren(nodeList, root);
            }

            /**
             * @name clearNode
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Clears a DOM Node by removing all of its childNodes.
             * 
             * @param {Node} node The DOM Node to clear.
             * 
             * @returns {void}
             */
            clearNode(node: Node): void {
                return clearNode(node);
            }

            /**
             * @name clearNodeBlock
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Removes all the Nodes in the Array from the parent Node.
             * 
             * @param {Array<Node>} nodeList The Node Array to remove from the parent Node.
             * @param {Node} parent? The parent Node used to remove the nodeList.
             * 
             * @returns {void}
             */
            clearNodeBlock(nodeList: Array<Node>, parent?: Node): void;
            /**
             * @name clearNodeBlock
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Removes all the Nodes in the NodeList from the parent Node.
             * 
             * @param {NodeList} nodeList The NodeList to remove from the parent Node.
             * @param {Node} parent? The parent Node used to remove the nodeList.
             * 
             * @returns {void}
             */
            clearNodeBlock(nodeList: NodeList, parent?: Node): void;
            clearNodeBlock(nodeList: any, parent?: Node): void {
                return clearNodeBlock(nodeList, parent);
            }

            /**
             * @name setInnerHtml
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Sets the innerHTML of a Node. Can take in a Node rather than an Element
             * because it does not use innerHTML on the passed-in Node (it appends its
             * childNodes).
             * 
             * @param {Node} node The Node to set innerHTML.
             * @param {string} html HTML string to be put inside the node.
             * 
             * @returns {Node} The same node passed in, with innerHTML set.
             */
            setInnerHtml(node: Node, html: string): Node {
                return setInnerHtml(node, html);
            }

            /**
             * @name insertBefore
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Inserts a list of Nodes before the designated end Node.
             * 
             * @param {Node} parent The parent node into which to insert nodes.
             * @param {Array<Node>} nodes The Node Array to insert into the parent.
             * @param {Node} endNode? An optional endNode to use to insert nodes.
             * 
             * @returns {Array<Node>} An Array copy of the nodes.
             */
            insertBefore(parent: Node, nodes: Array<Node>, endNode?: Node): Array<Node>;
            /**
             * @name insertBefore
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Inserts a list of Nodes before the designated end Node.
             * 
             * @param {Node} parent The parent node into which to insert nodes.
             * @param {NodeList} nodes The NodeList to insert into the parent.
             * @param {Node} endNode? An optional endNode to use to insert nodes.
             * 
             * @returns {Array<Node>} An Array copy of the nodes.
             */
            insertBefore(parent: Node, nodes: NodeList, endNode?: Node): Array<Node>;
            /**
             * @name insertBefore
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Inserts a DocumentFragment before the designated end Node.
             * 
             * @param {Node} parent The parent node into which to insert nodes.
             * @param {DocumentFragment} fragment The DocumentFragment to insert into the parent.
             * @param {Node} endNode? An optional endNode to use to insert nodes.
             * 
             * @returns {Array<Node>} An Array copy of the fragment's childNodes.
             */
            insertBefore(parent: Node, fragment: DocumentFragment, endNode?: Node): Array<Node>;
            insertBefore(parent: Node, nodes: any, endNode?: Node): Array<Node> {
                return insertBefore(parent, nodes, endNode);
            }

            /**
             * @name replace
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Takes the child nodes of the given node and places them above the node
             * in the DOM. Then removes the given node.
             * 
             * @param {Node} node The Node to replace.
             * 
             * @returns {Array<Node>} A Node Array that represents the childNodes of the
             * given node.
             */
            replace(node: Node): Array<Node> {
                return replace(node);
            }

            /**
             * @name replaceWith
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes the childNodes of the given element and appends them to the newElement.
             * Then replaces the element in its parent's tree with the newElement.
             * 
             * @param {Node} node The Node to remove from its parent.
             * @param {HTMLElement} newElement The HTMLElement to populate with childNodes and add to the
             * element's parent.
             * 
             * @returns {HTMLElement} The replaced element (newElement).
             */
            replaceWith(node: Node, newElement: HTMLElement): HTMLElement;
            /**
             * @name replaceWith
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes the childNodes of the given element and appends them to the newElement.
             * Then replaces the element in its parent's tree with the newElement.
             * 
             * @param {Node} node The Node to remove from its parent.
             * @param {Element} newElement The Element to populate with childNodes and add to the
             * element's parent.
             * 
             * @returns {Element} The replaced element (newElement).
             */
            replaceWith(node: Node, newElement: Element): Element;
            /**
             * @name replaceWith
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes the childNodes of the given element and appends them to the newElement.
             * Then replaces the element in its parent's tree with the newElement.
             * 
             * @param {Node} node The Node to remove from its parent.
             * @param {Node} newElement The Node to populate with childNodes and add to the
             * element's parent.
             * 
             * @returns {Node} The replaced element (newElement).
             */
            replaceWith(node: Node, newNode: Node): Node;
            replaceWith(node: any, newNode: any): any {
                return replaceWith(node, newNode);
            }

            /**
             * @name serializeHtml
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Takes in a string representing innerHTML and returns a DocumentFragment
             * containing the serialized DOM.
             * 
             * @param {string} html The DOM string.
             * 
             * @returns {DocumentFragment} The serialized DOM.
             */
            serializeHtml(html: string): DocumentFragment {
                return serializeHtml(html);
            }

            /**
             * @name removeBetween
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode.  If endNode is not specified,
             * DOM will be removed until the end of the parentNode's children.
             * 
             * @param {Node} startNode The starting node, which will not be removed.
             * @param {Node} endNode The ending node, which will not be removed.
             * 
             * @returns {void}
             */
            removeBetween(startNode: Node, endNode?: Node): void {
                return removeBetween(startNode, endNode);
            }

            /**
             * @name removeAll
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode and endNode as well as
             * the startNode and the endNode.  If endNode is not specified, DOM
             * will be removed until the end of the parentNode's children.
             * 
             * @param {Node} startNode The first node to remove.
             * @param {Node} endNode The last node to remove.
             * 
             * @returns {void}
             */
            removeAll(startNode: Node, endNode?: Node): void {
                return removeAll(startNode, endNode);
            }

            /**
             * @name addClass
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Adds a class to the specified element.
             * 
             * @param {Element} element The element to which the class name is being added.
             * @param {string} className The class name to add to the element.
             * 
             * @returns {void}
             */
            addClass(element: Element, className: string): void {
                return addClass(<HTMLElement>element, className);
            }

            /**
             * @name removeClass
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Removes a class from the specified element.
             * 
             * @param {Element} element The element from which the class name is being removed.
             * @param {string} className The class name to remove from the element.
             * 
             * @returns {void}
             */
            removeClass(element: Element, className: string): void {
                return removeClass(<HTMLElement>element, className);
            }

            /**
             * @name toggleClass
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Toggles a class from the specified element.
             * 
             * @param {Element} element The element on which the class name is being toggled.
             * @param {string} className The class name to toggle on the element.
             * 
             * @returns {void}
             */
            toggleClass(element: Element, className: string): void {
                return toggleClass(<HTMLElement>element, className);
            }

            /**
             * @name hasClass
             * @memberof plat.ui.Dom
             * @kind function
             * @access public
             * 
             * @description
             * Returns whether or not an element has a particular class assigned to it.
             * 
             * @param {Element} element The element on which the class name is being checked.
             * @param {string} className The class name to check on the element.
             * 
             * @returns {void}
             */
            hasClass(element: Element, className: string): boolean {
                return hasClass(<HTMLElement>element, className);
            }
        }

        /**
         * The Type for referencing the '$Dom' injectable as a dependency.
         */
        export function IDom(): IDom {
            return new Dom();
        }

        register.injectable(__Dom, IDom);

        /**
         * @name IDom
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * An object that deals with the creation, deletion, and modification 
         * of DOM.
         */
        export interface IDom {
            /**
             * @name addEventListener
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Node} element The element to add the event listener to.
             * @param {string} type The type of event to listen to.
             * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Node, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event to listen to.
             * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Window, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Node} element The element to add the event listener to.
             * @param {string} type The type of event to listen to.
             * @param {EventListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Node, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Adds an event listener of the specified type to the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event to listen to.
             * @param {EventListener} listener The listener to fire when the event occurs.
             * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase 
             * of event propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added event listener.
             */
            addEventListener(element: Window, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;

            /**
             * @name appendChildren
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes a Node Array and creates a DocumentFragment and adds the nodes to the Fragment.
             * 
             * @param {Array<Node>} nodeList A Node Array to be appended to the DocumentFragment
             * 
             * @returns {DocumentFragment} A DocumentFragment.
             */
            appendChildren(nodeList: Array<Node>): DocumentFragment;
            /**
             * @name appendChildren
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes a NodeList and creates a DocumentFragment and adds the NodeList to the Fragment.
             * 
             * @param {NodeList} nodeList A NodeList to be appended to the DocumentFragment
             * 
             * @returns {DocumentFragment} A DocumentFragment.
             */
            appendChildren(nodeList: NodeList): DocumentFragment;
            /**
             * @name appendChildren
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes a Node Array and either adds it to the passed in Node,
             * or creates a DocumentFragment and adds the nodes to the
             * Fragment.
             * 
             * @param {NodeList} nodeList A NodeList to be appended to the root/DocumentFragment.
             * @param {Node} root? An optional Node to append the nodeList.
             * 
             * @returns {Node} The root Node or a DocumentFragment.
             */
            appendChildren(nodeList: Array<Node>, root?: Node): Node;
            /**
             * @name appendChildren
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Takes a NodeList and either adds it to the passed in Node,
             * or creates a DocumentFragment and adds the NodeList to the
             * Fragment.
             * 
             * @param {NodeList} nodeList A NodeList to be appended to the root/DocumentFragment.
             * @param {Node} root? An optional Node to append the nodeList.
             * 
             * @returns {Node} The root Node or a DocumentFragment.
             */
            appendChildren(nodeList: NodeList, root?: Node): Node;

            /**
             * @name clearNode
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Clears a DOM Node by removing all of its childNodes.
             * 
             * @param {Node} node The DOM Node to clear.
             * 
             * @returns {void}
             */
            clearNode(node: Node): void;

            /**
             * @name clearNodeBlock
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Removes all the Nodes in the Array from the parent Node.
             * 
             * @param {Array<Node>} nodeList The Node Array to remove from the parent Node.
             * @param {Node} parent? The parent Node used to remove the nodeList.
             * 
             * @returns {void}
             */
            clearNodeBlock(nodeList: Array<Node>, parent?: Node): void;
            /**
             * @name clearNodeBlock
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Removes all the Nodes in the NodeList from the parent Node.
             * 
             * @param {NodeList} nodeList The NodeList to remove from the parent Node.
             * @param {Node} parent? The parent Node used to remove the nodeList.
             * 
             * @returns {void}
             */
            clearNodeBlock(nodeList: NodeList, parent?: Node): void;

            /**
             * @name setInnerHtml
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Sets the innerHTML of a Node. Can take in a Node rather than an Element
             * because it does not use innerHTML on the passed-in Node (it appends its
             * childNodes).
             * 
             * @param {Node} node The Node to set innerHTML.
             * @param {string} html HTML string to be put inside the node.
             * 
             * @returns {Node} The same node passed in, with innerHTML set.
             */
            setInnerHtml(node: Node, html: string): Node;

            /**
             * @name insertBefore
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Inserts a list of Nodes before the designated end Node.
             * 
             * @param {Node} parent The parent node into which to insert nodes.
             * @param {Array<Node>} nodes The Node Array to insert into the parent.
             * @param {Node} endNode? An optional endNode to use to insert nodes.
             * 
             * @returns {Array<Node>} An Array copy of the nodes.
             */
            insertBefore(parent: Node, nodes: Array<Node>, endNode?: Node): Array<Node>;
            /**
             * @name insertBefore
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Inserts a list of Nodes before the designated end Node.
             * 
             * @param {Node} parent The parent node into which to insert nodes.
             * @param {NodeList} nodes The NodeList to insert into the parent.
             * @param {Node} endNode? An optional endNode to use to insert nodes.
             * 
             * @returns {Array<Node>} An Array copy of the nodes.
             */
            insertBefore(parent: Node, nodes: NodeList, endNode?: Node): Array<Node>;
            /**
             * @name insertBefore
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Inserts a DocumentFragment before the designated end Node.
             * 
             * @param {Node} parent The parent node into which to insert nodes.
             * @param {DocumentFragment} fragment The DocumentFragment to insert into the parent.
             * @param {Node} endNode? An optional endNode to use to insert nodes.
             * 
             * @returns {Array<Node>} An Array copy of the fragment's childNodes.
             */
            insertBefore(parent: Node, fragment: DocumentFragment, endNode?: Node): Array<Node>;

            /**
             * @name replace
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Takes the child nodes of the given node and places them above the node
             * in the DOM. Then removes the given node.
             * 
             * @param {Node} node The Node to replace.
             * 
             * @returns {Array<Node>} A Node Array that represents the childNodes of the
             * given node.
             */
            replace(node: Node): Array<Node>;

            /**
             * @name replaceWith
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Takes the childNodes of the given element and appends them to the newElement.
             * Then replaces the element in its parent's tree with the newElement.
             * 
             * @param {Node} node The Node to remove from its parent.
             * @param {HTMLElement} newElement The HTMLElement to populate with childNodes and add to the
             * element's parent.
             * 
             * @returns {HTMLElement} The replaced element (newElement).
             */
            replaceWith(node: Node, newElement: HTMLElement): HTMLElement;
            /**
             * @name replaceWith
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Takes the childNodes of the given element and appends them to the newElement.
             * Then replaces the element in its parent's tree with the newElement.
             * 
             * @param {Node} node The Node to remove from its parent.
             * @param {Element} newElement The Element to populate with childNodes and add to the
             * element's parent.
             * 
             * @returns {Element} The replaced element (newElement).
             */
            replaceWith(node: Node, newElement: Element): Element;
            /**
             * @name replaceWith
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Takes the childNodes of the given element and appends them to the newElement.
             * Then replaces the element in its parent's tree with the newElement.
             * 
             * @param {Node} node The Node to remove from its parent.
             * @param {Node} newElement The Node to populate with childNodes and add to the
             * element's parent.
             * 
             * @returns {Node} The replaced element (newElement).
             */
            replaceWith(node: Node, newNode: Node): Node;

            /**
             * @name serializeHtml
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Takes in a string representing innerHTML and returns a DocumentFragment
             * containing the serialized DOM.
             * 
             * @param {string} html The DOM string.
             * 
             * @returns {DocumentFragment} The serialized DOM.
             */
            serializeHtml(html?: string): DocumentFragment;

            /**
             * @name removeBetween
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode.  If endNode is not specified,
             * DOM will be removed until the end of the parentNode's children.
             * 
             * @param {Node} startNode The starting node, which will not be removed.
             * @param {Node} endNode The ending node, which will not be removed.
             * 
             * @returns {void}
             */
            removeBetween(startNode: Node, endNode?: Node): void;

            /**
             * @name removeAll
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode and endNode as well as
             * the startNode and the endNode.  If endNode is not specified, DOM
             * will be removed until the end of the parentNode's children.
             * 
             * @param {Node} startNode The first node to remove.
             * @param {Node} endNode The last node to remove.
             * 
             * @returns {void}
             */
            removeAll(startNode: Node, endNode?: Node): void;

            /**
             * @name addClass
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Adds a class to the specified element.
             * 
             * @param {Element} element The element to which the class name is being added.
             * @param {string} className The class name to add to the element.
             * 
             * @returns {void}
             */
            addClass(element: Element, className: string): void;

            /**
             * @name removeClass
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Removes a class from the specified element.
             * 
             * @param {Element} element The element from which the class name is being removed.
             * @param {string} className The class name to remove from the element.
             * 
             * @returns {void}
             */
            removeClass(element: Element, className: string): void;

            /**
             * @name toggleClass
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Toggles a class from the specified element.
             * 
             * @param {Element} element The element on which the class name is being toggled.
             * @param {string} className The class name to toggle on the element.
             * 
             * @returns {void}
             */
            toggleClass(element: Element, className: string): void;

            /**
             * @name hasClass
             * @memberof plat.ui.IDom
             * @kind function
             * @access public
             * 
             * @description
             * Returns whether or not an element has a particular class assigned to it.
             * 
             * @param {Element} element The element on which the class name is being checked.
             * @param {string} className The class name to check on the element.
             * 
             * @returns {void}
             */
            hasClass(element: Element, className: string): void;
        }

        /**
         * @name ICustomElementProperty
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.IObject<string>}
         * 
         * @description
         * An object describing custom element properties added to elements for hashing purposes.
         */
        export interface ICustomElementProperty extends IObject<string> {
            /**
             * @name domEvent
             * @memberof plat.ui.ICustomElementProperty
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A unique id given to the element if it's registered for a custom DOM event.
             */
            domEvent?: string;

            /**
             * @name animation
             * @memberof plat.ui.ICustomElementProperty
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * A unique id given to the element if it's registered for an animation.
             */
            animation?: string;
        }

        /**
         * @name ICustomElement
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {HTMLElement}
         * 
         * @description
         * An interface for describing an Element with an ICustomElementProperty attached. Primarily 
         * used for element interaction with {@link plat.ui.DomEvents|DomEvents} and the 
         * {@link plat.ui.Animator|Animator}.
         */
        export interface ICustomElement extends HTMLElement {
            /**
             * @name __plat
             * @memberof plat.ui.ICustomElementProperty
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ICustomElementProperty}
             * 
             * @description
             * The PlatypusTS custom element property.
             */
            __plat: ICustomElementProperty;
        }

        /**
         * @name BindableTemplates
         * @memberof plat.ui
         * @kind class
         * 
         * @implements {plat.ui.IBindableTemplates}
         * 
         * @description
         * The class which provides a way for {@link plat.ui.ITemplateControl|ITemplateControls} to bind a template 
         * to a context. Useful for narrowing context without needing another 
         * {@link plat.ui.ITemplateControl|ITemplateControl}. In addition, this object provides a performance increase because 
         * it will only compile the template once. This object is also useful when a 
         * {@link plat.ui.ITemplateControl|ITemplateControls} expects multiple configuration templates in its innerHTML. It can 
         * separate those templates and reuse them accordingly.
         */
        export class BindableTemplates implements IBindableTemplates {
            /**
             * @name create
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is 
             * passed in, it will use the properties on the original BindableTemplates.
             * 
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * containing the new {@link plat.ui.BindableTemplates|BindableTemplates} object, used for data 
             * context inheritance for templates.
             * @param {plat.ui.IBindableTemplates} original? An optional {@link plat.ui.IBindableTemplates|IBindableTemplates} 
             * object to copy.
             * 
             * @returns {plat.ui.IBindableTemplates} The newly instantiated {@link plat.ui.IBindableTemplates|IBindableTemplates} object.
             */
            static create(control: ITemplateControl, original?: IBindableTemplates): IBindableTemplates;
            /**
             * @name create
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is 
             * passed in, it will use the properties on the original BindableTemplates.
             * 
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * containing the new {@link plat.ui.BindableTemplates|BindableTemplates} object, used for data 
             * context inheritance for templates.
             * @param {plat.ui.BindableTemplates} original? An optional {@link plat.ui.BindableTemplates|BindableTemplates} 
             * object to copy.
             * 
             * @returns {plat.ui.IBindableTemplates} The newly instantiated {@link plat.ui.IBindableTemplates|IBindableTemplates} object.
             */
            static create(control: ITemplateControl, original?: BindableTemplates): IBindableTemplates {
                var bindableTemplates = new BindableTemplates();
                bindableTemplates.control = control;

                if (!isNull(original)) {
                    bindableTemplates.templates = original.templates;
                    bindableTemplates._cache = original._cache;
                }

                return bindableTemplates;
            }

            /**
             * @name dispose
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clears the memory being held by control's bindableTemplates.
             * 
             * @static
             * @param {plat.ui.ITemplateControl} control The control whose bindableTemplates will be disposed.
             * 
             * @returns {void}
             */
            static dispose(control: ITemplateControl): void {
                if (isNull(control)) {
                    return;
                }
                var instance = control.bindableTemplates;

                if (isNull(instance) || !isFunction(instance.dispose)) {
                    return;
                }

                instance.dispose();
            }

            /**
             * @name $ResourcesFactory
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IResourcesFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.IResourcesFactory|IResourcesFactory} injectable.
             */
            $ResourcesFactory: IResourcesFactory = acquire(__ResourcesFactory);
            /**
             * @name $TemplateControlFactory
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControlFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.ITemplateControlFactory|ITemplateControlFactory} injectable.
             */
            $TemplateControlFactory: ITemplateControlFactory = acquire(__TemplateControlFactory);
            /**
             * @name $Promise
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.async.IPromise}
             * 
             * @description
             * Reference to the {@link plat.async.IPromise|IPromise} injectable.
             */
            $Promise: async.IPromise = acquire(__Promise);
            /**
             * @name $ManagerCache
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.storage.ICache<processing.IElementManager>}
             * 
             * @description
             * Reference to a cache injectable that stores {@link plat.processing.IElementManager|IElementManagers}.
             */
            $ManagerCache: storage.ICache<processing.IElementManager> = acquire(__ManagerCache);
            /**
             * @name $Document
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {Document}
             * 
             * @description
             * Reference to the Document injectable.
             */
            $Document: Document = acquire(__Document);
            /**
             * @name $ElementManagerFactory
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.processing.IElementManagerFactory}
             * 
             * @description
             * Reference to the {@link plat.processing.IElementManagerFactory|IElementManagerFactory} injectable.
             */
            $ElementManagerFactory: processing.IElementManagerFactory = acquire(__ElementManagerFactory);

            /**
             * @name control
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * The control containing this {@link plat.ui.BindableTemplates|BindableTemplates} object.
             */
            control: ITemplateControl;
            /**
             * @name templates
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.IObject<plat.async.IThenable<DocumentFragment>>}
             * 
             * @description
             * Stores promises that resolve to all the compiled templates for this object, ready to be bound to a data context. 
             * All created templates are DocumentFragments, allowing an {@link plat.ui.ITemplateControl|ITemplateControl} to
             * easily insert the template into the DOM (without iterating over childNodes).
             */
            templates: IObject<async.IThenable<DocumentFragment>> = {};

            /**
             * @name _cache
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access protected
             * 
             * @type {plat.IObject<plat.processing.IElementManager>}
             * 
             * @description
             * A keyed cache of {@link plat.processing.IElementManager|IElementManagers} that represent the roots of compiled templates 
             * created by this instance.
             */
            _cache: IObject<processing.IElementManager> = {};

            /**
             * @name __compiledControls
             * @memberof plat.ui.BindableTemplates
             * @kind property
             * @access private
             * 
             * @type {Array<plat.ui.ITemplateControl>}
             * 
             * @description
             * A collection of all the controls created while compiling an added template. Useful during disposal.
             */
            private __compiledControls: Array<ITemplateControl> = [];

            /**
             * @name bind
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Method for linking a new template to a data context and returning a clone of the template, 
             * with all new {@link plat.IControl|IControls} created if the template contains controls. It is not necessary
             * to specify a data context.
             * 
             * @param {string} key The key used to retrieve the template.
             * @param {string} relativeIdentifier? The identifier string relative to this control's context
             * (e.g. 'foo.bar.baz' would signify the object this.context.foo.bar.baz). This is the 
             * most efficient way of specifying context, else the framework has to search for the 
             * object.
             * @param {plat.IObject<plat.IResource>} resources? An object used as the resources for any top-level 
             * controls created in the template.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves when the template is bound and 
             * ready to return.
             */
            bind(key: string, relativeIdentifier?: string, resources?: IObject<IResource>): async.IThenable<DocumentFragment>;
            /**
             * @name bind
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Method for linking a new template to a data context and returning a clone of the template, 
             * with all new {@link plat.IControl|IControls} created if the template contains controls. It is not necessary
             * to specify a data context.
             * 
             * @param {string} key The key used to retrieve the template.
             * @param {number} relativeIdentifier? The identifier number relative to this control's context
             * (e.g. '1' would signify the object this.context[1]). Only necessary when context is an array.
             * @param {plat.IObject<plat.IResource>} resources? An object used as the resources for any top-level 
             * controls created in the template.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves when the template is bound and 
             * ready to return.
             */
            bind(key: string, relativeIdentifier?: number, resources?: IObject<IResource>): async.IThenable<DocumentFragment>;
            bind(key: any, relativeIdentifier?: any, resources?: IObject<IResource>): async.IThenable<DocumentFragment> {
                var templatePromise = this.templates[key],
                    $exception: IExceptionStatic;

                if (isNull(templatePromise)) {
                    $exception = acquire(__ExceptionStatic);
                    $exception.fatal('Cannot bind template, no template stored with key: ' + key,
                        $exception.TEMPLATE);
                    return;
                }

                if (!(isNull(relativeIdentifier) || isNumber(relativeIdentifier) || isString(relativeIdentifier))) {
                    $exception = acquire(__ExceptionStatic);
                    $exception.warn('Cannot bind template with relativeIdentifier: ' +
                        relativeIdentifier +
                        '. Identifier must be either a string or number', $exception.BIND);
                    return;
                }

                return templatePromise.then((result: DocumentFragment) => {
                    return this._bindTemplate(key, <DocumentFragment>result.cloneNode(true), relativeIdentifier, resources);
                }, (error: any) => {
                    postpone(() => {
                        $exception = acquire(__ExceptionStatic);
                        $exception.fatal(error, $exception.BIND);
                    });

                    return <DocumentFragment>null;
                });
            }

            /**
             * @name add
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {Element} template An Element representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: Element): void;
            /**
             * @name add
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {Array<Node>} template A node Array representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: Array<Node>): void;
            /**
             * @name add
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {NodeList} template A NodeList representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: NodeList): void;
            /**
             * @name add
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {DocumentFragment} template A DocumentFragment representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: DocumentFragment): void;
            /**
             * @name add
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * @variation 4
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {Node} template A Node representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: Node): void;
            add(key: string, template: any): void {
                if (isNull(template)) {
                    return;
                }

                if (isDocumentFragment(template)) {
                    this._compile(key, template);
                    return;
                }

                var fragment = this.$Document.createDocumentFragment();

                if (isNode(template)) {
                    fragment.appendChild(template);
                } else if (isArrayLike(template)) {
                    appendChildren(template, fragment);
                } else {
                    return;
                }

                this._compile(key, fragment);
            }

            /**
             * @name dispose
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access public
             * 
             * @description
             * Clears the memory being held by this instance.
             * 
             * @returns {void}
             */
            dispose(): void {
                var dispose = this.$TemplateControlFactory.dispose,
                    compiledControls = this.__compiledControls,
                    length = compiledControls.length;

                for (var i = 0; i < length; ++i) {
                    dispose(compiledControls[i]);
                }

                this.__compiledControls = [];
                this.control = null;
                this._cache = {};
                this.templates = {};
            }
        
            /**
             * @name _bindTemplate
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access protected
             * 
             * @description
             * Creates the template's bound control and {@link plat.processing.INodeMap|INodeMap} and initiates 
             * the binding of the {@link plat.processing.INodeMap|INodeMap} for a cloned template.
             * 
             * @param {string} key The template key.
             * @param {DocumentFragment} template The cached HTML template.
             * @param {string} contextId The relative path from the context used to bind this template.
             * @param {plat.IObject<plat.ui.IResource>} A set of resources to add to the control used to bind this 
             * template.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves when the template is bound.
             */
            _bindTemplate(key: string, template: DocumentFragment, contextId: string,
                resources: IObject<IResource>): async.IThenable<DocumentFragment> {
                var control = this._createBoundControl(key, template, contextId, resources),
                    nodeMap = this._createNodeMap(control, template, contextId),
                    disposed = false,
                    dispose = control.dispose;

                control.dispose = () => {
                    disposed = true;
                    dispose.call(control);
                    control.dispose = dispose;
                };

                return this._bindNodeMap(nodeMap, key).then(() => {
                    var $document = this.$Document;
                    if (disposed) {
                        return $document.createDocumentFragment();
                    }
                    control.startNode = template.insertBefore($document.createComment(control.type + __START_NODE),
                        template.firstChild);
                    control.endNode = template.insertBefore($document.createComment(control.type + __END_NODE),
                        null);

                    return template;
                }, (error: any) => {
                    postpone(() => {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.fatal(error, $exception.COMPILE);
                    });

                    return <DocumentFragment>null;
                });
            }
        
            /**
             * @name _bindNodeMap
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access protected
             * 
             * @description
             * Clones the compiled {@link plat.processing.IElementManager|IElementManager} using the newly created 
             * {@link plat.processing.INodeMap|INodeMap} and binds and loads this control's 
             * {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @param {plat.processing.INodeMap} nodeMap The node map to bind.
             * @param {string} key The template key used to grab the {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.async.IThenable<void>} A promise that resolves when the control's 
             * {@link plat.processing.IElementManager|IElementManager} is bound and loaded.
             */
            _bindNodeMap(nodeMap: processing.INodeMap, key: string): async.IThenable<void> {
                var manager = this._cache[key],
                    child = nodeMap.uiControlNode.control,
                    template = nodeMap.element,
                    $managerCache = this.$ManagerCache;

                this.control.controls.push(child);

                manager.clone(template, $managerCache.read(this.control.uid), nodeMap);
                return $managerCache.read(child.uid).bindAndLoad();
            }
        
            /**
             * @name _compile
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access protected
             * 
             * @description
             * Creates the template's compiled, bound control and {@link plat.processing.INodeMap|INodeMap} and initiates 
             * the compilation of the template.
             * 
             * @param {string} key The template key.
             * @param {DocumentFragment} template The HTML template being bound.
             * 
             * @returns {void}
             */
            _compile(key: string, template: DocumentFragment): void {
                var control = this._createBoundControl(key + __COMPILED, template),
                    nodeMap = this._createNodeMap(control, template);

                this.__compiledControls.push(control);

                this._compileNodeMap(control, nodeMap, key);
            }
        
            /**
             * @name _compileNodeMap
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access protected
             * 
             * @description
             * Instantiates a new {@link plat.processing.IElementManager|IElementManager} for the root of this 
             * template and resolves any asynchronous url templates within the template being compiled.
             * 
             * @param {plat.ui.ITemplateControl} control The newly created control used to bind the template.
             * @param {plat.processing.INodeMap} nodeMap The newly created node map to bind.
             * @param {string} key The template key.
             * 
             * @returns {void}
             */
            _compileNodeMap(control: ITemplateControl, nodeMap: processing.INodeMap, key: string): void {
                var manager = this.$ElementManagerFactory.getInstance(),
                    promises: Array<async.IThenable<void>> = [];

                manager.isClone = true;
                manager.initialize(nodeMap, null);
                manager.setUiControlTemplate();

                this._cache[key] = manager;

                promises.push(manager.fulfillTemplate());

                this.templates[key] = this.$Promise.all(promises).then(() => {
                    var element = nodeMap.element,
                        startNode: Comment,
                        endNode: Comment;

                    var clone = <DocumentFragment>nodeMap.element.cloneNode(true);

                    startNode = control.startNode = this.$Document.createComment(control.type + __START_NODE);
                    endNode = control.endNode = this.$Document.createComment(control.type + __END_NODE);
                    element.insertBefore(startNode, element.firstChild);
                    element.insertBefore(endNode, null);

                    return clone;
                });
            }
        
            /**
             * @name _createNodeMap
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access protected
             * 
             * @description
             * Creates an {@link plat.processing.INodeMap|INodeMap} for either a template being compiled or a 
             * template being bound.
             * 
             * @param {plat.ui.ITemplateControl} uiControl The newly created control used to bind the template.
             * @param {Node} template The template being compiled.
             * @param {string} childContext? A potential child context string identifier.
             * 
             * @returns {plat.processing.INodeMap} The newly created {@link plat.processing.INodeMap|INodeMap}.
             */
            _createNodeMap(uiControl: ITemplateControl, template: Node, childContext?: string): processing.INodeMap {
                return {
                    element: <HTMLElement>template,
                    attributes: {},
                    nodes: [],
                    childContext: childContext,
                    uiControlNode: {
                        control: uiControl,
                        nodeName: uiControl.type,
                        expressions: [],
                        injector: null
                    }
                };
            }
        
            /**
             * @name _createBoundControl
             * @memberof plat.ui.BindableTemplates
             * @kind function
             * @access protected
             * 
             * @description
             * Creates a {@link plat.ui.ITemplateControl|ITemplateControl} used for binding either a template being compiled 
             * or a template being bound.
             * 
             * @param {string} key The template key.
             * @param {DocumentFragment} template The template being compiled or being bound.
             * @param {string} relativeIdentifier? A potential context string identifier identifying the 
             * object's position off the context.
             * @param {plat.IObject<plat.ui.IResource>} resources? A set of resources to add to the control used to 
             * compile/bind this template.
             * 
             * @returns {plat.ui.ITemplateControl} The newly created {@link plat.ui.ITemplateControl|ITemplateControl}.
             */
            _createBoundControl(key: string, template: DocumentFragment,
                relativeIdentifier?: string, resources?: IObject<IResource>): ITemplateControl {
                var $TemplateControlFactory = this.$TemplateControlFactory,
                    control = $TemplateControlFactory.getInstance(),
                    $ResourcesFactory = this.$ResourcesFactory,
                    parent = this.control;

                var _resources = $ResourcesFactory.getInstance();

                _resources.initialize(control, resources);

                control.resources = _resources;
                $ResourcesFactory.addControlResources(control);

                control.parent = parent;
                control.controls = [];
                control.element = <HTMLElement>template;
                control.type = parent.type + __BOUND_PREFIX + key;

                return control;
            }
        }

        /**
         * The Type for referencing the '$BindableTemplatesFactory' injectable as a dependency.
         */
        export function IBindableTemplatesFactory(): IBindableTemplatesFactory {
            return BindableTemplates;
        }

        register.injectable(__BindableTemplatesFactory, IBindableTemplatesFactory, null, __FACTORY);

        /**
         * @name IBindableTemplatesFactory
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Creates and manages {@link plat.ui.IBindableTemplates|IBindableTemplates}.
         */
        export interface IBindableTemplatesFactory {
            /**
             * @name create
             * @memberof plat.ui.IBindableTemplatesFactory
             * @kind function
             * @access public
             * @static
             * @variation 0
             * 
             * @description
             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is 
             * passed in, it will use the properties on the original BindableTemplates.
             * 
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * containing the new {@link plat.ui.BindableTemplates|BindableTemplates} object, used for data 
             * context inheritance for templates.
             * @param {plat.ui.IBindableTemplates} original? An optional {@link plat.ui.IBindableTemplates|IBindableTemplates} 
             * object to copy.
             * 
             * @returns {plat.ui.IBindableTemplates} The newly instantiated {@link plat.ui.IBindableTemplates|IBindableTemplates} object.
             */
            create(control: ITemplateControl, original?: IBindableTemplates): IBindableTemplates;
            /**
             * @name create
             * @memberof plat.ui.IBindableTemplatesFactory
             * @kind function
             * @access public
             * @static
             * @variation 1
             * 
             * @description
             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is 
             * passed in, it will use the properties on the original BindableTemplates.
             * 
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * containing the new {@link plat.ui.BindableTemplates|BindableTemplates} object, used for data 
             * context inheritance for templates.
             * @param {plat.ui.BindableTemplates} original? An optional {@link plat.ui.BindableTemplates|BindableTemplates} 
             * object to copy.
             * 
             * @returns {plat.ui.IBindableTemplates} The newly instantiated {@link plat.ui.IBindableTemplates|IBindableTemplates} object.
             */
            create(control: ITemplateControl, original?: BindableTemplates): IBindableTemplates;

            /**
             * @name dispose
             * @memberof plat.ui.IBindableTemplatesFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clears the memory being held by control's bindableTemplates.
             * 
             * @static
             * @param {plat.ui.ITemplateControl} control The control whose bindableTemplates will be disposed.
             * 
             * @returns {void}
             */
            dispose(control: ITemplateControl): void;
        }

        /**
         * @name IBindableTemplates
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * An object that provides a way for {@link plat.ui.ITemplateControl|ITemplateControls} to bind a template 
         * to a context. Useful for narrowing context without needing another 
         * {@link plat.ui.ITemplateControl|ITemplateControl}. In addition, this object provides a performance increase because 
         * it will only compile the template once. This object is also useful when a 
         * {@link plat.ui.ITemplateControl|ITemplateControls} expects multiple configuration templates in its innerHTML. It can 
         * separate those templates and reuse them accordingly.
         */
        export interface IBindableTemplates {
            /**
             * @name control
             * @memberof plat.ui.IBindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * The control containing this {@link plat.ui.BindableTemplates|BindableTemplates} object.
             */
            control: ITemplateControl;

            /**
             * @name templates
             * @memberof plat.ui.IBindableTemplates
             * @kind property
             * @access public
             * 
             * @type {plat.IObject<plat.async.IThenable<DocumentFragment>>}
             * 
             * @description
             * Stores promises that resolve to all the compiled templates for this object, ready to be bound to a data context. 
             * All created templates are DocumentFragments, allowing an {@link plat.ui.ITemplateControl|ITemplateControl} to
             * easily insert the template into the DOM (without iterating over childNodes).
             */
            templates: IObject<async.IThenable<DocumentFragment>>;

            /**
             * @name bind
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Method for linking a new template to a data context and returning a clone of the template, 
             * with all new {@link plat.IControl|IControls} created if the template contains controls. It is not necessary
             * to specify a data context.
             * 
             * @param {string} key The key used to retrieve the template.
             * @param {string} relativeIdentifier? The identifier string relative to this control's context
             * (e.g. 'foo.bar.baz' would signify the object this.context.foo.bar.baz). This is the 
             * most efficient way of specifying context, else the framework has to search for the 
             * object.
             * @param {plat.IObject<plat.IResource>} resources? An object used as the resources for any top-level 
             * controls created in the template.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves when the template is bound and 
             * ready to return.
             */
            bind(key: string, relativeIdentifier?: string,
                resources?: IObject<IResource>): async.IThenable<DocumentFragment>;
            /**
             * @name bind
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Method for linking a new template to a data context and returning a clone of the template, 
             * with all new {@link plat.IControl|IControls} created if the template contains controls. It is not necessary
             * to specify a data context.
             * 
             * @param {string} key The key used to retrieve the template.
             * @param {number} relativeIdentifier? The identifier number relative to this control's context
             * (e.g. '1' would signify the object this.context[1]). Only necessary when context is an array.
             * @param {plat.IObject<plat.IResource>} resources? An object used as the resources for any top-level 
             * controls created in the template.
             * 
             * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves when the template is bound and 
             * ready to return.
             */
            bind(key: string, relativeIdentifier?: number,
                resources?: IObject<IResource>): async.IThenable<DocumentFragment>;

            /**
             * @name add
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {Element} template An Element representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: Element): void;
            /**
             * @name add
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {Array<Node>} template A node Array representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: Array<Node>): void;
            /**
             * @name add
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {NodeList} template A NodeList representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: NodeList): void;
            /**
             * @name add
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {DocumentFragment} template A DocumentFragment representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: DocumentFragment): void;
            /**
             * @name add
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * @variation 4
             * 
             * @description
             * Adds a template to this object. The template will be stored with the key,
             * and it will be transformed into a DocumentFragment.
             * 
             * @param {string} key The key used to store the template.
             * @param {Node} template A Node representing the DOM template.
             * 
             * @returns {void}
             */
            add(key: string, template: Node): void;

            /**
             * @name dispose
             * @memberof plat.ui.IBindableTemplates
             * @kind function
             * @access public
             * 
             * @description
             * Clears the memory being held by this instance.
             * 
             * @returns {void}
             */
            dispose(): void;
        }

        /**
         * @name Attributes
         * @memberof plat.ui
         * @kind class
         * 
         * @implements {plat.ui.IAttributesInstance}
         * 
         * @description
         * The class that stores the information about an Element's attributes (NamedNodeMap).
         * Methods are implemented to allow you to observe for changes on an attribute.
         * 
         * @remarks
         * Attributes for this object are converted from dash-notation to camelCase notation.
         */
        export class Attributes implements IAttributesInstance {
            /**
             * @name __listeners
             * @memberof plat.ui.Attributes
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<Array<plat.IPropertyChangedListener>>}
             * 
             * @description
             * The set of functions added externally that listens 
             * for attribute changes.
             */
            private __listeners: IObject<Array<(newValue: any, oldValue?: any) => void>> = {};
            /**
             * @name __control
             * @memberof plat.ui.Attributes
             * @kind property
             * @access private
             * 
             * @type {plat.IControl}
             * 
             * @description
             * The control tied to this instance.
             */
            private __control: IControl;

            /**
             * @name initialize
             * @memberof plat.ui.Attributes
             * @kind function
             * @access public
             * 
             * @description
             * Initializes this instance with a {@link plat.IControl|IControl} and the camelCased 
             * attribute properties and their values.
             * 
             * @param {plat.IControl} control The function that acts as a listener.
             * @param {plat.IObject<string>} attributes The camelCased attribute properties and their values.
             * 
             * @returns {void}
             */
            initialize(control: IControl, attributes: IObject<string>): void {
                this.__control = control;

                var keys = Object.keys(attributes),
                    attributeListeners = this.__listeners,
                    key: string,
                    length = keys.length;

                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    (<any>this)[key] = attributes[key];
                    attributeListeners[key] = [];
                }
            }

            /**
             * @name observe
             * @memberof plat.ui.Attributes
             * @kind function
             * @access public
             * 
             * @description
             * Provides a way to observe an attribute for changes.
             * 
             * @param {string} key The attribute to observe for changes (e.g. 'src').
             * @param {plat.IPropertyChangedListener} listener The listener function to be called when the attribute changes.
             * 
             * @returns {plat.IRemoveListener} A function to stop observing this attribute for changes.
             */
            observe(key: string, listener: (newValue: any, oldValue?: any) => void): IRemoveListener {
                var listeners = this.__listeners[camelCase(key)];

                if (isNull(listeners)) {
                    return noop;
                }

                var length = listeners.length;

                listeners.push(listener);

                return () => {
                    listeners.splice(length, 1);
                };
            }
        
            /**
             * @name _attributeChanged
             * @memberof plat.ui.Attributes
             * @kind function
             * @access protected
             * 
             * @description
             * Used to show an attribute has been changed and forces listeners to be fired.
             * 
             * @param {string} key The attribute being observed for changes (e.g. 'src').
             * @param {any} newValue The new value of the attribute.
             * @param {any} oldValue The previous value of the attribute.
             * 
             * @returns {void}
             */
            _attributeChanged(key: string, newValue: any, oldValue: any): void {
                var control = this.__control,
                    listeners = this.__listeners[camelCase(key)],
                    length = listeners.length;

                for (var i = 0; i < length; ++i) {
                    listeners[i].call(control, newValue, oldValue);
                }
            }
        }

        /**
         * The Type for referencing the '$Attributes' injectable as a dependency.
         */
        export function IAttributesInstance(): IAttributesInstance {
            return new Attributes();
        }

        register.injectable(__AttributesInstance, IAttributesInstance, null, __INSTANCE);
    
        /**
         * @name IAttributesInstance
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object that stores the information about an Element's attribute NamedNodeMap.
         * Methods are implemented to allow you to observe for changes on an attribute.
         */
        export interface IAttributesInstance {
            /**
             * @name initialize
             * @memberof plat.ui.IAttributesInstance
             * @kind function
             * @access public
             * 
             * @description
             * Initializes this instance with a {@link plat.IControl|IControl} and the camelCased 
             * attribute properties and their values.
             * 
             * @param {plat.IControl} control The function that acts as a listener.
             * @param {plat.IObject<string>} attributes The camelCased attribute properties and their values.
             * 
             * @returns {void}
             */
            initialize(control: IControl, attributes: IObject<string>): void;

            /**
             * @name observe
             * @memberof plat.ui.IAttributesInstance
             * @kind function
             * @access public
             * 
             * @description
             * Provides a way to observe an attribute for changes.
             * 
             * @param {string} key The attribute to observe for changes (e.g. 'src').
             * @param {plat.IPropertyChangedListener} listener The listener function to be called when the attribute changes.
             * 
             * @returns {plat.IRemoveListener} A function to stop observing this attribute for changes.
             */
            observe(key: string, listener: (newValue: any, oldValue: any) => void): IRemoveListener;
        }

        /**
         * @name Resources
         * @memberof plat.ui
         * @kind class
         * 
         * @implements {plat.ui.IResources}
         * 
         * @description
         * Resources are used for providing aliases to use in markup expressions. They 
         * are particularly useful when trying to access properties outside of the 
         * current context, as well as reassigning context at any point in an app.
         * 
         * @remarks
         * By default, every control has a resource for '@control' and '@context'.
         * {@link plat.ui.IViewControl|IViewControl} objects also have a resource for '@root' and '@rootContext', 
         * which is a reference to the control and its context.
         * 
         * Resources can be created in HTML, or through the exposed control.resources 
         * object. If specified in HTML, they must be the first element child of the 
         * control upon which the resources will be placed. IViewControls that use a 
         * templateUrl can have resources as their first element in the templateUrl.
         * 
         * In the provided example, the resources can be accessed by using '@Cache' and '@testObj'.
         * The type of resource is denoted by the element name.
         * 
         * Only resources of type 'observable' will have data binding. The types of resources are:
         * function, injectable, observable, and object. Resources of type 'function' will have their
         * associated function context bound to the control that contains the resource.
         * 
         * When an alias is found in a markup expression, the framework will search up the control chain 
         * to find the alias on a control's resources. This first matching alias will be used.
         * 
         * @example 
         * <custom-control>
         *     <plat-resources>
         *         <injectable alias="Cache">$CacheFactory</injectable>
         *         <observable alias="testObj">
         *              { 
         *                  foo: 'foo', 
         *                  bar: 'bar', 
         *                  baz: 2 
         *              }
         *         </observable>
         *     </plat-resources>
         * </custom-control>
         */
        export class Resources implements IResources {
            /**
             * @name $ContextManagerStatic
             * @memberof plat.ui.Resources
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.observable.IContextManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
             */
            static $ContextManagerStatic: observable.IContextManagerStatic;
            /**
             * @name $Regex
             * @memberof plat.ui.Resources
             * @kind property
             * @access public
             * 
             * @type {plat.expressions.IRegex}
             * 
             * @description
             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.
             */
            static $Regex: expressions.IRegex;

            /**
             * @name create
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Populates an {@link plat.ui.IResource|IResource} value if necessary, and adds it to the given 
             * control's resources.
             * 
             * @param {plat.ui.ITemplateControl} control The control for which to create a resource.
             * @param {plat.ui.IResource} resource The object used to set the resource values.
             * 
             * @returns {plat.ui.IResource} The newly created {@link plat.ui.IResource|IResource}.
             */
            static create(control: ITemplateControl, resource: IResource): IResource {
                if (isNull(resource)) {
                    return resource;
                }

                var value: any;

                switch (resource.type.toLowerCase()) {
                    case 'injectable':
                        var injector = injectableInjectors[resource.value];
                        if (!isNull(injector)) {
                            resource.value = injector.inject();
                        }
                        break;
                    case 'observable':
                        Resources._observeResource(control, resource);
                        break;
                    case 'object':
                        value = resource.value;
                        if (isString(value)) {
                            resource.value = control.evaluateExpression(value);
                        }
                        break;
                    case 'function':
                        value = resource.value;
                        if (isString(value)) {
                            value = (<any>control)[value];
                            if (isFunction(value)) {
                                resource.value = value.bind(control);
                            } else {
                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                                $exception.warn('Attempted to create a "function" ' +
                                    'type Resource with a function not found on your control.',
                                    $exception.BIND);
                                resource.value = noop;
                            }
                        }
                        break;
                }

                return resource;
            }

            /**
             * @name addControlResources
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Adds resource aliases for '@control' and '@context'. The resources are 
             * aliases for the control instance and the control.context.
             * 
             * @param {plat.ui.ITemplateControl} control The control on which to add the resources.
             * 
             * @returns {void}
             */
            static addControlResources(control: ITemplateControl): void {
                control.resources.add({
                    context: {
                        value: control.context,
                        type: 'observable'
                    },
                    control: {
                        value: control,
                        type: 'object'
                    }
                });

                if (control.hasOwnContext) {
                    Resources.__addRoot(<IViewControl>control);
                }
            }

            /**
             * @name bindResources
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Binds the resources in a resource instance. This involves injecting 
             * the injectable resources, creating object/observable resources, and
             * binding functions to the associated control's instance.
             * 
             * @param {plat.ui.IResources} resourcesInstance The instance of the 
             * {@link plat.ui.IResources|IResources} object to bind.
             * 
             * @returns {void}
             */
            static bindResources(resourcesInstance: IResources): void;
            static bindResources(resourcesInstance: Resources): void {
                var resources = resourcesInstance.__resources;
                if (isNull(resources)) {
                    return;
                }

                var control = resourcesInstance.__controlInstance,
                    aliases = Object.keys(resources),
                    controlResources = Resources.__controlResources,
                    length = aliases.length,
                    alias: string;

                for (var i = 0; i < length; ++i) {
                    alias = aliases[i];

                    if (controlResources.indexOf(alias) !== -1) {
                        continue;
                    }

                    (<any>resourcesInstance)[alias] = resources[alias] = Resources.create(control,
                        (<any>resourcesInstance)[alias]);
                }

                resourcesInstance.__bound = true;
            }

            /**
             * @name dispose
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Disposes a resource instance, removing its reference 
             * from a control and breaking references to all resource 
             * objects.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose resources will be disposed.
             * @param {boolean} persist? Whether or not to persist a resource object post 
             * disposal or set it to null.
             * 
             * @returns {void}
             */
            static dispose(control: ITemplateControl, persist?: boolean): void {
                var resources = <Resources>control.resources;

                if (isNull(resources)) {
                    return;
                }

                var keys = Object.keys(resources.__resources),
                    key: string,
                    length = keys.length,
                    define = Resources.$ContextManagerStatic.defineProperty,
                    resource: IResource;

                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    resource = (<any>resources)[key];

                    if (!isNull(resource) && resource.type === 'observable') {
                        define(resources, key, persist ? _clone(resource, true) : null, true, true);
                    }
                }

                Resources._removeListeners(resources.__controlInstance);
            }

            /**
             * @name parseElement
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Parses a resources Element (<plat-resources>) and creates 
             * an {@link plat.IObject<plat.ui.IResource>|IObject<IResource>} with its element children.
             * 
             * @param {Element} element The resources element to parse.
             * 
             * @returns {plat.IObject<plat.ui.IResource>} The resources created using the input element.
             */
            static parseElement(element: Element): IObject<IResource> {
                var children: Array<Element> = Array.prototype.slice.call((<HTMLElement>element).children),
                    child: Element,
                    $regex = Resources.$Regex,
                    whiteSpaceRegex = $regex.whiteSpaceRegex,
                    quotationRegex = $regex.quotationRegex,
                    resources: IObject<IResource> = {},
                    resource: IResource,
                    types = Resources.__resourceTypes,
                    attrs: NamedNodeMap,
                    attr: Attr,
                    nodeName: string,
                    text: string;

                while (children.length > 0) {
                    child = children.pop();
                    nodeName = child.nodeName.toLowerCase();

                    if (types.indexOf(nodeName) === -1) {
                        continue;
                    }

                    attrs = child.attributes;
                    resource = <IResource>{};

                    attr = attrs.getNamedItem('alias');
                    if (isNull(attr)) {
                        continue;
                    }
                    resource.alias = attr.value;

                    text = child.textContent.replace(whiteSpaceRegex, '$1');
                    if (isEmpty(text)) {
                        continue;
                    }
                    resource.value = (nodeName === 'injectable') ?
                        text.replace(quotationRegex, '') : text;

                    resource.type = nodeName;
                    resources[resource.alias] = resource;
                }

                return resources;
            }

            /**
             * @name getInstance
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance with type {@link plat.ui.IResources|IResources}.
             * 
             * @returns {plat.ui.IResources} A new {@link plat.ui.Resources|Resources} instance.
             */
            static getInstance(): IResources {
                return new Resources();
            }

            /**
             * @name _observeResource
             * @memberof plat.ui.Resources
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Observes the resource if the type is 'observable'.
             * 
             * @param {plat.ui.ITemplateControl} control The control in charge of the observable resource.
             * @param {plat.ui.IResource} resource The resource to observe.
             * 
             * @returns {void}
             */
            static _observeResource(control: ITemplateControl, resource: IResource): void {
                var value = resource.value,
                    uid = control.uid,
                    removeListeners = Resources.__observableResourceRemoveListeners[uid];

                if (isNull(removeListeners)) {
                    removeListeners = Resources.__observableResourceRemoveListeners[uid] = [];
                }

                if (isString(value)) {
                    if (!isNull(resource.initialValue)) {
                        value = resource.initialValue;
                    } else {
                        resource.initialValue = value;
                    }
                    var listener = control.observeExpression(value, (newValue) => {
                        resource.value = newValue;
                    });
                    resource.value = control.evaluateExpression(value);
                    removeListeners.push(listener);
                }
            }

            /**
             * @name _removeListeners
             * @memberof plat.ui.Resources
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Removes observable resource listeners for a specified control.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose listeners are being removed.
             * 
             * @returns {void}
             */
            static _removeListeners(control: ITemplateControl): void {
                if (isNull(control)) {
                    return;
                }

                var uid = control.uid,
                    removeListeners = Resources.__observableResourceRemoveListeners[uid];

                if (isArray(removeListeners)) {
                    var length = removeListeners.length;

                    for (var i = 0; i < length; ++i) {
                        removeListeners[i]();
                    }
                }

                deleteProperty(Resources.__observableResourceRemoveListeners, uid);
            }

            /**
             * @name __controlResources
             * @memberof plat.ui.Resources
             * @kind property
             * @access private
             * @static
             * 
             * @type {Array<string>}
             * 
             * @description
             * A list of resources to place on a control.
             */
            private static __controlResources = ['control', 'context', 'root', 'rootContext'];
            /**
             * @name __resourceTypes
             * @memberof plat.ui.Resources
             * @kind property
             * @access private
             * @static
             * 
             * @type {Array<string>}
             * 
             * @description
             * A list of all resource types.
             */
            private static __resourceTypes = ['injectable', 'object', 'observable', 'function'];
            /**
             * @name __observableResourceRemoveListeners
             * @memberof plat.ui.Resources
             * @kind property
             * @access private
             * @static
             * 
             * @type {plat.IObject<Array<plat.IRemoveListener>>}
             * 
             * @description
             * An object consisting of keyed arrays containing functions for removing observation listeners.
             */
            private static __observableResourceRemoveListeners: IObject<Array<IRemoveListener>> = {};

            /**
             * @name __addRoot
             * @memberof plat.ui.Resources
             * @kind function
             * @access private
             * @static
             * 
             * @description
             * Adds a '@root' alias and '@rootContext' to a control, specifying that it contains the root 
             * and root context. Root controls are generally the root {@link plat.ui.IViewControl|IViewControl}.
             * 
             * @param {plat.ui.ITemplateControl} control The root control.
             * 
             * @returns {void}
             */
            private static __addRoot(control: ITemplateControl): void {
                control.resources.add({
                    root: {
                        value: control,
                        type: 'object',
                        alias: 'root'
                    },
                    rootContext: {
                        value: control.context,
                        type: 'observable',
                        alias: 'rootContext'
                    }
                });
            }

            /**
             * @name __resources
             * @memberof plat.ui.Resources
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<plat.ui.IResource>}
             * 
             * @description
             * An object representing all of the currently available resources.
             */
            private __resources: IObject<IResource> = {};
            /**
             * @name __bound
             * @memberof plat.ui.Resources
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether this {@link plat.ui.Resources|Resources} instance has been bound yet.
             */
            private __bound: boolean = false;
            /**
             * @name __controlInstance
             * @memberof plat.ui.Resources
             * @kind property
             * @access private
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * The control that these resources are for.
             */
            private __controlInstance: ITemplateControl;

            /**
             * @name initialize
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Initializes this {@link plat.ui.Resources|Resources} instance.
             * 
             * @param {plat.ui.ITemplateControl} control The control containing this {@link plat.ui.Resources|Resources} instance.
             * @param {Element} element? An optional element used to create initial {@link plat.ui.IResource|IResource} objects.
             * 
             * @returns {void}
             */
            initialize(control: ITemplateControl, element?: Element): void;
            /**
             * @name initialize
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Initializes this {@link plat.ui.Resources|Resources} instance.
             * 
             * @param {plat.ui.ITemplateControl} control The control containing this {@link plat.ui.Resources|Resources} instance.
             * @param {IObject<IResource>} resources? An optional object used to populate initial
             * {@link plat.ui.IResource|IResource} objects.
             * 
             * @returns {void}
             */
            initialize(control: ITemplateControl, resources?: IObject<IResource>): void;
            /**
             * @name initialize
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Initializes this {@link plat.ui.Resources|Resources} instance.
             * 
             * @param {plat.ui.ITemplateControl} control The control containing this {@link plat.ui.Resources|Resources} instance.
             * @param {plat.ui.IResources} resources? An optional {@link plat.ui.IResources|IResources} object used to populate initial 
             * {@link plat.ui.IResource|IResource} objects.
             * 
             * @returns {void}
             */
            initialize(control: ITemplateControl, resources?: IResources): void;
            initialize(controlInstance: ITemplateControl, resources?: any): void {
                this.__controlInstance = controlInstance;

                if (isNull(resources)) {
                    return;
                } else if (isNode(resources)) {
                    resources = Resources.parseElement(resources);
                } else if (isObject(resources.resources)) {
                    resources = resources.resources;
                }

                this.__resources = resources;

                var keys = Object.keys(resources),
                    key: string,
                    length = keys.length;

                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    (<any>this)[key] = resources[key];
                }
            }

            /**
             * @name add
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Used for programatically adding {@link plat.ui.IResource|IResource} objects.
             * 
             * @param resources An {@link plat.IObject<plat.ui.IResource>|IObject<IResource>} used to add 
             * resources, keyed by their alias.
             * 
             * @returns {void}
             * 
             * @example 
             * control.resources.add({
             *     myAlias: {
             *         type: 'observable',
             *         value: { 
             *             hello: 'Hello World!'
             *         } 
             *     }
             * });
             */
            add(resources: IObject<IResource>): void;
            /**
             * @name add
             * @memberof plat.ui.Resources
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Used for programatically adding {@link plat.ui.IResource|IResource} objects.
             * 
             * @param {Element} element An Element containing resource element children.
             * 
             * @returns {void}
             * 
             * @remarks
             * The resource type is specified by the element name.
             * 
             * @example
             *     <plat-resources>
             *         <injectable alias="Cache">$CacheFactory</injectable>
             *         <observable alias="testObj">{ foo: 'foo', bar: 'bar', baz: 2 }</observable>
             *     </plat-resources>
             */
            add(element: Element): void;
            add(resources: any): void {
                if (isNull(resources)) {
                    return;
                } else if (isNode(resources)) {
                    resources = Resources.parseElement(resources);
                }

                var keys = Object.keys(resources),
                    length = keys.length,
                    resource: IResource,
                    control = this.__controlInstance,
                    bound = this.__bound,
                    key: string,
                    create = Resources.create;

                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    resource = resources[key];
                    resource.alias = key;

                    (<any>this)[key] = this.__resources[key] = bound ? create(control, resource) : resource;
                }
            }
        }

        /**
         * The Type for referencing the '$ResourcesFactory' injectable as a dependency.
         */
        export function IResourcesFactory(
            $ContextManagerStatic?: observable.IContextManagerStatic,
            $Regex?: expressions.IRegex): IResourcesFactory {
                Resources.$ContextManagerStatic = $ContextManagerStatic;
                Resources.$Regex = $Regex;
                return Resources;
        }

        register.injectable(__ResourcesFactory, IResourcesFactory, [
            __ContextManagerStatic,
            __Regex
        ], __FACTORY);

        /**
         * @name IResourcesFactory
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Creates and manages {@link plat.ui.IResources|IResources} for {@link plat.ui.ITemplateControl|ITemplateControls}.
         */
        export interface IResourcesFactory {
            /**
             * @name create
             * @memberof plat.ui.IResourcesFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Populates an {@link plat.ui.IResource|IResource} value if necessary, and adds it to the given 
             * control's resources.
             * 
             * @param {plat.ui.ITemplateControl} control The control for which to create a resource.
             * @param {plat.ui.IResource} resource The object used to set the resource values.
             * 
             * @returns {plat.ui.IResource} The newly created {@link plat.ui.IResource|IResource}.
             */
            create(control: ITemplateControl, resource: IResource): IResource;

            /**
             * @name addControlResources
             * @memberof plat.ui.IResourcesFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Adds resource aliases for '@control' and '@context'. The resources are 
             * aliases for the control instance and the control.context.
             * 
             * @param {plat.ui.ITemplateControl} control The control on which to add the resources.
             * 
             * @returns {void}
             */
            addControlResources(control: ITemplateControl): void;

            /**
             * @name bindResources
             * @memberof plat.ui.IResourcesFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Binds the resources in a resource instance. This involves injecting 
             * the injectable resources, creating object/observable resources, and
             * binding functions to the associated control's instance.
             * 
             * @param {plat.ui.IResources} resourcesInstance The instance of the IResources object.
             * 
             * @returns {void}
             */
            bindResources(resourcesInstance: IResources): void;

            /**
             * @name dispose
             * @memberof plat.ui.IResourcesFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Disposes a resource instance, removing its reference 
             * from a control and breaking references to all resource 
             * objects.
             * 
             * @param {plat.ui.ITemplateControl} control The control whose resources will be disposed.
             * @param {boolean} persist? Whether or not to persist a resource object post 
             * disposal or set it to null.
             * 
             * @returns {void}
             */
            dispose(control: ITemplateControl, persist?: boolean): void;

            /**
             * @name parseElement
             * @memberof plat.ui.IResourcesFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Parses a resources Element (<plat-resources>) and creates 
             * an {@link plat.IObject<plat.ui.IResource>|IObject<IResource>} with its element children.
             * 
             * @param {Element} element The resources element to parse.
             * 
             * @returns {plat.IObject<plat.ui.IResource>} The resources created using the input element.
             */
            parseElement(element: Element): IObject<IResource>;

            /**
             * @name getInstance
             * @memberof plat.ui.IResourcesFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance with type {@link plat.ui.IResources|IResources}.
             * 
             * @returns {plat.ui.IResources} A new {@link plat.ui.Resources|Resources} instance.
             */
            getInstance(): IResources;
        }

        /**
         * @name IResources
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Resources are used for providing aliases to use in markup expressions. They 
         * are particularly useful when trying to access properties outside of the 
         * current context, as well as reassigning context at any point in an app.
         * 
         * @remarks
         * By default, every control has a resource for '@control' and '@context'.
         * {@link plat.ui.IViewControl|IViewControl} objects also have a resource for '@root' and '@rootContext', 
         * which is a reference to the control and its context.
         * 
         * Resources can be created in HTML, or through the exposed control.resources 
         * object. If specified in HTML, they must be the first element child of the 
         * control upon which the resources will be placed. IViewControls that use a 
         * templateUrl can have resources as their first element in the templateUrl.
         * 
         * In the provided example, the resources can be accessed by using '@Cache' and '@testObj'.
         * The type of resource is denoted by the element name.
         * 
         * Only resources of type 'observable' will have data binding. The types of resources are:
         * function, injectable, observable, and object. Resources of type 'function' will have their
         * associated function context bound to the control that contains the resource.
         * 
         * When an alias is found in a markup expression, the framework will search up the control chain 
         * to find the alias on a control's resources. This first matching alias will be used.
         * 
         * @example 
         * <custom-control>
         *     <plat-resources>
         *         <injectable alias="Cache">$CacheFactory</injectable>
         *         <observable alias="testObj">
         *              { 
         *                  foo: 'foo', 
         *                  bar: 'bar', 
         *                  baz: 2 
         *              }
         *         </observable>
         *     </plat-resources>
         * </custom-control>
         */
        export interface IResources {
            /**
             * @name add
             * @memberof plat.ui.IResources
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Used for programatically adding {@link plat.ui.IResource|IResource} objects.
             * 
             * @param resources An {@link plat.IObject<plat.ui.IResource>|IObject<IResource>} used to add 
             * resources, keyed by their alias.
             * 
             * @returns {void}
             * 
             * @example 
             * control.resources.add({
             *     myAlias: {
             *         type: 'observable',
             *         value: { 
             *             hello: 'Hello World!'
             *         } 
             *     }
             * });
             */
            add(resources: IObject<IResource>): void;
            /**
             * @name add
             * @memberof plat.ui.IResources
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Used for programatically adding {@link plat.ui.IResource|IResource} objects.
             * 
             * @param {Element} element An Element containing resource element children.
             * 
             * @returns {void}
             * 
             * @remarks
             * The resource type is specified by the element name.
             * 
             * @example
             *     <plat-resources>
             *         <injectable alias="Cache">$CacheFactory</injectable>
             *         <observable alias="testObj">{ foo: 'foo', bar: 'bar', baz: 2 }</observable>
             *     </plat-resources>
             */
            add(element: Element): void;

            /**
             * @name initialize
             * @memberof plat.ui.IResources
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Initializes this {@link plat.ui.Resources|Resources} instance.
             * 
             * @param {plat.ui.ITemplateControl} control The control containing this {@link plat.ui.Resources|Resources} instance.
             * @param {Element} element? An optional element used to create initial {@link plat.ui.IResource|IResource} objects.
             * 
             * @returns {void}
             */
            initialize(control: ITemplateControl, element?: Element): void;
            /**
             * @name initialize
             * @memberof plat.ui.IResources
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Initializes this {@link plat.ui.Resources|Resources} instance.
             * 
             * @param {plat.ui.ITemplateControl} control The control containing this {@link plat.ui.Resources|Resources} instance.
             * @param {IObject<IResource>} resources? An optional object used to populate initial
             * {@link plat.ui.IResource|IResource} objects.
             * 
             * @returns {void}
             */
            initialize(control: ITemplateControl, resources?: IObject<IResource>): void;
            /**
             * @name initialize
             * @memberof plat.ui.IResources
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Initializes this {@link plat.ui.Resources|Resources} instance.
             * 
             * @param {plat.ui.ITemplateControl} control The control containing this {@link plat.ui.Resources|Resources} instance.
             * @param {plat.ui.IResources} resources? An optional {@link plat.ui.IResources|IResources} object used to populate initial 
             * {@link plat.ui.IResource|IResource} objects.
             * 
             * @returns {void}
             */
            initialize(control: ITemplateControl, resources?: IResources): void;
        }

        /**
         * @name IResource
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Defines a single resource on the {@link plat.ui.IResources|IResources} object.
         */
        export interface IResource {
            /**
             * @name type
             * @memberof plat.ui.IResource
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of resource.
             * - injectable
             * - observable
             * - object
             * - function
             */
            type: string;

            /**
             * @name alias
             * @memberof plat.ui.IResource
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The alias used to reference the resource.
             */
            alias?: string;

            /**
             * @name value
             * @memberof plat.ui.IResource
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The value of the resource.
             */
            value?: any;

            /**
             * @name initialValue
             * @memberof plat.ui.IResource
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The initial value of the resource prior to it being observed.
             */
            initialValue?: any;
        }

        /**
         * @name DomEvents
         * @memberof plat.ui
         * @kind class
         * 
         * @implements {plat.ui.IDomEvents}
         * 
         * @description
         * A class for managing DOM event registration and handling.
         */
        export class DomEvents implements IDomEvents {
            /**
             * @name config
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ui.IDomEventsConfig}
             * 
             * @description
             * A configuration object for all DOM events.
             */
            static config: IDomEventsConfig = {
                /**
                 * An object containing the different time intervals that govern the behavior of certain 
                 * custom DOM events.
                 */
                intervals: {
                    /**
                     * The max time in milliseconds a user can hold down on the screen 
                     * for a tap event to be fired.
                     */
                    tapInterval: 200,
                    /**
                     * The max time in milliseconds a user can wait between consecutive 
                     * taps for a dbltap event to be fired.
                     */
                    dblTapInterval: 300,
                    /**
                     * The time in milliseconds a user must hold down on the screen 
                     * before a hold event is fired or a release event can be fired.
                     */
                    holdInterval: 400,
                    /**
                     * The delay in milliseconds between the time a user taps to the time 
                     * the tap event fires. Used in the case where a double-tap-to-zoom 
                     * feature is required.
                     */
                    dblTapZoomDelay: 0
                },
                /**
                 * An object containing the different minimum/maximum distances that govern the behavior of certain 
                 * custom DOM events.
                 */
                distances: {
                    /**
                     * The minimum distance a user must move after touch down to register 
                     * it as a scroll instead of a tap.
                     */
                    minScrollDistance: 5,
                    /**
                     * The maximum distance between consecutive taps a user is allowed to 
                     * register a dbltap event.
                     */
                    maxDblTapDistance: 20
                },
                /**
                 * An object containing the different minimum/maximum velocities that govern the behavior of certain 
                 * custom DOM events.
                 */
                velocities: {
                    /**
                     * The minimum velocity a user must move after touch down to register 
                     * a swipe event.
                     */
                    minSwipeVelocity: 0.8
                },
                /**
                 * The default CSS styles applied to elements listening for custom DOM events. If using 
                 * platypus.css, you must overwrite the styles in platypus.css or create your own and 
                 * change the classNames in the config.
                 */
                styleConfig: [{
                    /**
                     * The className that will be used to define the custom style for 
                     * allowing the best touch experience. This class is added to every 
                     * element that registers for a custom DOM event (denoted by a prefixed '$').
                     */
                    className: 'plat-gesture',
                    /**
                     * An array of string styles to be placed on an element to allow for the 
                     * best touch experience. In the format 'CSS identifier: value'
                     * (e.g. 'width : 100px')
                     */
                    styles: [
                        '-moz-user-select: none',
                        '-khtml-user-select: none',
                        '-webkit-touch-callout: none',
                        '-webkit-user-select: none',
                        '-webkit-user-drag: none',
                        '-webkit-tap-highlight-color: transparent',
                        '-webkit-overflow-scrolling: touch',
                        '-ms-user-select: none',
                        '-ms-touch-action: manipulation',
                        'touch-action: manipulation'
                    ]
                }, {
                    /**
                     * The className that will be used to define the custom style for 
                     * blocking touch action scrolling, zooming, etc on the element.
                     */
                    className: 'plat-no-touch-action',
                    /**
                     * An array of string styles that block touch action scrolling, zooming, etc. 
                     * Primarily useful on elements such as a canvas.
                     * In the format 'CSS identifier: value'
                     * (e.g. 'width : 100px')
                     */
                    styles: [
                        '-ms-touch-action: none',
                        'touch-action: none'
                    ]
                }]
            };

            /**
             * @name $Document
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access public
             * @static
             * 
             * @type {Document}
             * 
             * @description
             * Reference to the Document injectable.
             */
            $Document: Document = acquire(__Document);
            /**
             * @name $Compat
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ICompat}
             * 
             * @description
             * Reference to the {@link plat.ICompat|ICompat} injectable.
             */
            $Compat: ICompat = acquire(__Compat);

            /**
             * @name _isActive
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the {@link plat.ui.DomEvents|DomEvents} are currently active. 
             * They become active at least one element on the current 
             * page is listening for a custom event.
             */
            _isActive: boolean;

            /**
             * @name _inTouch
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the user is currently touching the screen.
             */
            _inTouch: boolean;

            /**
             * @name _subscribers
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {plat.IObject<plat.ui.IEventSubscriber>}
             * 
             * @description
             * An object with keyed subscribers that keep track of all of the 
             * events registered on a particular element.
             */
            _subscribers: IObject<IEventSubscriber> = {};

            /**
             * @name _startEvents
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {Array<string>}
             * 
             * @description
             * The touch start events defined by this browser.
             */
            _startEvents: Array<string>;

            /**
             * @name _moveEvents
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {Array<string>}
             * 
             * @description
             * The touch move events defined by this browser.
             */
            _moveEvents: Array<string>;

            /**
             * @name _endEvents
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {Array<string>}
             * 
             * @description
             * The touch end events defined by this browser.
             */
            _endEvents: Array<string>;

            /**
             * @name _gestures
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {plat.ui.IGestures<string>}
             * 
             * @description
             * An object containing the event types for all of the 
             * supported gestures.
             */
            _gestures: IGestures<string> = {
                $tap: __$tap,
                $dbltap: __$dbltap,
                $hold: __$hold,
                $release: __$release,
                $swipe: __$swipe,
                $swipeleft: __$swipeleft,
                $swiperight: __$swiperight,
                $swipeup: __$swipeup,
                $swipedown: __$swipedown,
                $track: __$track,
                $trackleft: __$trackleft,
                $trackright: __$trackright,
                $trackup: __$trackup,
                $trackdown: __$trackdown,
                $trackend: __$trackend
            };

            /**
             * @name _gestureCount
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access protected
             * 
             * @type {plat.ui.IGestures<number>}
             * 
             * @description
             * An object containing the number of currently active 
             * events of each type.
             */
            _gestureCount: IGestures<number> = {
                $tap: 0,
                $dbltap: 0,
                $hold: 0,
                $release: 0,
                $swipe: 0,
                $track: 0,
                $trackend: 0
            };

            /**
             * @name __START
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * A constant for specifying the start condition.
             */
            private __START = 'start';
            /**
             * @name __MOVE
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * A constant for specifying the move condition.
             */
            private __MOVE = 'move';
            /**
             * @name __END
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {string}
             * 
             * @description
             * A constant for specifying the end condition.
             */
            private __END = 'end';
            /**
             * @name __hasMoved
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the user moved while in touch.
             */
            private __hasMoved = false;
            /**
             * @name __hasSwiped
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not the user swiped while in touch.
             */
            private __hasSwiped = false;
            /**
             * @name __hasRelease
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not their is a registered "release" event.
             */
            private __hasRelease = false;
            /**
             * @name __detectingMove
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not we should be detecting move events.
             */
            private __detectingMove = false;
            /**
             * @name __tapCount
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {number}
             * 
             * @description
             * The current tap count to help distinguish single from double taps.
             */
            private __tapCount = 0;
            /**
             * @name __touchCount
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {number}
             * 
             * @description
             * The total number of touches on the screen.
             */
            private __touchCount = 0;
            /**
             * @name __tapTimeout
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {number}
             * 
             * @description
             * A timeout ID given in the case that a tap delay was needed for 
             * something such as a double tap to zoom feature.
             */
            private __tapTimeout: number;
            /**
             * @name __holdTimeout
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {number}
             * 
             * @description
             * A timeout ID for removing a registered hold event.
             */
            private __holdTimeout: number;
            /**
             * @name __cancelRegex
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expressino for determining a "cancel" event.
             */
            private __cancelRegex = /cancel/i;
            /**
             * @name __pointerEndRegex
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expressino for determining a pointer end event.
             */
            private __pointerEndRegex = /up|cancel/i;
            /**
             * @name __lastTouchDown
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {plat.ui.IPointerEvent}
             * 
             * @description
             * The user's last touch down.
             */
            private __lastTouchDown: IPointerEvent;
            /**
             * @name __lastTouchUp
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {plat.ui.IPointerEvent}
             * 
             * @description
             * The user's last touch up.
             */
            private __lastTouchUp: IPointerEvent;
            /**
             * @name __swipeOrigin
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {plat.ui.IPointerEvent}
             * 
             * @description
             * The starting place of an initiated swipe gesture.
             */
            private __swipeOrigin: IPointerEvent;
            /**
             * @name __lastMoveEvent
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {plat.ui.IPointerEvent}
             * 
             * @description
             * The user's last move while in touch.
             */
            private __lastMoveEvent: IPointerEvent;
            /**
             * @name __capturedTarget
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {plat.ui.ICustomElement}
             * 
             * @description
             * The captured target that the user first initiated a gesture on.
             */
            private __capturedTarget: ICustomElement;
            /**
             * @name __focusedElement
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {HTMLInputElement}
             * 
             * @description
             * The currently focused element on the screen. Used in the case of WebKit touch events.
             */
            private __focusedElement: HTMLInputElement;
            /**
             * @name __mappedEventListener
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {EventListener}
             * 
             * @description
             * An EventListener with a bound context for registering mapped events.
             */
            private __mappedEventListener: EventListener = this.__handleMappedEvent.bind(this);
            /**
             * @name __reverseMap
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {{}}
             * 
             * @description
             * A hash map for mapping custom events to standard events.
             */
            private __reverseMap = {};
            /**
             * @name __swipeSubscribers
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {{ master: plat.ui.IDomEventInstance; directional: plat.ui.IDomEventInstance }}
             * 
             * @description
             * A set of subscribers for the swipe gesture.
             */
            private __swipeSubscribers: { master: IDomEventInstance; directional: IDomEventInstance };
            /**
             * @name __pointerHash
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {plat.IObject<plat.ui.IPointerEvent>}
             * 
             * @description
             * A hash of the current pointer touch points on the page.
             */
            private __pointerHash: IObject<IPointerEvent> = {};
            /**
             * @name __pointerEvents
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {Array<plat.ui.IPointerEvent>}
             * 
             * @description
             * An array containing all current pointer touch points on the page.
             */
            private __pointerEvents: Array<IPointerEvent> = [];
            /**
             * @name __listeners
             * @memberof plat.ui.DomEvents
             * @kind property
             * @access private
             * 
             * @type {plat.ui.ICustomEventListener}
             * 
             * @description
             * A set of touch start, move, and end listeners to be place on the document.
             */
            private __listeners: ICustomEventListener = {
                start: this._onTouchStart.bind(this),
                move: this._onMove.bind(this),
                end: this._onTouchEnd.bind(this)
            };

            /**
             * @name constructor
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access public
             * 
             * @description
             * Retrieve the type of touch events for this browser and create the default gesture style.
             * 
             * @returns {plat.ui.DomEvents}
             */
            constructor() {
                this.__getTypes();
            }

            /**
             * @name addEventListener
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Node} element The node listening for the event.
             * @param {string} type The type of event being listened to.
             * @param {plat.ui.IGestureListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Node, type: string, listener: IGestureListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event being listened to.
             * @param {plat.ui.IGestureListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Window, type: string, listener: IGestureListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Node} element The node listening for the event.
             * @param {string} type The type of event being listened to.
             * @param {EventListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Node, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event being listened to.
             * @param {EventListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Window, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;
            addEventListener(element: any, type: string, listener: IGestureListener, useCapture?: boolean): IRemoveListener {
                var $compat = this.$Compat,
                    mappedGestures = $compat.mappedEvents,
                    mappedType = mappedGestures[type],
                    mappingExists = !isNull(mappedType),
                    mappedRemoveListener = noop,
                    mappedTouchRemoveListener = noop,
                    gestures = this._gestures;

                if (mappingExists) {
                    (<any>this.__reverseMap)[mappedType] = type;
                    this.__registerElement(element, type);
                    mappedRemoveListener = this.__addMappedEvent(mappedType, useCapture);
                    if ($compat.hasTouchEvents) {
                        mappedType = mappedType
                            .replace('touch', 'mouse')
                            .replace('start', 'down')
                            .replace('end', 'up');
                        (<any>this.__reverseMap)[mappedType] = type;
                        mappedTouchRemoveListener = this.__addMappedEvent(mappedType, useCapture);
                    }
                }

                element.addEventListener(type, listener, useCapture);

                if (!isUndefined(element['on' + type]) || isUndefined((<any>gestures)[type]) || mappingExists) {
                    return () => {
                        mappedRemoveListener();
                        mappedTouchRemoveListener();
                        element.removeEventListener(type, listener, useCapture);
                    };
                }

                var swipeGesture = gestures.$swipe,
                    trackGesture = gestures.$track,
                    countType = type;

                if (type.indexOf(trackGesture) !== -1) {
                    var trackend = gestures.$trackend;
                    countType = type === trackend ? trackend : trackGesture;
                } else if (type.indexOf(swipeGesture) !== -1) {
                    countType = swipeGesture;
                }

                (<any>this._gestureCount)[countType]++;
                this.__registerElement(element, type);

                return () => {
                    this.__removeEventListener(element, type, listener, useCapture);
                };
            }

            /**
             * @name dispose
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access public
             * 
             * @description
             * Stops listening for touch events and resets the DomEvents instance.
             * 
             * @returns {void}
             */
            dispose(): void {
                this.__unregisterTypes();

                this._gestureCount = {
                    $tap: 0,
                    $dbltap: 0,
                    $hold: 0,
                    $release: 0,
                    $swipe: 0,
                    $track: 0,
                    $trackend: 0
                };
                this._isActive = false;
                this._subscribers = {};
                this.__pointerEvents = [];
                this.__pointerHash = {};
                this.__reverseMap = {};
                this.__tapCount = 0;
                this.__touchCount = 0;
                this.__detectingMove = false;
                this.__hasMoved = false;
                this.__hasRelease = false;
                this.__hasSwiped = false;
                this.__swipeOrigin = null;
                this.__lastMoveEvent = null;
                this.__lastTouchDown = null;
                this.__lastTouchUp = null;
                this.__capturedTarget = null;
                this.__focusedElement = null;
            }

            /**
             * @name _onTouchStart
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access protected
             * 
             * @description
             * A listener for touch/mouse start events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch start event object.
             * 
             * @returns {boolean} Prevents default and stops propagation if false is returned.
             */
            _onTouchStart(ev: IPointerEvent): boolean {
                var isTouch = ev.type !== 'mousedown';

                if (isTouch) {
                    this._inTouch = true;
                } else if (this._inTouch === true) {
                    // return immediately if mouse event and currently in a touch
                    ev.preventDefault();
                    return false;
                }

                // set any captured target back to null
                this.__capturedTarget = null;

                this.__standardizeEventObject(ev);

                this.__lastTouchDown = this.__swipeOrigin = ev;
                this.__lastMoveEvent = null;
                this.__hasMoved = false;

                if ((this.__touchCount = ev.touches.length) > 1) {
                    ev.preventDefault();
                    return false;
                }

                this.__registerType(this.__MOVE);
                this.__detectingMove = true;

                var gestureCount = this._gestureCount,
                    noHolds = gestureCount.$hold <= 0,
                    noRelease = gestureCount.$release <= 0;

                // return if no hold or release events are registered
                if (noHolds && noRelease) {
                    return true;
                }

                var holdInterval = DomEvents.config.intervals.holdInterval,
                    domEvent: IDomEventInstance,
                    subscribeFn: () => void;

                if (noHolds) {
                    this.__hasRelease = false;
                    this.__holdTimeout = setTimeout(() => {
                        this.__hasRelease = true;
                    }, holdInterval);
                    return;
                } else if (noRelease) {
                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$hold);
                    subscribeFn = () => {
                        domEvent.trigger(ev);
                        this.__holdTimeout = null;
                    };
                } else {
                    this.__hasRelease = false;
                    // has both hold and release events registered
                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$hold);
                    subscribeFn = () => {
                        domEvent.trigger(ev);
                        this.__hasRelease = true;
                        this.__holdTimeout = null;
                    };
                }

                // set timeout to fire the subscribeFn
                if (!isNull(domEvent)) {
                    this.__holdTimeout = setTimeout(subscribeFn, holdInterval);
                }

                return true;
            }

            /**
             * @name _onMove
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access protected
             * 
             * @description
             * A listener for touch/mouse move events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch move event object.
             * 
             * @returns {boolean} Prevents default and stops propagation if false is returned.
             */
            _onMove(ev: IPointerEvent): boolean {
                // clear hold event
                this.__clearHold();

                // return immediately if there are multiple touches present, or 
                // if it is a mouse event and currently in a touch
                if (this.__touchCount > 1 || (this._inTouch === true && ev.type === 'mousemove')) {
                    ev.preventDefault();
                    return false;
                }

                this.__standardizeEventObject(ev);

                var gestureCount = this._gestureCount,
                    noTracking = gestureCount.$track <= 0,
                    config = DomEvents.config,
                    swipeOrigin = this.__swipeOrigin,
                    x = ev.clientX,
                    y = ev.clientY,
                    lastX = swipeOrigin.clientX,
                    lastY = swipeOrigin.clientY,
                    minMove = this.__getDistance(lastX, x, lastY, y) >= config.distances.minScrollDistance;

                // if minimum distance moved
                if (minMove) {
                    this.__hasMoved = true;
                }

                // if no move events or no tracking events and the user hasn't moved the minimum swipe distance
                if ((gestureCount.$swipe <= 0 && noTracking) || (noTracking && !minMove)) {
                    return true;
                }

                var lastMove = this.__lastMoveEvent,
                    direction = ev.direction = isNull(lastMove) ? this.__getDirection(x - lastX, y - lastY) :
                        this.__getDirection(x - lastMove.clientX, y - lastMove.clientY);

                if (this.__checkForOriginChanged(direction)) {
                    ev.preventDefault();
                }

                var velocity = ev.velocity = this.__getVelocity(x - swipeOrigin.clientX, y - swipeOrigin.clientY,
                    ev.timeStamp - swipeOrigin.timeStamp);
                this.__hasSwiped = (this.__isHorizontal(direction) ? velocity.x : velocity.y) >= config.velocities.minSwipeVelocity;

                // if tracking events exist
                if (!noTracking) {
                    this.__handleTrack(ev);
                }

                this.__lastMoveEvent = ev;

                return true;
            }

            /**
             * @name _onTouchEnd
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access protected
             * 
             * @description
             * A listener for touch/mouse end events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             * 
             * @returns {boolean} Prevents default and stops propagation if false is returned.
             */
            _onTouchEnd(ev: IPointerEvent): boolean {
                var eventType = ev.type,
                    hasMoved = this.__hasMoved,
                    inTouch = this._inTouch;

                // return immediately if there were multiple touches present
                if (this.__touchCount > 1) {
                    ev.preventDefault();
                    if (eventType === 'touchend') {
                        this.__preventClickFromTouch();
                    }
                    return false;
                }

                if (eventType !== 'mouseup') {
                    if (eventType === 'touchend') {
                        var target = <HTMLInputElement>ev.target;
                        if (hasMoved) {
                            ev.preventDefault();
                            this.__preventClickFromTouch();
                        } else if (this.__isFocused(target)) {
                            this.__preventClickFromTouch();
                        } else {
                            ev.preventDefault();
                            if (inTouch === true) {
                                this.__handleInput(target);
                            }
                        }
                        this._inTouch = false;
                    }
                } else if (!isUndefined(inTouch)) {
                    ev.preventDefault();
                    return false;
                }

                // clear hold event
                this.__clearHold();

                if (this.__detectingMove) {
                    this.__unregisterType(this.__MOVE);
                    this.__detectingMove = false;
                }

                this.__standardizeEventObject(ev);

                // check for cancel event,
                if (this.__cancelRegex.test(eventType)) {
                    this.__tapCount = 0;
                    this.__hasRelease = false;
                    this.__hasSwiped = false;
                    return true;
                }

                // return if the touch count was greater than 0 (should only happen with pointerevents), 
                // or handle release
                if (ev.touches.length > 0) {
                    ev.preventDefault();
                    return false;
                } else if (this.__hasRelease) {
                    this.__handleRelease(ev);
                }

                // handle swipe events
                if (this.__hasSwiped) {
                    this.__handleSwipe();
                }

                var config = DomEvents.config,
                    intervals = config.intervals,
                    touchEnd = ev.timeStamp,
                    touchDown = this.__lastTouchDown;

                // if the user moved their finger (for scroll) we handle $trackend and return,
                // else if they had their finger down too long to be considered a tap, we want to return
                if (hasMoved) {
                    this.__handleTrackEnd(ev);
                    this.__tapCount = 0;
                    return false;
                } else if (isNull(touchDown) || ((touchEnd - touchDown.timeStamp) > intervals.tapInterval)) {
                    this.__tapCount = 0;
                    return true;
                }

                var lastTouchUp = this.__lastTouchUp,
                    x = ev.clientX,
                    y = ev.clientY;

                // check if can be a double tap event by checking number of taps, distance between taps, 
                // and time between taps
                if (this.__tapCount > 0 &&
                    this.__getDistance(x, lastTouchUp.clientX, y, lastTouchUp.clientY) <= config.distances.maxDblTapDistance &&
                    ((touchEnd - lastTouchUp.timeStamp) <= intervals.dblTapInterval)) {
                    // handle dbltap events
                    this.__handleDbltap(ev);
                } else {
                    this.__tapCount = 0;
                }

                // handle tap events
                this.__handleTap(ev);

                this.__lastTouchUp = ev;

                return true;
            }

            // gesture handling methods

            /**
             * @name __handleTap
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for handling and firing tap events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             * 
             * @returns {void}
             */
            private __handleTap(ev: IPointerEvent): void {
                this.__tapCount++;

                if (this._gestureCount.$tap <= 0) {
                    return;
                }

                var gestures = this._gestures,
                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, gestures.$tap);

                if (isNull(domEvent)) {
                    return;
                }

                // fire tap event immediately if no dbltap zoom
                // or a mouse is being used
                if (DomEvents.config.intervals.dblTapZoomDelay <= 0 ||
                    ev.pointerType === 'mouse' || ev.type === 'mouseup') {
                    domEvent.trigger(ev);
                    return;
                }

                // setTimeout for tap delay in case of 
                // dbltap zoom
                this.__tapTimeout = setTimeout(() => {
                    domEvent.trigger(ev);
                    this.__tapCount = 0;
                    this.__tapTimeout = null;
                }, DomEvents.config.intervals.dblTapZoomDelay);

            }
            /**
             * @name __handleDbltap
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for handling and firing double tap events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             * 
             * @returns {void}
             */
            private __handleDbltap(ev: IPointerEvent): void {
                this.__tapCount = 0;

                if (!isNull(this.__tapTimeout)) {
                    clearTimeout(this.__tapTimeout);
                    this.__tapTimeout = null;
                }

                if (this._gestureCount.$dbltap <= 0) {
                    return;
                }

                var domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$dbltap);
                if (isNull(domEvent)) {
                    return;
                }

                domEvent.trigger(ev);
                // set touch count to -1 to prevent repeated fire on sequential taps
                this.__tapCount = -1;
            }
            /**
             * @name __handleRelease
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for handling and firing release events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             * 
             * @returns {void}
             */
            private __handleRelease(ev: IPointerEvent): void {
                var domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$release);
                if (!isNull(domEvent)) {
                    domEvent.trigger(ev);
                }

                this.__hasRelease = false;
            }
            /**
             * @name __handleSwipe
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for handling and firing swipe events.
             * 
             * @returns {void}
             */
            private __handleSwipe(): void {
                var lastMove = this.__lastMoveEvent;
                if (isNull(lastMove)) {
                    this.__hasSwiped = false;
                    return;
                }

                var swipeSubscribers = this.__swipeSubscribers,
                    swipeDomEvent = swipeSubscribers.master,
                    swipeDirectionDomEvent = swipeSubscribers.directional;

                if (!isNull(swipeDomEvent)) {
                    swipeDomEvent.trigger(lastMove);
                }

                if (!isNull(swipeDirectionDomEvent)) {
                    swipeDirectionDomEvent.trigger(lastMove);
                }

                this.__hasSwiped = false;
                this.__lastMoveEvent = null;
                this.__swipeSubscribers = null;
            }
            /**
             * @name __handleTrack
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for handling and firing track events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch move event object.
             * 
             * @returns {void}
             */
            private __handleTrack(ev: IPointerEvent): void {
                var trackGesture = this._gestures.$track,
                    direction = ev.direction,
                    trackDirectionGesture = trackGesture + direction,
                    eventTarget = this.__capturedTarget || <ICustomElement>ev.target,
                    trackDomEvent = this.__findFirstSubscriber(eventTarget, trackGesture),
                    trackDirectionDomEvent = this.__findFirstSubscriber(eventTarget, trackDirectionGesture);

                if (!isNull(trackDomEvent)) {
                    ev.preventDefault();
                    trackDomEvent.trigger(ev);
                }

                if (!isNull(trackDirectionDomEvent)) {
                    ev.preventDefault();
                    trackDirectionDomEvent.trigger(ev);
                }
            }
            /**
             * @name __handleTrackEnd
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for handling and firing track end events.
             * 
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             * 
             * @returns {void}
             */
            private __handleTrackEnd(ev: IPointerEvent): void {
                if (this._gestureCount.$trackend <= 0) {
                    return;
                }

                var eventTarget = this.__capturedTarget || <ICustomElement>ev.target,
                    domEvent = this.__findFirstSubscriber(eventTarget, this._gestures.$trackend);
                if (isNull(domEvent)) {
                    return;
                }

                domEvent.trigger(ev);
            }
            /**
             * @name __handleMappedEvent
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for handling and firing custom events that are mapped to standard events.
             * 
             * @param {plat.ui.IExtendedEvent} ev The touch event object.
             * 
             * @returns {void}
             */
            private __handleMappedEvent(ev: IExtendedEvent): void {
                var mappedType = ev.type,
                    eventType = (<any>this.__reverseMap)[mappedType],
                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, eventType);

                if (isNull(domEvent)) {
                    return;
                }

                this.__standardizeEventObject(ev);
                domEvent.trigger(ev);
            }

            // touch type and element registration

            /**
             * @name __getTypes
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * A function for determining the proper touch events.
             * 
             * @returns {void}
             */
            private __getTypes(): void {
                var $compat = this.$Compat,
                    touchEvents = $compat.mappedEvents;

                if ($compat.hasPointerEvents) {
                    this._startEvents = [touchEvents.$touchstart];
                    this._moveEvents = [touchEvents.$touchmove];
                    this._endEvents = [touchEvents.$touchend, touchEvents.$touchcancel];
                    return;
                } else if ($compat.hasTouchEvents) {
                    this._startEvents = [touchEvents.$touchstart, 'mousedown'];
                    this._moveEvents = [touchEvents.$touchmove, 'mousemove'];
                    this._endEvents = [touchEvents.$touchend, touchEvents.$touchcancel, 'mouseup'];
                    return;
                }

                var cancelEvent = touchEvents.$touchcancel;
                this._startEvents = [touchEvents.$touchstart];
                this._moveEvents = [touchEvents.$touchmove];
                this._endEvents = isNull(cancelEvent) ? [touchEvents.$touchend] : [touchEvents.$touchend, cancelEvent];
            }
            /**
             * @name __registerTypes
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Registers for and starts listening to start and end touch events on the document.
             * 
             * @returns {void}
             */
            private __registerTypes(): void {
                this.__registerType(this.__START);
                this.__registerType(this.__END);
            }
            /**
             * @name __unregisterTypes
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Unregisters for and stops listening to all touch events on the document.
             * 
             * @returns {void}
             */
            private __unregisterTypes(): void {
                this.__unregisterType(this.__START);
                this.__unregisterType(this.__MOVE);
                this.__unregisterType(this.__END);
            }
            /**
             * @name __registerType
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Registers for and begins listening to a particular touch event type.
             * 
             * @param {string} event The event type to begin listening for.
             * 
             * @returns {void}
             */
            private __registerType(event: string): void {
                var events: Array<string>,
                    listener = this.__listeners[event],
                    $document = this.$Document;

                switch (event) {
                    case this.__START:
                        events = this._startEvents;
                        break;
                    case this.__MOVE:
                        events = this._moveEvents;
                        break;
                    case this.__END:
                        events = this._endEvents;
                        break;
                    default:
                        return;
                }

                var index = events.length;
                while (index-- > 0) {
                    $document.addEventListener(events[index], listener, false);
                }
            }
            /**
             * @name __unregisterType
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Unregisters for and stops listening to a particular touch event type.
             * 
             * @param {string} event The event type to stop listening for.
             * 
             * @returns {void}
             */
            private __unregisterType(event: string): void {
                var events: Array<string>,
                    listener = this.__listeners[event],
                    $document = this.$Document;

                switch (event) {
                    case this.__START:
                        events = this._startEvents;
                        break;
                    case this.__MOVE:
                        events = this._moveEvents;
                        break;
                    case this.__END:
                        events = this._endEvents;
                        break;
                    default:
                        return;
                }

                var index = events.length;
                while (index-- > 0) {
                    $document.removeEventListener(events[index], listener, false);
                }
            }
            /**
             * @name __registerElement
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Registers and associates an element with an event.
             * 
             * @param {plat.ui.ICustomElement} element The element being tied to a custom event.
             * @param {string} type The type of event.
             * 
             * @returns {void}
             */
            private __registerElement(element: ICustomElement, type: string): void {
                var id: string,
                    plat = element.__plat;
                if (isNull(plat)) {
                    id = uniqueId('domEvent_');
                    element.__plat = plat = {
                        domEvent: id
                    };
                } else if (isNull(plat.domEvent)) {
                    id = uniqueId('domEvent_');
                    plat.domEvent = id;
                }

                // check if DomEvents is ready
                if (!this._isActive) {
                    this.__registerTypes();

                    if (isNull(this._isActive)) {
                        this.__appendGestureStyle();
                    }

                    this._isActive = true;
                }

                var $domEvent: IDomEventInstance;
                if (isNull(id)) {
                    var subscriber = this._subscribers[plat.domEvent];
                    if (isUndefined((<any>subscriber)[type])) {
                        $domEvent = new CustomDomEvent(element, type);
                        (<any>subscriber)[type] = $domEvent;
                    } else {
                        (<any>subscriber)[type].count++;
                    }
                    subscriber.gestureCount++;
                } else {
                    var newSubscriber = { gestureCount: 1 };
                    $domEvent = new CustomDomEvent(element, type);
                    (<any>newSubscriber)[type] = $domEvent;
                    this._subscribers[id] = newSubscriber;

                    if (!isUndefined((<HTMLElement>element).className)) {
                        addClass(<HTMLElement>element, DomEvents.config.styleConfig[0].className);
                    }
                    this.__removeSelections(element);
                }
            }
            /**
             * @name __unregisterElement
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Unregisters and disassociates an element with an event.
             * 
             * @param {plat.ui.ICustomElement} element The element being disassociated with the given custom event.
             * @param {string} type The type of event.
             * 
             * @returns {void}
             */
            private __unregisterElement(element: ICustomElement, type: string): void {
                var plat = element.__plat;
                if (isNull(plat) || isNull(plat.domEvent)) {
                    return;
                }

                var domEventId = plat.domEvent,
                    eventSubscriber = this._subscribers[domEventId],
                    domEvent: ICustomDomEventInstance = (<any>eventSubscriber)[type];

                if (isNull(domEvent)) {
                    return;
                }

                domEvent.count--;
                if (domEvent.count === 0) {
                    deleteProperty(eventSubscriber, type);
                }
                eventSubscriber.gestureCount--;

                if (eventSubscriber.gestureCount === 0) {
                    deleteProperty(this._subscribers, domEventId);
                    this.__removeElement(element);
                }
            }
            /**
             * @name __setTouchPoint
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Sets the current touch point and helps standardize the given event object.
             * 
             * @param {plat.ui.IPointerEvent} ev The current point being touched.
             * 
             * @returns {void}
             */
            private __setTouchPoint(ev: IPointerEvent): void {
                var eventType = ev.type,
                    $compat = this.$Compat;

                if ($compat.hasPointerEvents) {
                    if (eventType === 'pointerdown') {
                        this.__setCapture(ev.target);
                    }

                    this.__updatePointers(ev, this.__pointerEndRegex.test(eventType));
                } else if ($compat.hasMsPointerEvents) {
                    if (eventType === 'MSPointerDown') {
                        this.__setCapture(ev.target);
                    }

                    this.__updatePointers(ev, this.__pointerEndRegex.test(eventType));
                } else if (eventType === 'mousedown') {
                    ev.pointerType = 'mouse';
                    this.__setCapture(ev.target);
                } else {
                    // do not need to set catpure for touchstart events
                    ev.pointerType = eventType.indexOf('mouse') === -1 ? 'touch' : 'mouse';
                }
            }
            /**
             * @name __setCapture
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Sets the captured target.
             * 
             * @param {EventTarget} target The target to capture.
             * 
             * @returns {void}
             */
            private __setCapture(target: EventTarget): void {
                if (isNull(this.__capturedTarget) && !isDocument(target)) {
                    this.__capturedTarget = <ICustomElement>target;
                }
            }
            /**
             * @name __updatePointers
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Sets the captured target.
             * 
             * @param {plat.ui.IPointerEvent} ev The current touch point.
             * @param {boolean} remove Whether to remove the touch point or add it.
             * 
             * @returns {void}
             */
            private __updatePointers(ev: IPointerEvent, remove: boolean): void {
                var id = ev.pointerId,
                    pointer = this.__pointerHash[id];

                if (remove) {
                    if (!isUndefined(pointer)) {
                        this.__pointerEvents.splice(this.__pointerEvents.indexOf(pointer), 1);
                        deleteProperty(this.__pointerHash, id);
                    }
                } else {
                    ev.identifier = ev.pointerId;
                    if (isUndefined(pointer)) {
                        this.__pointerEvents.push(ev);
                    } else {
                        this.__pointerEvents.splice(this.__pointerEvents.indexOf(pointer), 1, ev);
                    }

                    this.__pointerHash[id] = ev;
                }
            }

            // event and subscription handling

            /**
             * @name __findFirstSubscriber
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Searches from the EventTarget up the DOM tree looking for an element with the 
             * registered event type.
             * 
             * @param {plat.ui.ICustomElement} eventTarget The current target of the touch event.
             * @param {string} type The type of event being searched for.
             * 
             * @returns {plat.ui.IDomEventInstance} The found {@link plat.ui.IDomEventInstance} associated 
             * with the first found element in the tree and the event type. Used to trigger the event at this 
             * point in the DOM tree.
             */
            private __findFirstSubscriber(eventTarget: ICustomElement, type: string): IDomEventInstance {
                var plat: ICustomElementProperty,
                    subscriber: IEventSubscriber,
                    domEvent: IDomEventInstance;

                do {
                    plat = eventTarget.__plat;
                    if (isUndefined(plat) || isUndefined(plat.domEvent)) {
                        continue;
                    }

                    subscriber = this._subscribers[plat.domEvent];
                    domEvent = (<any>subscriber)[type];
                    if (isUndefined(domEvent)) {
                        continue;
                    }

                    return domEvent;
                } while (!isNull(eventTarget = <ICustomElement>eventTarget.parentNode));
            }
            /**
             * @name __addMappedEvent
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Adds a listener for listening to a standard event and mapping it to a custom event.
             * 
             * @param {string} mappedEvent The mapped event type.
             * @param {boolean} useCapture? Whether the mapped event listener is fired on the capture or bubble phase.
             * 
             * @returns {plat.IRemoveListener} A function for removing the added mapped listener.
             */
            private __addMappedEvent(mappedEvent: string, useCapture?: boolean): IRemoveListener {
                var $document = this.$Document;
                $document.addEventListener(mappedEvent, this.__mappedEventListener, useCapture);

                return () => {
                    $document.removeEventListener(mappedEvent, this.__mappedEventListener, useCapture);
                };
            }
            /**
             * @name __removeEventListener
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Removes an event listener for a given event type.
             * 
             * @param {plat.ui.ICustomElement} element The element to remove the listener from.
             * @param {string} type The type of event being removed.
             * @param {plat.ui.IGestureListener} listener The listener being removed.
             * @param {boolean} useCapture? Whether the listener is fired on the capture or bubble phase.
             * 
             * @returns {void}
             */
            private __removeEventListener(element: ICustomElement, type: string, listener: IGestureListener,
                useCapture?: boolean): void {
                var gestures = this._gestures;

                element.removeEventListener(type, listener, useCapture);

                var swipeGesture = gestures.$swipe,
                    trackGesture = gestures.$track,
                    countType = type;

                if (type.indexOf(trackGesture) !== -1) {
                    countType = trackGesture;
                } else if (type.indexOf(swipeGesture) !== -1) {
                    countType = swipeGesture;
                }

                (<any>this._gestureCount)[countType]--;
                this.__unregisterElement(element, type);
            }
            /**
             * @name __removeElement
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Removes an element from the subscriber object.
             * 
             * @param {plat.ui.ICustomElement} element The element being removed.
             * 
             * @returns {void}
             */
            private __removeElement(element: ICustomElement): void {
                this.__returnSelections(element);

                if (!isUndefined(element.className)) {
                    removeClass(element, DomEvents.config.styleConfig[0].className);
                }

                var plat = element.__plat;
                deleteProperty(plat, 'domEvent');
                if (isEmpty(plat)) {
                    deleteProperty(element, '__plat');
                }

                // check if no elements are left listening
                if (isEmpty(this._subscribers)) {
                    this.dispose();
                }
            }
            /**
             * @name __standardizeEventObject
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Standardizes certain properties on the event object for custom events.
             * 
             * @param {plat.ui.IExtendedEvent} ev The event object to be standardized.
             * 
             * @returns {void}
             */
            private __standardizeEventObject(ev: IExtendedEvent): void {
                this.__setTouchPoint(ev);

                ev.touches = ev.touches || this.__pointerEvents;

                var evtObj = ev;
                if (isUndefined(ev.clientX)) {
                    if (ev.touches.length > 0) {
                        evtObj = ev.touches[0];
                    } else if (((<any>ev).changedTouches || []).length > 0) {
                        evtObj = (<any>ev).changedTouches[0];
                    }

                    ev.clientX = evtObj.clientX;
                    ev.clientY = evtObj.clientY;
                }

                if (isUndefined(ev.offsetX) || !isNull(this.__capturedTarget)) {
                    ev.offset = this.__getOffset(ev);
                    return;
                }

                ev.offset = {
                    x: ev.offsetX,
                    y: ev.offsetY
                };
            }
            /**
             * @name __getOffset
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Grabs the x and y offsets of an event object's target.
             * 
             * @param {plat.ui.IExtendedEvent} ev The current event object.
             * 
             * @returns {plat.ui.IPoint} An object containing the x and y offsets.
             */
            private __getOffset(ev: IExtendedEvent): IPoint {
                var target = this.__capturedTarget || <any>ev.target;
                if (isDocument(target)) {
                    return {
                        x: ev.clientX,
                        y: ev.clientY
                    };
                }

                var x = target.offsetLeft,
                    y = target.offsetTop;
                while (!isNull(target = target.offsetParent)) {
                    x += target.offsetLeft;
                    y += target.offsetTop;
                }

                return {
                    x: (ev.clientX - x),
                    y: (ev.clientY - y)
                };
            }
            /**
             * @name __clearHold
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Clears the hold events setTimeout.
             * 
             * @returns {void}
             */
            private __clearHold(): void {
                if (!isNull(this.__holdTimeout)) {
                    clearTimeout(this.__holdTimeout);
                    this.__holdTimeout = null;
                }
            }

            // utility methods

            /**
             * @name __getDistance
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Calculates the distance between two (x, y) coordinate points.
             * 
             * @param {number} x1 The x-coordinate of the first point.
             * @param {number} x2 The x-coordinate of the second point.
             * @param {number} y1 The y-coordinate of the first point.
             * @param {number} y2 The y-coordinate of the second point.
             * 
             * @returns {number} The distance between the points.
             */
            private __getDistance(x1: number, x2: number, y1: number, y2: number): number {
                var x = Math.abs(x2 - x1),
                    y = Math.abs(y2 - y1);
                return Math.sqrt((x * x) + (y * y));
            }
            /**
             * @name __getVelocity
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Calculates the velocity between two (x, y) coordinate points over a given time.
             * 
             * @param {number} dx The change in x position.
             * @param {number} dy The change in y position.
             * @param {number} dt The change in time.
             * 
             * @returns {plat.ui.IVelocity} A velocity object containing horiztonal and vertical velocities.
             */
            private __getVelocity(dx: number, dy: number, dt: number): IVelocity {
                return {
                    x: Math.abs(dx / dt) || 0,
                    y: Math.abs(dy / dt) || 0
                };
            }
            /**
             * @name __getDirection
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Calculates the direction of movement.
             * 
             * @param {number} dx The change in x position.
             * @param {number} dy The change in y position.
             * 
             * @returns {string} The direction of movement.
             */
            private __getDirection(dx: number, dy: number): string {
                var distanceX = Math.abs(dx),
                    distanceY = Math.abs(dy);

                if (distanceY > distanceX) {
                    return dy < 0 ? 'up' : 'down';
                }

                return dx < 0 ? 'left' : 'right';
            }
            /**
             * @name __checkForOriginChanged
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Checks to see if a swipe direction has changed to recalculate 
             * an origin point.
             * 
             * @param {string} direction The current direction of movement.
             * 
             * @returns {boolean} Whether or not the origin point has changed.
             */
            private __checkForOriginChanged(direction: string): boolean {
                var lastMove = this.__lastMoveEvent;
                if (isNull(lastMove)) {
                    this.__hasSwiped = false;
                    return this.__checkForRegisteredSwipe(direction);
                }

                var swipeDirection = lastMove.direction;
                if (swipeDirection === direction) {
                    return false;
                }

                this.__swipeOrigin = lastMove;

                this.__hasSwiped = false;
                return this.__checkForRegisteredSwipe(direction);
            }
            /**
             * @name __checkForRegisteredSwipe
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Checks to see if a swipe event has been registered.
             * 
             * @param {string} direction The current direction of movement.
             * 
             * @returns {boolean} Whether or not a registerd swipe event exists.
             */
            private __checkForRegisteredSwipe(direction: string): boolean {
                var swipeTarget = <ICustomElement>this.__swipeOrigin.target,
                    swipeGesture = this._gestures.$swipe,
                    swipeDirectionGesture = swipeGesture + direction,
                    domEventSwipe = this.__findFirstSubscriber(swipeTarget, swipeGesture),
                    domEventSwipeDirection = this.__findFirstSubscriber(swipeTarget, swipeDirectionGesture);

                this.__swipeSubscribers = {
                    master: domEventSwipe,
                    directional: domEventSwipeDirection
                };

                return !isNull(domEventSwipe) || !isNull(domEventSwipeDirection);
            }
            /**
             * @name __isHorizontal
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Checks to see if a swipe event has been registered.
             * 
             * @param {string} direction The current direction of movement.
             * 
             * @returns {boolean} Whether or not the current movement is horizontal.
             */
            private __isHorizontal(direction: string): boolean {
                return direction === 'left' || direction === 'right';
            }
            /**
             * @name __appendGestureStyle
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Appends CSS to the head for gestures if needed.
             * 
             * @returns {void}
             */
            private __appendGestureStyle(): void {
                var $document = this.$Document,
                    styleClasses: Array<IDefaultStyle>,
                    classLength: number;

                if (this.$Compat.platCss) {
                    return;
                } else if (!isNull($document.styleSheets) && $document.styleSheets.length > 0) {
                    var styleSheet = <CSSStyleSheet>$document.styleSheets[0];
                    styleClasses = DomEvents.config.styleConfig;
                    classLength = styleClasses.length;
                    while (classLength-- > 0) {
                        styleSheet.insertRule(this.__createStyle(styleClasses[classLength]), 0);
                    }
                    return;
                }

                var head = $document.head,
                    style = <HTMLStyleElement>$document.createElement('style'),
                    textContent = '';

                style.type = 'text/css';
                styleClasses = DomEvents.config.styleConfig;
                classLength = styleClasses.length;
                while (classLength-- > 0) {
                    textContent = this.__createStyle(styleClasses[classLength]) + textContent;
                }
                style.textContent = textContent;
                head.appendChild(style);
            }
            /**
             * @name __createStyle
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Creates a style text to append to the document head.
             * 
             * @param {plat.ui.IDefaultStyle} styleClass The object containing the custom styles for 
             * gestures.
             * 
             * @returns {string} The style text.
             */
            private __createStyle(styleClass: IDefaultStyle): string {
                var styles: Array<string> = styleClass.styles || [],
                    styleLength = styles.length,
                    style = '.' + styleClass.className + ' { ',
                    textContent = '';

                    styleLength = styles.length;

                    for (var j = 0; j < styleLength; ++j) {
                        textContent += styles[j] + ';';
                    }

                    style += textContent + ' } ';

                return style;
            }
            /**
             * @name __isFocused
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Determines whether the target is the currently focused element.
             * 
             * @param {EventTarget} target The event target.
             * 
             * @returns {boolean} Whether or not the target is focused.
             */
            private __isFocused(target: EventTarget): boolean {
                return target === this.__focusedElement;
            }
            /**
             * @name __handleInput
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Handles HTMLInputElements in WebKit based touch applications.
             * 
             * @param {HTMLInputElement} target The event target.
             * 
             * @returns {void}
             */
            private __handleInput(target: HTMLInputElement): void {
                var nodeName = target.nodeName,
                    focusedElement = this.__focusedElement || <HTMLInputElement>{};

                if (!isString(nodeName)) {
                    this.__focusedElement = null;
                    if (isFunction(focusedElement.blur)) {
                        focusedElement.blur();
                    }
                    return;
                }

                var remover: IRemoveListener;
                switch (nodeName.toLowerCase()) {
                    case 'input':
                        switch (target.type) {
                            case 'range':
                                if (isFunction(focusedElement.blur)) {
                                    focusedElement.blur();
                                }
                                break;
                            case 'button':
                            case 'submit':
                            case 'checkbox':
                            case 'radio':
                            case 'file':
                                if (isFunction(focusedElement.blur)) {
                                    focusedElement.blur();
                                }
                                postpone(() => {
                                    if (this.$Document.body.contains(target)) {
                                        target.click();
                                    }
                                });
                                break;
                            default:
                                this.__focusedElement = target;
                                target.focus();
                                remover = this.addEventListener(target, 'blur', () => {
                                    if (this.__isFocused(target)) {
                                        this.__focusedElement = null;
                                    }
                                    remover();
                                }, false);
                                return;
                        }
                        break;
                    case 'a':
                    case 'button':
                    case 'select':
                    case 'label':
                        if (isFunction(focusedElement.blur)) {
                            focusedElement.blur();
                        }
                        postpone(() => {
                            if (this.$Document.body.contains(target)) {
                                target.click();
                            }
                        });
                        break;
                    case 'textarea':
                        this.__focusedElement = target;
                        target.focus();
                        remover = this.addEventListener(target, 'blur', () => {
                            if (this.__isFocused(target)) {
                                this.__focusedElement = null;
                            }
                            remover();
                        }, false);
                        return;
                    default:
                        if (isFunction(focusedElement.blur)) {
                            focusedElement.blur();
                        }
                        postpone(() => {
                            if (this.$Document.body.contains(target) && isFunction(target.click)) {
                                target.click();
                            }
                        });
                        break;
                }

                this.__focusedElement = null;
                return;
            }
            /**
             * @name __preventClickFromTouch
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Handles the phantom click in WebKit based touch applications.
             * 
             * @returns {void}
             */
            private __preventClickFromTouch(): void {
                var $document = this.$Document,
                    delayedClickRemover = defer(() => {
                        $document.removeEventListener('click', preventDefault, true);
                        $document.removeEventListener('mousedown', preventDefault, true);
                        $document.removeEventListener('mouseup', preventDefault, true);
                    }, 400),
                    preventDefault = (ev: Event) => {
                        ev.preventDefault();
                        ev.stopPropagation();
                        $document.removeEventListener(ev.type, preventDefault, true);
                        if (delayedClickRemover === noop) {
                            return false;
                        }
                        delayedClickRemover();
                        delayedClickRemover = noop;

                        var touchDown = this.__lastTouchDown;
                        if (isNull(touchDown) || this.__isFocused(touchDown.target)) {
                            return false;
                        }
                        this.__handleInput(<HTMLInputElement>touchDown.target);
                        return false;
                    };

                $document.addEventListener('click', preventDefault, true);
                $document.addEventListener('mousedown', preventDefault, true);
                $document.addEventListener('mouseup', preventDefault, true);
            }
            /**
             * @name __removeSelections
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Removes selection capability from the element.
             * 
             * @param {Node} element The element to remove selections on.
             * 
             * @returns {void}
             */
            private __removeSelections(element: Node): void {
                if (!isNode(element)) {
                    return;
                }

                if (!isUndefined((<any>element).onselectstart)) {
                    element.addEventListener('selectstart', this.__preventDefault, false);
                }
                if (!isUndefined((<any>element).ondragstart)) {
                    element.addEventListener('dragstart', this.__preventDefault, false);
                }
            }
            /**
             * @name __returnSelections
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Returns selection capability from the element.
             * 
             * @param {Node} element The element to return selections on.
             * 
             * @returns {void}
             */
            private __returnSelections(element: Node): void {
                if (!isNode(element)) {
                    return;
                }

                if (!isUndefined((<any>element).onselectstart)) {
                    element.removeEventListener('selectstart', this.__preventDefault, false);
                }
                if (!isUndefined((<any>element).ondragstart)) {
                    element.removeEventListener('dragstart', this.__preventDefault, false);
                }
            }
            /**
             * @name __preventDefault
             * @memberof plat.ui.DomEvents
             * @kind function
             * @access private
             * 
             * @description
             * Prevents default and stops propagation in all elements other than 
             * inputs and textareas.
             * 
             * @param {Event} ev The event object.
             * 
             * @returns {boolean} Prevents default and stops propagation if false.
             */
            private __preventDefault(ev: Event): boolean {
                var nodeName = (<Node>ev.target).nodeName;
                if (isString(nodeName)) {
                    nodeName = nodeName.toLowerCase();
                }

                if (nodeName === 'input' || nodeName === 'textarea') {
                    return true;
                }

                ev.preventDefault();
                return false;
            }
        }

        /**
         * The Type for referencing the '$DomEvents' injectable as a dependency.
         */
        export function IDomEvents(): IDomEvents {
            return new DomEvents();
        }

        register.injectable(__DomEvents, IDomEvents);

        /**
         * @name IDomEvents
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object for managing DOM event registration and handling.
         */
        export interface IDomEvents {
            /**
             * @name addEventListener
             * @memberof plat.ui.IDomEvents
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Node} element The node listening for the event.
             * @param {string} type The type of event being listened to.
             * @param {plat.ui.IGestureListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Node, type: string, listener: IGestureListener,
                useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.IDomEvents
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event being listened to.
             * @param {plat.ui.IGestureListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Window, type: string, listener: IGestureListener,
                useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.IDomEvents
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Node} element The node listening for the event.
             * @param {string} type The type of event being listened to.
             * @param {EventListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Node, type: string, listener: EventListener,
                useCapture?: boolean): IRemoveListener;
            /**
             * @name addEventListener
             * @memberof plat.ui.IDomEvents
             * @kind function
             * @access public
             * @variation 3
             * 
             * @description
             * Add an event listener for the specified event type on the specified element.
             * 
             * @param {Window} element The window object.
             * @param {string} type The type of event being listened to.
             * @param {EventListener} listener The listener to be fired.
             * @param {boolean} useCapture? Whether to fire the event on the capture or bubble phase of propagation.
             * 
             * @returns {plat.IRemoveListener} A function for removing the event listener and stop listening to the event.
             */
            addEventListener(element: Window, type: string, listener: EventListener,
                useCapture?: boolean): IRemoveListener;

            /**
             * @name dispose
             * @memberof plat.ui.IDomEvents
             * @kind function
             * @access public
             * 
             * @description
             * Stops listening for touch events and resets the DomEvents instance.
             * 
             * @returns {void}
             */
            dispose(): void;
        }

        /**
         * The Type for referencing the '$DomEventsConfig' injectable as a dependency.
         */
        export function IDomEventsConfig(): IDomEventsConfig {
            return DomEvents.config;
        }

        register.injectable(__DomEventsConfig, IDomEventsConfig);

        /**
         * @name DomEvent
         * @memberof plat.ui
         * @kind class
         * 
         * @implements {plat.ui.IDomEventInstance}
         * 
         * @description
         * A class for managing a single custom event.
         */
        export class DomEvent implements IDomEventInstance {
            /**
             * @name $Document
             * @memberof plat.ui.DomEvent
             * @kind property
             * @access public
             * 
             * @type {Document}
             * 
             * @description
             * Reference to the Document injectable.
             */
            $Document: Document = acquire(__Document);

            /**
             * @name element
             * @memberof plat.ui.DomEvent
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The node or window object associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             */
            element: any;
            /**
             * @name event
             * @memberof plat.ui.DomEvent
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event type associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             */
            event: string;

            /**
             * @name initialize
             * @memberof plat.ui.DomEvent
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Initializes the element and event of this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @param {Node} element The element associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * @param {string} event The event associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @returns {void}
             */
            initialize(element: Node, event: string): void;
            /**
             * @name initialize
             * @memberof plat.ui.DomEvent
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Initializes the element and event of this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @param {Window} element The window object.
             * @param {string} event The event associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @returns {void}
             */
            initialize(element: Window, event: string): void;
            initialize(element: any, event: string): void {
                this.element = element;
                this.event = event;
            }

            /**
             * @name trigger
             * @memberof plat.ui.DomEvent
             * @kind function
             * @access public
             * 
             * @description
             * Triggers its event on its element.
             * 
             * @param {Object} eventExtension? An event extension to extend the dispatched CustomEvent.
             * 
             * @returns {void}
             */
            trigger(eventExtension?: Object): void {
                var customEv = <CustomEvent>this.$Document.createEvent('CustomEvent');
                if (isObject(eventExtension)) {
                    extend(customEv, eventExtension);
                }
                customEv.initCustomEvent(this.event, true, true, 0);
                this.element.dispatchEvent(customEv);
            }
        }

        /**
         * The Type for referencing the '$DomEventInstance' injectable as a dependency.
         */
        export function IDomEventInstance(): IDomEventInstance {
            return new DomEvent();
        }

        register.injectable(__DomEventInstance, IDomEventInstance, null, __INSTANCE);

        /**
         * @name CustomDomEvent
         * @memberof plat.ui
         * @kind class
         * @exported false
         * 
         * @extends {plat.ui.DomEvent}
         * @implements {plat.ui.ICustomDomEventInstance}
         * 
         * @description
         * A specialized class for managing a single custom touch event in {@link plat.ui.DomEvents|DomEvents}.
         */
        class CustomDomEvent extends DomEvent implements ICustomDomEventInstance {
            /**
             * @name count
             * @memberof plat.ui.CustomDomEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The number of listeners added for this event on this element.
             */
            count = 0;

            /**
             * @name constructor
             * @memberof plat.ui.CustomDomEvent
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * The constructor for a {@link plat.ui.CustomDomEvent|CustomDomEvent}. Assigns the 
             * associated element and event.
             * 
             * @param {Node} element The associated element.
             * @param {string} event The associated event.
             * 
             * @returns {plat.ui.CustomDomEvent}
             */
            constructor(element: Node, event: string);
            /**
             * @name constructor
             * @memberof plat.ui.CustomDomEvent
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * The constructor for a {@link plat.ui.CustomDomEvent|CustomDomEvent}. Assigns the 
             * associated element and event.
             * 
             * @param {Window} element The window object.
             * @param {string} event The associated event.
             * 
             * @returns {plat.ui.CustomDomEvent} A {@link plat.ui.CustomDomEvent|CustomDomEvent} instance.
             */
            constructor(element: Window, event: string);
            constructor(element: any, event: string) {
                super();
                this.element = element;
                this.event = event;
                this.count++;
            }

            /**
             * @name trigger
             * @memberof plat.ui.CustomDomEvent
             * @kind function
             * @access public
             * 
             * @description
             * Triggers its event on its element.
             * 
             * @param {plat.ui.IPointerEvent} ev The current touch event object used to extend the 
             * newly created custom event.
             * 
             * @returns {void}
             */
            trigger(ev: IPointerEvent): void {
                var customEv = <CustomEvent>this.$Document.createEvent('CustomEvent');
                this.__extendEventObject(customEv, ev);
                customEv.initCustomEvent(this.event, true, true, 0);
                this.element.dispatchEvent(customEv);
            }

            /**
             * @name __extendEventObject
             * @memberof plat.ui.CustomDomEvent
             * @kind function
             * @access private
             * 
             * @description
             * Extends the custom event to mimic a standardized touch event.
             * 
             * @param {plat.ui.IGestureEvent} customEv The newly created custom event object.
             * @param {plat.ui.IPointerEvent} ev The current touch event object.
             * 
             * @returns {void}
             */
            private __extendEventObject(customEv: IGestureEvent, ev: IPointerEvent): void {
                // not using extend function because this gets called so often for certain events.
                var pointerType = ev.pointerType;

                customEv.clientX = ev.clientX;
                customEv.clientY = ev.clientY;
                customEv.offsetX = ev.offset.x;
                customEv.offsetY = ev.offset.y;
                customEv.direction = ev.direction || 'none';
                customEv.touches = ev.touches;
                customEv.velocity = ev.velocity || { x: 0, y: 0 };
                customEv.identifier = ev.identifier || 0;
                customEv.pointerType = isNumber(pointerType) ? this.__convertPointerType(pointerType, ev.type) : pointerType;
                customEv.screenX = ev.screenX;
                customEv.screenY = ev.screenY;
                customEv.pageX = ev.pageX;
                customEv.pageY = ev.pageY;
            }

            /**
             * @name __convertPointerType
             * @memberof plat.ui.DomEvent
             * @kind function
             * @access private
             * 
             * @description
             * Converts pointer type to a standardized string.
             * 
             * @param {any} pointerType The pointer type as either a number or a string.
             * @param {string} eventType The touch event type.
             * 
             * @returns {string} The standardized pointer type.
             */
            private __convertPointerType(pointerType: any, eventType: string): string {
                switch (<any>pointerType) {
                    case MSPointerEvent.MSPOINTER_TYPE_MOUSE:
                        return 'mouse';
                    case MSPointerEvent.MSPOINTER_TYPE_PEN:
                        return 'pen';
                    case MSPointerEvent.MSPOINTER_TYPE_TOUCH:
                        return 'touch';
                }

                return (eventType.indexOf('mouse') === -1) ? 'touch' : 'mouse';
            }
        }

        /**
         * @name ICustomDomEventInstance
         * @memberof plat.ui
         * @kind interface
         * @exported false
         * 
         * @extends {plat.ui.IDomEventInstance}
         * 
         * @description
         * A specialized object for managing a single custom touch event in {@link plat.ui.DomEvents|DomEvents}.
         */
        interface ICustomDomEventInstance extends IDomEventInstance {
            /**
             * @name count
             * @memberof plat.ui.ICustomDomEventInstance
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The number of listeners added for this event on this element.
             */
            count: number;

            /**
             * @name trigger
             * @memberof plat.ui.ICustomDomEventInstance
             * @kind function
             * @access public
             * 
             * @description
             * Triggers its event on its element.
             * 
             * @param {plat.ui.IPointerEvent} ev The current touch event object used to extend the 
             * newly created custom event.
             * 
             * @returns {void}
             */
            trigger(ev: IPointerEvent): void;
        }

        /**
         * @name IDomEventInstance
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object used for managing a single custom event.
         */
        export interface IDomEventInstance {
            /**
             * @name element
             * @memberof plat.ui.IDomEventInstance
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * The node or window object associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             */
            element: any;

            /**
             * @name event
             * @memberof plat.ui.IDomEventInstance
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The event type associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             */
            event: string;

            /**
             * @name initialize
             * @memberof plat.ui.IDomEventInstance
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Initializes the element and event of this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @param {Node} element The element associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * @param {string} event The event associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @returns {void}
             */
            initialize(element: Node, event: string): void;
            /**
             * @name initialize
             * @memberof plat.ui.IDomEventInstance
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Initializes the element and event of this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @param {Window} element The window object.
             * @param {string} event The event associated with this {@link plat.ui.IDomEventInstance|IDomEventInstance} object.
             * 
             * @returns {void}
             */
            initialize(element: Window, event: string): void;

            /**
             * @name trigger
             * @memberof plat.ui.IDomEventInstance
             * @kind function
             * @access public
             * 
             * @description
             * Triggers its event on its element.
             * 
             * @param {Object} eventExtension? An event extension to extend the dispatched CustomEvent.
             * 
             * @returns {void}
             */
            trigger(eventExtension?: Object): void;
        }

        /**
         * @name ICustomEventListener
         * @memberof plat.ui
         * @kind interface
         * @exported false
         * 
         * @extends {plat.IObject<EventListener>}
         * 
         * @description
         * Describes the touch event listeners for the document.
         */
        interface ICustomEventListener extends IObject<EventListener> {
            /**
             * @name start
             * @memberof plat.ui.ICustomEventListener
             * @kind property
             * @access public
             * 
             * @type {EventListener}
             * 
             * @description
             * The touch start event.
             */
            start: EventListener;
            /**
             * @name end
             * @memberof plat.ui.ICustomEventListener
             * @kind property
             * @access public
             * 
             * @type {EventListener}
             * 
             * @description
             * The touch end event.
             */
            end: EventListener;
            /**
             * @name move
             * @memberof plat.ui.ICustomEventListener
             * @kind property
             * @access public
             * 
             * @type {EventListener}
             * 
             * @description
             * The touch move event.
             */
            move: EventListener;
        }

        /**
         * @name IExtendedEvent
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {Event}
         * 
         * @description
         * An extended event object potentially containing coordinate and movement information.
         */
        export interface IExtendedEvent extends Event {
            /**
             * @name clientX
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event on the screen relative to the upper left corner of the 
             * browser window. This value cannot be affected by scrolling.
             */
            clientX?: number;

            /**
             * @name clientY
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event on the screen relative to the upper left corner of the 
             * browser window. This value cannot be affected by scrolling.
             */
            clientY?: number;

            /**
             * @name screenX
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event on the screen relative to the upper left corner of the 
             * physical screen or monitor.
             */
            screenX?: number;

            /**
             * @name screenY
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event on the screen relative to the upper left corner of the 
             * physical screen or monitor.
             */
            screenY?: number;

            /**
             * @name pageX
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event on the screen relative to the upper left corner of the 
             * fully rendered content area in the browser window. This value can be altered and/or affected by 
             * embedded scrollable pages when the scroll bar is moved.
             */
            pageX?: number;

            /**
             * @name pageY
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event on the screen relative to the upper left corner of the 
             * fully rendered content area in the browser window. This value can be altered and/or affected by 
             * embedded scrollable pages when the scroll bar is moved.
             */
            pageY?: number;

            /**
             * @name offsetX
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event relative to the top-left corner of the 
             * offsetParent element that fires the event.
             */
            offsetX?: number;

            /**
             * @name offsetY
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event relative to the top-left corner of the 
             * offsetParent element that fires the event.
             */
            offsetY?: number;

            /**
             * @name offset
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IPoint}
             * 
             * @description
             * The x and y-coordinates of the event as an object relative to the top-left corner of the 
             * offsetParent element that fires the event.
             */
            offset: IPoint;

            /**
             * @name direction
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The potential direction associated with the event.
             */
            direction?: string;

            /**
             * @name velocity
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IVelocity}
             * 
             * @description
             * The potential velocity associated with the event.
             */
            velocity?: IVelocity;

            /**
             * @name touches
             * @memberof plat.ui.IExtendedEvent
             * @kind property
             * @access public
             * 
             * @type {Array<plat.ui.IExtendedEvent>}
             * 
             * @description
             * An array containing all current touch points. The IExtendedEvents 
             * may slightly differ depending on the browser implementation.
             */
            touches?: Array<IExtendedEvent>;
        }

        /**
         * @name IPointerEvent
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.ui.IExtendedEvent}
         * 
         * @description
         * An extended event object potentially containing coordinate and movement information as 
         * well as pointer type for pointer events.
         */
        export interface IPointerEvent extends IExtendedEvent {
            /**
             * @name pointerType
             * @memberof plat.ui.IPointerEvent
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of interaction associated with the touch event ('touch', 'pen', 'mouse', '').
             */
            pointerType?: string;

            /**
             * @name pointerId
             * @memberof plat.ui.IPointerEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * A unique touch identifier.
             */
            pointerId?: number;

            /**
             * @name identifier
             * @memberof plat.ui.IPointerEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * A unique touch identifier.
             */
            identifier?: number;
        }

        /**
         * @name IGestureEvent
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {CustomEvent}
         * 
         * @description
         * The type of event object passed into the listeners for our custom events.
         */
        export interface IGestureEvent extends CustomEvent {
            /**
             * @name clientX
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event on the screen relative to the upper left corner of the 
             * browser window. This value cannot be affected by scrolling.
             */
            clientX?: number;

            /**
             * @name clientY
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event on the screen relative to the upper left corner of the 
             * browser window. This value cannot be affected by scrolling.
             */
            clientY?: number;

            /**
             * @name screenX
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event on the screen relative to the upper left corner of the 
             * physical screen or monitor.
             */
            screenX?: number;

            /**
             * @name screenY
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event on the screen relative to the upper left corner of the 
             * physical screen or monitor.
             */
            screenY?: number;

            /**
             * @name pageX
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event on the screen relative to the upper left corner of the 
             * fully rendered content area in the browser window. This value can be altered and/or affected by 
             * embedded scrollable pages when the scroll bar is moved.
             */
            pageX?: number;

            /**
             * @name pageY
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event on the screen relative to the upper left corner of the 
             * fully rendered content area in the browser window. This value can be altered and/or affected by 
             * embedded scrollable pages when the scroll bar is moved.
             */
            pageY?: number;

            /**
             * @name offsetX
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate of the event relative to the top-left corner of the 
             * offsetParent element that fires the event.
             */
            offsetX?: number;

            /**
             * @name offsetY
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate of the event relative to the top-left corner of the 
             * offsetParent element that fires the event.
             */
            offsetY?: number;

            /**
             * @name direction
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The potential direction associated with the event.
             */
            direction?: string;

            /**
             * @name velocity
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IVelocity}
             * 
             * @description
             * The potential velocity associated with the event.
             */
            velocity?: IVelocity;

            /**
             * @name touches
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {Array<plat.ui.IExtendedEvent>}
             * 
             * @description
             * An array containing all current touch points. The IExtendedEvents 
             * may slightly differ depending on the browser implementation.
             */
            touches?: Array<IExtendedEvent>;

            /**
             * @name pointerType
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of interaction associated with the touch event ('touch', 'pen', 'mouse', '').
             */
            pointerType?: string;

            /**
             * @name identifier
             * @memberof plat.ui.IGestureEvent
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * A unique touch identifier.
             */
            identifier?: number;
        }

        /**
         * @name IGestureListener
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * The listener interface for our custom DOM events.
         */
        export interface IGestureListener {
            /**
             * @memberof plat.ui.IGestureListener
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * The method signature for a {@link plat.ui.IGestureListener|IGestureListener}. 
             * An EventListener with the argument as an {@link plat.ui.IGestureEvent|IGestureEvent}.
             * 
             * @param {plat.ui.IGestureEvent} ev The gesture event object.
             * 
             * @returns {void}
             */
            (ev?: IGestureEvent): void;
        }

        /**
         * @name IEventSubscriber
         * @memberof plat.ui
         * @kind interface
         * 
         * @extends {plat.ui.IGestures<plat.ui.IDomEventInstance>}
         * 
         * @description
         * Describes an object to keep track of a single 
         * element's registered custom event types.
         */
        export interface IEventSubscriber extends IGestures<IDomEventInstance> {
            /**
             * @name gestureCount
             * @memberof plat.ui.IEventSubscriber
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The total registered gesture count for the associated element.
             */
            gestureCount: number;
        }

        /**
         * @name IGestures
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object containing information 
         * regarding all our custom events.
         * 
         * @typeparam {any} T The type of objects/primitives contained in this object.
         */
        export interface IGestures<T> {
            /**
             * @name $tap
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the tap event.
             */
            $tap?: T;

            /**
             * @name $dbltap
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the dbltap event.
             */
            $dbltap?: T;

            /**
             * @name $hold
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the hold event.
             */
            $hold?: T;

            /**
             * @name $release
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the release event.
             */
            $release?: T;

            /**
             * @name $swipe
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the swipe event.
             */
            $swipe?: T;

            /**
             * @name $swipeleft
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the swipeleft event.
             */
            $swipeleft?: T;

            /**
             * @name $swiperight
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the swiperight event.
             */
            $swiperight?: T;

            /**
             * @name $swipeup
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the swipeup event.
             */
            $swipeup?: T;

            /**
             * @name $swipedown
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the swipedown event.
             */
            $swipedown?: T;

            /**
             * @name $track
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the track event.
             */
            $track?: T;

            /**
             * @name $trackleft
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the trackleft event.
             */
            $trackleft?: T;

            /**
             * @name $trackright
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the trackright event.
             */
            $trackright?: T;

            /**
             * @name $trackup
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the trackup event.
             */
            $trackup?: T;

            /**
             * @name $trackdown
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the trackdown event.
             */
            $trackdown?: T;

            /**
             * @name $trackend
             * @memberof plat.ui.IGestures
             * @kind property
             * @access public
             * 
             * @type {T}
             * 
             * @description
             * The string type|number of events associated with the trackend event.
             */
            $trackend?: T;
        }

        /**
         * @name IPoint
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object containing x and y coordinates.
         */
        export interface IPoint {
            /**
             * @name x
             * @memberof plat.ui.IPoint
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The x-coordinate.
             */
            x: number;

            /**
             * @name y
             * @memberof plat.ui.IPoint
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The y-coordinate.
             */
            y: number;
        }

        /**
         * @name IVelocity
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object containing a speed in both the horizontal and vertical directions.
         */
        export interface IVelocity {
            /**
             * @name x
             * @memberof plat.ui.IVelocity
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The horizontal, x velocity.
             */
            x: number;

            /**
             * @name y
             * @memberof plat.ui.IVelocity
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The vertical, y velocity.
             */
            y: number;
        }

        /**
         * @name IIntervals
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object containing time interval information that 
         * governs the behavior of certain custom DOM events.
         */
        export interface IIntervals {
            /**
             * @name tapInterval
             * @memberof plat.ui.IIntervals
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The max time in milliseconds a user can hold down on the screen 
             * for a tap event to be fired. Defaults to 200 ms.
             */
            tapInterval: number;

            /**
             * @name dblTapInterval
             * @memberof plat.ui.IIntervals
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The max time in milliseconds a user can wait between consecutive 
             * taps for a dbltap event to be fired. Defaults to 300 ms.
             */
            dblTapInterval: number;

            /**
             * @name holdInterval
             * @memberof plat.ui.IIntervals
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The time in milliseconds a user must hold down on the screen 
             * before a hold event is fired or a release event can be fired. 
             * Defaults to 400 ms.
             */
            holdInterval: number;

            /**
             * @name dblTapZoomDelay
             * @memberof plat.ui.IIntervals
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The delay in milliseconds between the time a user taps to the time 
             * the tap event fires. Used in the case where a double-tap-to-zoom 
             * feature is required. Defaults to 0 ms.
             */
            dblTapZoomDelay: number;
        }

        /**
         * @name IDistances
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object containing distance information that 
         * governs the behavior of certain custom DOM events.
         */
        export interface IDistances {
            /**
             * @name minScrollDistance
             * @memberof plat.ui.IDistances
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The minimum distance a user must move after touch down to register 
             * it as a scroll instead of a tap. Defaults to 5.
             */
            minScrollDistance: number;

            /**
             * @name maxDblTapDistance
             * @memberof plat.ui.IDistances
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The maximum distance between consecutive taps a user is allowed to 
             * register a dbltap event. Defaults to 20.
             */
            maxDblTapDistance: number;
        }

        /**
         * @name IVelocities
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object containing velocity information that 
         * governs the behavior of certain custom DOM events.
         */
        export interface IVelocities {
            /**
             * @name minSwipeVelocity
             * @memberof plat.ui.IVelocities
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The minimum velocity a user must move after touch down to register 
             * a swipe event. Defaults to 0.8.
             */
            minSwipeVelocity: number;
        }

        /**
         * @name IDefaultStyle
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes an object used for creating a custom class for styling an element 
         * listening for a custom DOM event.
         */
        export interface IDefaultStyle {
            /**
             * @name className
             * @memberof plat.ui.IDefaultStyle
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The className that will be used to define the custom style.
             */
            className: string;

            /**
             * @name styles
             * @memberof plat.ui.IDefaultStyle
             * @kind property
             * @access public
             * 
             * @type {Array<string>}
             * 
             * @description
             * An array of string styles in the format:
             * CSS identifier : value
             * (e.g. 'width : 100px')
             */
            styles: Array<string>;
        }

        /**
         * @name IDomEventsConfig
         * @memberof plat.ui
         * @kind interface
         * 
         * @description
         * Describes a configuration object for all custom DOM events.
         */
        export interface IDomEventsConfig {
            /**
             * @name intervals
             * @memberof plat.ui.IDomEventsConfig
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IIntervals}
             * 
             * @description
             * An object containing the different time intervals that govern the behavior of certain 
             * custom DOM events.
             */
            intervals: IIntervals;

            /**
             * @name distances
             * @memberof plat.ui.IDomEventsConfig
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IDistances}
             * 
             * @description
             * An object containing the different minimum/maximum distances that govern the behavior of certain 
             * custom DOM events.
             */
            distances: IDistances;

            /**
             * @name velocities
             * @memberof plat.ui.IDomEventsConfig
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IVelocities}
             * 
             * @description
             * An object containing the different minimum/maximum velocities that govern the behavior of certain 
             * custom DOM events.
             */
            velocities: IVelocities;

            /**
             * @name styleConfig
             * @memberof plat.ui.IDomEventsConfig
             * @kind property
             * @access public
             * 
             * @type {Array<plat.ui.IDefaultStyle>}
             * 
             * @description
             * The default CSS styles applied to elements listening for custom DOM events.
             */
            styleConfig: Array<IDefaultStyle>;
        }

    /**
     * @name animations
     * @memberof plat.ui
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds all the classes and interfaces related to UI animation components for platypus.
     */
        export module animations {
            /**
             * @name Animator
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @implements {plat.ui.animations.IAnimator}
             * 
             * @description
             * A class used for animating elements.
             */
            export class Animator implements IAnimator {
                /**
                 * @name $Compat
                 * @memberof plat.ui.animations.Animator
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ICompat}
                 * 
                 * @description
                 * Reference to the {@link plat.ICompat|ICompat} injectable.
                 */
                $Compat: ICompat = acquire(__Compat);

                /**
                 * @name _elements
                 * @memberof plat.ui.animations.Animator
                 * @kind property
                 * @access protected
                 * 
                 * @type {plat.IObject<plat.ui.animations.IAnimatedElement>}
                 * 
                 * @description
                 * All elements currently being animated.
                 */
                _elements: IObject<IAnimatedElement> = {};
        
                /**
                 * @name __cssWarning
                 * @memberof plat.ui.animations.Animator
                 * @kind property
                 * @access private
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * Indicates if a warning regarding our CSS was previously fired.
                 */
                private __cssWarning = false;
        
                /**
                 * @name animate
                 * @memberof plat.ui.animations.Animator
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Animates the element with the defined animation denoted by the key.
                 * 
                 * @param {Element} element The Element to be animated.
                 * @param {string} key The identifier specifying the type of animation.
                 * @param {any} options Specified options for the animation.
                 * 
                 * @returns {plat.ui.animations.IAnimationPromise} A promise that resolves when the animation is finished.
                 */
                animate(element: Element, key: string, options?: any): IAnimationPromise {
                    if (!isNode(element) || element.nodeType !== Node.ELEMENT_NODE || this.__parentIsAnimating(element)) {
                        return this.__resolvePromise();
                    }

                    var $compat = this.$Compat,
                        animation = animationInjectors[key],
                        jsAnimation = jsAnimationInjectors[key],
                        animationInstance: IBaseAnimation;

                    if (!$compat.animationSupported || isUndefined(animation)) {
                        if (isUndefined(jsAnimation)) {
                            return this.__resolvePromise();
                        }

                        animationInstance = jsAnimation.inject();
                    } else {
                        if (!(this.__cssWarning || $compat.platCss)) {
                            var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                            $exception.warn('CSS animation occurring and platypus.css was not found prior to platypus.js. If you ' +
                                'intend to use platypus.css, please move it before platypus.js inside your head or body declaration.',
                                $exception.ANIMATION);
                            this.__cssWarning = true;
                        }

                        animationInstance = animation.inject();
                    }

                    var id = this.__setAnimationId(element, animationInstance);
                    this.__stopChildAnimations(element, id);
                    var animationObj = this._elements[id],
                        animationPromise = (<BaseAnimation>animationInstance)._init(element, options).then(() => {
                            animationObj.promise = null;
                            animationObj.animationEnd();
                        });

                    if (!isNull(animationObj.promise)) {
                        return animationObj.promise.then(() => {
                            return animationPromise;
                        });
                    }

                    return (animationObj.promise = animationPromise);
                }
        
                /**
                 * @name __parentIsAnimating
                 * @memberof plat.ui.animations.Animator
                 * @kind function
                 * @access private
                 * 
                 * @description
                 * Checks whether or not any parent elements are animating.
                 * 
                 * @param {Node} element The element whose parents we need to check.
                 * 
                 * @returns {boolean} Whether or not animating parents were found.
                 */
                private __parentIsAnimating(element: Node): boolean {
                    while (!isDocument(element = element.parentNode) && element.nodeType === Node.ELEMENT_NODE) {
                        if (hasClass(<HTMLElement>element, __Animating)) {
                            return true;
                        }
                    }

                    return false;
                }
        
                /**
                 * @name __setAnimationId
                 * @memberof plat.ui.animations.Animator
                 * @kind function
                 * @access private
                 * 
                 * @description
                 * Sets an new, unique animation ID and denotes the element as currently being animated.
                 * 
                 * @param {Node} element The element being animated.
                 * @param {plat.ui.animations.IBaseAnimation} animationInstance The animation instance doing the animating.
                 * 
                 * @returns {string} The new animation ID.
                 */
                private __setAnimationId(element: Node, animationInstance: IBaseAnimation): string {
                    var elements = this._elements,
                        plat = (<ICustomElement>element).__plat,
                        id: string;

                    if (isUndefined(plat)) {
                        (<ICustomElement>element).__plat = plat = {};
                    }

                    if (isUndefined(plat.animation)) {
                        plat.animation = id = uniqueId('animation_');
                    } else {
                        id = plat.animation;
                    }

                    var animationObj = elements[id],
                        removeListener = (reanimating?: boolean) => {
                        if (reanimating === true) {
                            animationInstance.cancel();
                            return;
                        }

                        removeClass(<HTMLElement>element, __Animating);
                        deleteProperty(elements, id);
                        deleteProperty(plat, 'animation');
                        if (isEmpty(plat)) {
                            deleteProperty(element, '__plat');
                        }
                    };

                    if (isUndefined(animationObj)) {
                        addClass(<HTMLElement>element, __Animating);
                        elements[id] = {
                            animationEnd: removeListener
                        };
                    } else {
                        animationObj.animationEnd(true);
                        animationObj.animationEnd = removeListener;
                    }

                    return id;
                }
        
                /**
                 * @name __stopChildAnimations
                 * @memberof plat.ui.animations.Animator
                 * @kind function
                 * @access private
                 * 
                 * @description
                 * Forces child nodes of an animating element to stop animating.
                 * 
                 * @param {Element} element The element being animated.
                 * @param {string} id The animation ID.
                 * 
                 * @returns {void}
                 */
                private __stopChildAnimations(element: Element, id: string): void {
                    var elements = this._elements,
                        animatedElements = Array.prototype.slice.call(element.querySelectorAll('.' + __Animating)),
                        length = animatedElements.length,
                        animatedElement: ICustomElement,
                        plat: ICustomElementProperty;

                    while (length-- > 0) {
                        animatedElement = animatedElements[length];
                        plat = animatedElement.__plat;
                        if (isUndefined(plat) || isUndefined(plat.animation)) {
                            continue;
                        }

                        id = plat.animation;
                        if (isFunction(elements[id])) {
                            elements[id].animationEnd();
                        }
                    }
                }
        
                /**
                 * @name __resolvePromise
                 * @memberof plat.ui.animations.Animator
                 * @kind function
                 * @access private
                 * 
                 * @description
                 * Immediately resolves an empty {@link plat.ui.animations.AnimationPromise|AnimationPromise}.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<void>} The immediately resolved 
                 * {@link plat.ui.animations.AnimationPromise|AnimationPromise}.
                 */
                private __resolvePromise(): IAnimationThenable<void> {
                    return new AnimationPromise((resolve) => {
                        resolve();
                    });
                }
            }

            /**
             * The Type for referencing the '$Animator' injectable as a dependency.
             */
            export function IAnimator(): IAnimator {
                return new Animator();
            }

            register.injectable('$Animator', IAnimator);

            /**
             * @name IAnimator
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @description
             * Describes an object used for animating elements.
             */
            export interface IAnimator {
                /**
                 * @name animate
                 * @memberof plat.ui.animations.IAnimator
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Animates the element with the defined animation denoted by the key.
                 * 
                 * @param {Element} element The Element to be animated.
                 * @param {string} key The identifier specifying the type of animation.
                 * @param {any} options Specified options for the animation.
                 * 
                 * @returns {plat.ui.animations.IAnimationPromise} A promise that resolves when the animation is finished.
                 */
                animate(element: Element, key: string, options?: any): IAnimationPromise;
            }
    
            /**
             * @name IAnimatedElement
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @description
             * Describes an object representing a currenlty animated element.
             */
            export interface IAnimatedElement {
                /**
                 * @name animationEnd
                 * @memberof plat.ui.animations.IAnimatedElement
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * The function called at the conclusion of the animation.
                 * 
                 * @param {boolean} reanimated? Specifies whether the element is being reanimated while 
                 * in a current animation.
                 * 
                 * @returns {void}
                 */
                animationEnd: (reanimated?: boolean) => void;

                /**
                 * @name promise
                 * @memberof plat.ui.animations.IAnimatedElement
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ui.animations.IAnimationThenable<any>}
                 * 
                 * @description
                 * A promise representing an element's current state of animation.
                 */
                promise?: IAnimationThenable<any>;
            }
    
            /**
             * @name AnimationPromise
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.async.Promise<void>}
             * @implements {plat.ui.animations.IAnimationPromise}
             * 
             * @description
             * Describes a type of {@link plat.async.Promise|Promise} that can be optionally cancelled.
             */
            export class AnimationPromise extends async.Promise<void> implements IAnimationPromise {
                /**
                 * @name __animationInstance
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.ui.animations.IBaseAnimation}
                 * 
                 * @description
                 * The animation instance to cancel if needed.
                 */
                private __animationInstance: IBaseAnimation;

                /**
                 * @name constructor
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 0
                 * 
                 * @description
                 * The constructor method for the {@link plat.async.AjaxPromise}.
                 * 
                 * @param {(resolve: (value?: void) => any) => void} resolveFunction A resolve function 
                 * that only allows for a resolve of void and no reject.
                 * 
                 * @returns {plat.ui.animations.AnimationPromise}
                 */
                constructor(resolveFunction: (resolve: (value?: void) => any) => void);
                /**
                 * @name constructor
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 1
                 * 
                 * @description
                 * The constructor method for the {@link plat.async.AjaxPromise}.
                 * 
                 * @param {(resolve: (value?: void) => any) => void} resolveFunction A resolve function 
                 * that only allows for a resolve of void and no reject.
                 * @param {any} promise The promise object to allow for cancelling the {@link plat.ui.animations.AnimationPromise}.
                 * 
                 * @returns {plat.ui.animations.AnimationPromise}
                 */
                constructor(resolveFunction: (resolve: (value?: void) => any) => void, promise: any);
                constructor(resolveFunction: (resolve: (value?: void) => any) => void, promise?: any) {
                    super(resolveFunction);
                    if (!isNull(promise)) {
                        this.__animationInstance = promise.__animationInstance;
                    }
                }

                /**
                 * @name cancel
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A method to cancel the associated animation.
                 * 
                 * @returns {plat.ui.animations.AnimationPromise} This promise instance.
                 */
                cancel(): IAnimationPromise {
                    if (!isNull(this.__animationInstance)) {
                        this.__animationInstance.cancel();
                        this.__animationInstance.end();
                    }

                    return this;
                }

                /**
                 * @name then
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 0
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills.
                 * 
                 * @typeparam {any} U The type of the object returned from the fulfill callbacks, which will be carried to the 
                 * next then method in the promise chain.
                 * 
                 * @param {(success: void) => U} onFulfilled A method called when/if the promise fulfills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>}
                 */
                then<U>(onFulfilled: (success: void) => U): IAnimationThenable<U>;
                /**
                 * @name then
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 1
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills.
                 * 
                 * @typeparam {any} U The type of the object returned from the fulfill callbacks, which will be carried to the 
                 * next then method in the promise chain.
                 * 
                 * @param {(success: void) => plat.ui.animations.IAnimationThenable<U>} onFulfilled A method called when/if the promise fulfills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>}
                 */
                then<U>(onFulfilled: (success: void) => IAnimationThenable<U>): IAnimationThenable<U>;
                /**
                 * @name then
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 2
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills.
                 * 
                 * @typeparam {any} U The type of the object returned from the fulfill callbacks, which will be carried to the 
                 * next then method in the promise chain.
                 * 
                 * @param {(success: void) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulfills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>}
                 */
                then<U>(onFulfilled: (success: void) => async.IThenable<U>): IAnimationThenable<U>;
                then<U>(onFulfilled: (success: void) => any): IAnimationThenable<U>  {
                    return <IAnimationThenable<U>><any>super.then<U>(onFulfilled);
                }

                /**
                 * @name catch
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 0
                 * 
                 * @description
                 * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(error: any) => plat.ui.animations.IAnimationThenable<U>} onRejected A method called when/if the promise rejects. 
                 * If undefined the next onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                catch<U>(onRejected: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;
                /**
                 * @name catch
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 1
                 * 
                 * @description
                 * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next
                 * onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                catch<U>(onRejected: (error: any) => U): IAnimationThenable<U>;
                catch<U>(onRejected: (error: any) => any): IAnimationThenable<U> {
                    return <IAnimationThenable<U>><any>super.catch<U>(onRejected);
                }
            }

            /**
             * @name IAnimationThenable
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @extends {plat.async.IThenable<R>}
             * 
             * @description
             * Describes a chaining function that fulfills when the previous link is complete and is 
             * able to be caught in the case of an error.
             * 
             * @typeparam {any} R The return type of the thenable.
             */
            export interface IAnimationThenable<R> extends async.IThenable<R> {
                /**
                 * @name cancel
                 * @memberof plat.ui.animations.IAnimationThenable
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A method to cancel the associated animation.
                 * 
                 * @returns {plat.ui.animations.AnimationPromise} This promise instance.
                 */
                cancel(): IAnimationPromise;

                /**
                 * @name then
                 * @memberof plat.ui.animations.IAnimationThenable
                 * @kind function
                 * @access public
                 * @variation 0
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills/rejects.
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(success: R) => plat.ui.animations.IAnimationThenable<U>} onFulfilled A method called when/if the promise fulills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * @param {(error: any) => plat.ui.animations.IAnimationThenable<U>} onRejected? A method called when/if the promise rejects. 
                 * If undefined the next onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                then<U>(onFulfilled: (success: R) => IAnimationThenable<U>,
                    onRejected?: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;
                /**
                 * @name then
                 * @memberof plat.ui.animations.IAnimationThenable
                 * @kind function
                 * @access public
                 * @variation 1
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills/rejects.
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(success: R) => plat.ui.animations.IAnimationThenable<U>} onFulfilled A method called when/if the promise fulills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * @param {(error: any) => U} onRejected? A method called when/if the promise rejects. 
                 * If undefined the next onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                then<U>(onFulfilled: (success: R) => IAnimationThenable<U>, onRejected?: (error: any) => U): IAnimationThenable<U>;
                /**
                 * @name then
                 * @memberof plat.ui.animations.IAnimationThenable
                 * @kind function
                 * @access public
                 * @variation 2
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills/rejects.
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * @param {(error: any) => plat.ui.animations.IAnimationThenable<U>} onRejected? A method called when/if the promise rejects. 
                 * If undefined the next onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;
                /**
                 * @name then
                 * @memberof plat.ui.animations.IAnimationThenable
                 * @kind function
                 * @access public
                 * @variation 3
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills/rejects.
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * @param {(error: any) => U} onRejected? A method called when/if the promise rejects. 
                 * If undefined the next onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IAnimationThenable<U>;

                /**
                 * @name catch
                 * @memberof plat.ui.animations.IAnimationThenable
                 * @kind function
                 * @access public
                 * @variation 0
                 * 
                 * @description
                 * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(error: any) => plat.ui.animations.IAnimationThenable<U>} onRejected A method called when/if the promise rejects. 
                 * If undefined the next onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                catch<U>(onRejected: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;
                /**
                 * @name catch
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 1
                 * 
                 * @description
                 * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}
                 * 
                 * @typeparam {any} U The return type of the returned promise.
                 * 
                 * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next
                 * onRejected method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>} A promise that resolves with the input type parameter U.
                 */
                catch<U>(onRejected: (error: any) => U): IAnimationThenable<U>;
            }
    
            /**
             * @name IAnimationPromise
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @extends {plat.ui.animations.IAnimationThenable<void>}
             * 
             * @description
             * Describes a type of {@link plat.async.IPromise|IPromise} that fulfills when an animation is 
             * finished and can be optionally cancelled.
             */
            export interface IAnimationPromise extends IAnimationThenable<void> {
                /**
                 * @name cancel
                 * @memberof plat.ui.animations.IAnimationPromise
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A method to cancel the associated animation.
                 * 
                 * @returns {plat.ui.animations.AnimationPromise} This promise instance.
                 */
                cancel(): IAnimationPromise;

                /**
                 * @name then
                 * @memberof plat.ui.animations.IAnimationPromise
                 * @kind function
                 * @access public
                 * @variation 0
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills.
                 * 
                 * @typeparam {any} U The type of the object returned from the fulfill callbacks, which will be carried to the 
                 * next then method in the promise chain.
                 * 
                 * @param {(success: void) => U} onFulfilled A method called when/if the promise fulfills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>}
                 */
                then<U>(onFulfilled: (success: void) => U): IAnimationThenable<U>;
                /**
                 * @name then
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 1
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills.
                 * 
                 * @typeparam {any} U The type of the object returned from the fulfill callbacks, which will be carried to the 
                 * next then method in the promise chain.
                 * 
                 * @param {(success: void) => plat.ui.animations.IAnimationThenable<U>} onFulfilled A method called when/if the promise fulfills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>}
                 */
                then<U>(onFulfilled: (success: void) => IAnimationThenable<U>): IAnimationThenable<U>;
                /**
                 * @name then
                 * @memberof plat.ui.animations.AnimationPromise
                 * @kind function
                 * @access public
                 * @variation 2
                 * 
                 * @description
                 * Takes in two methods, called when/if the promise fulfills.
                 * 
                 * @typeparam {any} U The type of the object returned from the fulfill callbacks, which will be carried to the 
                 * next then method in the promise chain.
                 * 
                 * @param {(success: void) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulfills. 
                 * If undefined the next onFulfilled method in the promise chain will be called.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<U>}
                 */
                then<U>(onFulfilled: (success: void) => async.IThenable<U>): IAnimationThenable<U>;
            }

            /**
             * @name BaseAnimation
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @implements {plat.ui.animations.IBaseAnimation}
             * 
             * @description
             * A class representing a single animation for a single element.
             */
            export class BaseAnimation implements IBaseAnimation {
                /**
                 * @name $Compat
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ICompat}
                 * 
                 * @description
                 * Reference to the {@link plat.ICompat|ICompat} injectable.
                 */
                $Compat: ICompat = acquire(__Compat);

                /**
                 * @name element
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {HTMLElement}
                 * 
                 * @description
                 * The node having the animation performed on it.
                 */
                element: HTMLElement;

                /**
                 * @name dom
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ui.IDom}
                 * 
                 * @description
                 * Contains DOM helper methods for manipulating this control's element.
                 */
                dom: IDom = acquire(__Dom);

                /**
                 * @name options
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {any}
                 * 
                 * @description
                 * Specified options for the animation.
                 */
                options: any;
        
                /**
                 * @name __resolve
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind property
                 * @access private
                 * 
                 * @type {() => void}
                 * 
                 * @description
                 * The resolve function for the end of the animation.
                 */
                private __resolve: () => void;

                /**
                 * @name initialize
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function for initializing the animation or any of its properties before start.
                 * 
                 * @returns {void}
                 */
                initialize(): void { }
        
                /**
                 * @name start
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function denoting the start of the animation.
                 * 
                 * @returns {void}
                 */
                start(): void { }
        
                /**
                 * @name end
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to be called when the animation is over.
                 * 
                 * @returns {void}
                 */
                end(): void {
                    if (isFunction(this.__resolve)) {
                        this.__resolve();
                    }
                    this.dispose();
                }
        
                /**
                 * @name cancel
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to be called to let it be known the animation is being cancelled.
                 * 
                 * @returns {void}
                 */
                cancel(): void {
                    this.end();
                }
        
                /**
                 * @name dispose
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function for reverting any modifications or changes that may have been made as a 
                 * result of this animation.
                 * 
                 * @returns {void}
                 */
                dispose(): void {
                    this.__resolve = null;
                }
        
                /**
                 * @name _init
                 * @memberof plat.ui.animations.BaseAnimation
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Initializes the element and key properties of this animation and passes in the function 
                 * to resolve when finished.
                 * 
                 * @param {Element} element The element on which the animation will occur.
                 * @param {any} options Specified options for the animation.
                 * 
                 * @returns {plat.ui.animations.IAnimationPromise} The promise that will resolve when the 
                 * animation is complete and end() is called.
                 */
                _init(element: Element, options?: any): IAnimationPromise {
                    this.element = <HTMLElement>element;
                    this.options = options;

                    return new AnimationPromise((resolve) => {
                        this.__resolve = resolve;
                        this.initialize();
                        this.start();
                    }, { __animationInstance: this });
                }
            }

            /**
             * @name IBaseAnimation
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @description
             * Describes an object representing a single animation for a single element.
             */
            export interface IBaseAnimation {
                /**
                 * @name element
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {HTMLElement}
                 * 
                 * @description
                 * The node having the animation performed on it.
                 */
                element: HTMLElement;

                /**
                 * @name dom
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ui.IDom}
                 * 
                 * @description
                 * Contains DOM helper methods for manipulating this control's element.
                 */
                dom: IDom;

                /**
                 * @name options
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {any}
                 * 
                 * @description
                 * Specified options for the animation.
                 */
                options: any;

                /**
                 * @name initialize
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function for initializing the animation or any of its properties before start.
                 * 
                 * @returns {void}
                 */
                initialize(): void;

                /**
                 * @name start
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function denoting the start of the animation.
                 * 
                 * @returns {void}
                 */
                start(): void;

                /**
                 * @name end
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to be called when the animation is over.
                 * 
                 * @returns {void}
                 */
                end(): void;

                /**
                 * @name cancel
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to be called to let it be known the animation is being cancelled.
                 * 
                 * @returns {void}
                 */
                cancel(): void;

                /**
                 * @name dispose
                 * @memberof plat.ui.animations.IBaseAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function for reverting any modifications or changes that may have been made as a 
                 * result of this animation.
                 * 
                 * @returns {void}
                 */
                dispose(): void;
            }

            /**
             * @name CssAnimation
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.BaseAnimation}
             * @implements {plat.ui.animations.ICssAnimation}
             * 
             * @description
             * A class representing a single CSS animation for a single element.
             */
            export class CssAnimation extends BaseAnimation implements ICssAnimation {
                /**
                 * @name __animationEvents
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.IAnimationEvents}
                 * 
                 * @description
                 * A set of browser compatible CSS animation events capable of being listened to.
                 */
                private __animationEvents: IAnimationEvents = this.$Compat.animationEvents;
                /**
                 * @name __subscribers
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {Array<() => void>}
                 * 
                 * @description
                 * A collection of animation event subscriptions used for chaining.
                 */
                private __subscribers: Array<() => void> = [];
                /**
                 * @name __removeListener
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.IRemoveListener}
                 * 
                 * @description
                 * The function to stop listening to the current event/animation in occurrence.
                 */
                private __removeListener: IRemoveListener;

                /**
                 * @name dispose
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function for reverting any modifications or changes that may have been made as a 
                 * result of this animation.
                 * 
                 * @returns {void}
                 */
                dispose(): void {
                    if (isFunction(this.__removeListener)) {
                        this.__removeListener();
                        this.__removeListener = null;
                    }
                    this.__subscribers = [];
                    super.dispose();
                }
        
                /**
                 * @name animationStart
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the start of an animation event.
                 * 
                 * @param {() => void} listener The function to call when the animation begins.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                animationStart(listener: () => void): ICssAnimation {
                    return this.__addEventListener(this.__animationEvents.$animationStart, listener);
                }
        
                /**
                 * @name transitionStart
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the start of a transition event.
                 * 
                 * @param {() => void} listener The function to call when the transition begins.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                transitionStart(listener: () => void): ICssAnimation {
                    return this.__addEventListener(this.__animationEvents.$transitionStart, listener);
                }
        
                /**
                 * @name animationEnd
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the end of an animation event.
                 * 
                 * @param {() => void} listener The function to call when the animation ends.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                animationEnd(listener: () => void): ICssAnimation {
                    return this.__addEventListener(this.__animationEvents.$animationEnd, listener);
                }
        
                /**
                 * @name animationEnd
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the end of a transition event.
                 * 
                 * @param {() => void} listener The function to call when the transition ends.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                transitionEnd(listener: () => void): ICssAnimation {
                    return this.__addEventListener(this.__animationEvents.$transitionEnd, listener);
                }
        
                /**
                 * @name __addEventListener
                 * @memberof plat.ui.animations.CssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Adds the listener for the desired event and handles subscription management and 
                 * chaining.
                 * 
                 * @param {string} event The event to subscribe to.
                 * @param {() => void} listener The function to call when the event fires.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                private __addEventListener(event: string, listener: () => void): ICssAnimation {
                    var subscribers = this.__subscribers,
                        subscriber = () => {
                            this.__removeListener = this.dom.addEventListener(this.element, event, (ev: Event) => {
                                this.__removeListener();
                                this.__removeListener = null;

                                if (subscribers.length === 0) {
                                    return;
                                }

                                listener.call(this);
                                subscribers.shift();

                                if (subscribers.length === 0) {
                                    return;
                                }

                                subscribers[0]();
                            }, false);
                        };

                    subscribers.push(subscriber);

                    if (subscribers.length === 1) {
                        subscriber();
                    }

                    return this;
                }
            }
    
            /**
             * @name ICssAnimation
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @extends {plat.ui.animations.IBaseAnimation}
             * 
             * @description
             * Describes an object representing a single CSS animation for a single element.
             */
            export interface ICssAnimation extends IBaseAnimation {
                /**
                 * @name animationStart
                 * @memberof plat.ui.animations.ICssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the start of an animation event.
                 * 
                 * @param {() => void} listener The function to call when the animation begins.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                animationStart(listener: () => void): ICssAnimation;
        
                /**
                 * @name transitionStart
                 * @memberof plat.ui.animations.ICssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the start of a transition event.
                 * 
                 * @param {() => void} listener The function to call when the transition begins.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                transitionStart(listener: () => void): ICssAnimation;
        
                /**
                 * @name animationEnd
                 * @memberof plat.ui.animations.ICssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the end of an animation event.
                 * 
                 * @param {() => void} listener The function to call when the animation ends.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                animationEnd(listener: () => void): ICssAnimation;
        
                /**
                 * @name animationEnd
                 * @memberof plat.ui.animations.ICssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to listen to the end of a transition event.
                 * 
                 * @param {() => void} listener The function to call when the transition ends.
                 * 
                 * @returns {plat.ui.animations.ICssAnimation} This instance (for chaining).
                 */
                transitionEnd(listener: () => void): ICssAnimation;
            }

            /**
             * @name JsAnimation
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.BaseAnimation}
             * @implements {plat.ui.animations.IJsAnimation}
             * 
             * @description
             * A class for creating a single JavaScript animation for a single element.
             */
            export class JsAnimation extends BaseAnimation implements IJsAnimation {
                /**
                 * @name isJs
                 * @memberof plat.ui.animations.JsAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * A flag specifying that this animation is a JavaScript implementation.
                 */
                isJs = true;
            }

            /**
             * @name IJsAnimation
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @extends {plat.ui.animations.IBaseAnimation}
             * 
             * @description
             * Describes an object representing a single JavaScript animation for a single element.
             */
            export interface IJsAnimation extends IBaseAnimation {
                /**
                 * @name isJs
                 * @memberof plat.ui.animations.IJsAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * A flag specifying that this animation is a JavaScript implementation.
                 */
                isJs: boolean;
            }

            /**
             * @name SimpleCssAnimation
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.CssAnimation}
             * @implements {plat.ui.animations.ISimpleCssAnimation}
             * 
             * @description
             * A simple CSS Animation class that places the 'plat-animation' class on an 
             * element, checks for animation properties, and waits for the animation to end.
             */
            export class SimpleCssAnimation extends CssAnimation implements ISimpleCssAnimation {
                /**
                 * @name $Window
                 * @memberof plat.ui.animations.SimpleCssAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {Window}
                 * 
                 * @description
                 * Reference to the Window injectable.
                 */
                $Window: Window = acquire(__Window);

                /**
                 * @name className
                 * @memberof plat.ui.animations.SimpleCssAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The class name added to the animated element.
                 */
                className = __SimpleAnimation;

                /**
                 * @name initialize
                 * @memberof plat.ui.animations.SimpleCssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function denoting the start of the animation.
                 * 
                 * @returns {void}
                 */
                start(): void {
                    var animationId = this.$Compat.animationEvents.$animation,
                        element = this.element,
                        className = this.className;

                    addClass(element, className);

                    var computedStyle = this.$Window.getComputedStyle(element),
                        animationName = computedStyle[<any>(animationId + 'Name')];
                    if (animationName === '' ||
                        animationName === 'none' ||
                        computedStyle[<any>(animationId + 'PlayState')] === 'paused') {
                        removeClass(element, className);
                        this.end();
                        return;
                    }

                    this.animationEnd(() => {
                        removeClass(element, className);
                        this.end();
                    });
                }

                /**
                 * @name cancel
                 * @memberof plat.ui.animations.SimpleCssAnimation
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to be called to let it be known the animation is being cancelled.
                 * 
                 * @returns {void}
                 */
                cancel(): void {
                    removeClass(this.element, this.className);
                    super.cancel();
                }
            }

            register.animation(__SimpleAnimation, SimpleCssAnimation);
    
            /**
             * @name ISimpleCssAnimation
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @extends {plat.ui.animations.ICssAnimation}
             * 
             * @description
             * An interface for extending the {@link plat.ui.animations.SimpleCssAnimation|SimpleCssAnimation} 
             * or {@link plat.ui.animations.SimpleCssTransition|SimpleCssTransition} and allowing for 
             * custom class names to initiate animations or transitions.
             */
            export interface ISimpleCssAnimation extends ICssAnimation {
                /**
                 * @name className
                 * @memberof plat.ui.animations.ISimpleCssAnimation
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The class name added to the animated element.
                 */
                className: string;
            }

            /**
             * @name FadeIn
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.SimpleCssAnimation}
             * 
             * @description
             * An animation control that fades in an element as defined by the included CSS.
             */
            export class FadeIn extends SimpleCssAnimation {
                /**
                 * @name className
                 * @memberof plat.ui.animations.FadeIn
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The class name added to the element fading in.
                 */
                className = __FadeIn;
            }

            register.animation(__FadeIn, FadeIn);
    
            /**
             * @name FadeOut
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.SimpleCssAnimation}
             * 
             * @description
             * An animation control that fades out an element as defined by the included CSS.
             */
            export class FadeOut extends SimpleCssAnimation {
                /**
                 * @name className
                 * @memberof plat.ui.animations.FadeOut
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The class name added to the element fading out.
                 */
                className = __FadeOut;
            }

            register.animation(__FadeOut, FadeOut);
    
            /**
             * @name Enter
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.SimpleCssAnimation}
             * 
             * @description
             * An animation control that causes an element to enter as defined by the included CSS.
             */
            export class Enter extends SimpleCssAnimation {
                /**
                 * @name className
                 * @memberof plat.ui.animations.Enter
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The class name added to the entering element.
                 */
                className = __Enter;
            }

            register.animation(__Enter, Enter);
    
            /**
             * @name Leave
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.SimpleCssAnimation}
             * 
             * @description
             * An animation control that causes an element to leave as defined by the included CSS.
             */
            export class Leave extends SimpleCssAnimation {
                /**
                 * @name className
                 * @memberof plat.ui.animations.Leave
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The class name added to the leaving element.
                 */
                className = __Leave;
            }

            register.animation(__Leave, Leave);

            /**
             * @name SimpleCssTransition
             * @memberof plat.ui.animations
             * @kind class
             * 
             * @extends {plat.ui.animations.CssAnimation}
             * @implements {plat.ui.animations.ISimpleCssTransition}
             * 
             * @description
             * A simple CSS Animation class that places the 'plat-transition' class on an 
             * element, checks for transition properties, and waits for the transition to end.
             */
            export class SimpleCssTransition extends CssAnimation implements ISimpleCssTransition {
                /**
                 * @name $Window
                 * @memberof plat.ui.animations.SimpleCssTransition
                 * @kind property
                 * @access public
                 * 
                 * @type {Window}
                 * 
                 * @description
                 * Reference to the Window injectable.
                 */
                $Window: Window = acquire(__Window);

                /**
                 * @name options
                 * @memberof plat.ui.animations.SimpleCssTransition
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.IObject<string>}
                 * 
                 * @description
                 * A JavaScript object with key value pairs for adjusting transition values. 
                 * (e.g. { width: '800px' } would set the element's width to 800px.
                 */
                options: IObject<string>;

                /**
                 * @name className
                 * @memberof plat.ui.animations.SimpleCssTransition
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The class name added to the animated element.
                 */
                className = __SimpleTransition;

                /**
                 * @name initialize
                 * @memberof plat.ui.animations.SimpleCssTransition
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function denoting the start of the animation.
                 * 
                 * @returns {void}
                 */
                start(): void {
                    var transitionId = this.$Compat.animationEvents.$transition,
                        element = this.element,
                        className = this.className,
                        endFn = () => {
                            removeClass(element, className);
                            this.end();
                        };

                    addClass(element, className);

                    var computedStyle = this.$Window.getComputedStyle(element),
                        transitionProperty = computedStyle[<any>(transitionId + 'Property')],
                        transitionDuration = computedStyle[<any>(transitionId + 'Duration')];
                    if (transitionProperty === '' || transitionProperty === 'none' ||
                        transitionDuration === '' || transitionDuration === '0s') {
                        this._animate();
                        endFn();
                        return;
                    }

                    this.transitionEnd(endFn);

                    if (this._animate()) {
                        return;
                    }

                    endFn();
                }

                /**
                 * @name cancel
                 * @memberof plat.ui.animations.SimpleCssTransition
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * A function to be called to let it be known the animation is being cancelled.
                 * 
                 * @returns {void}
                 */
                cancel(): void {
                    removeClass(this.element, this.className);
                    super.cancel();
                }

                /**
                 * @name _animate
                 * @memberof plat.ui.animations.SimpleCssTransition
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Animate the element based on the options passed in.
                 * 
                 * @returns {boolean} Whether or not the element is going to animate with the options passed in. 
                 * If false, the control should begin cleaning up.
                 */
                _animate(): boolean {
                    var style = this.element.style || {},
                        options = this.options || {},
                        keys = Object.keys(options),
                        length = keys.length,
                        key: any,
                        currentProperty: string,
                        newProperty: string,
                        unchanged = 0;

                    for (var i = 0; i < length; ++i) {
                        key = keys[i];
                        currentProperty = style[key];
                        newProperty = options[key];
                        if (!isString(newProperty)) {
                            unchanged++;
                            continue;
                        }

                        style[key] = newProperty;
                        if (currentProperty === style[key]) {
                            unchanged++;
                        }
                    }

                    return unchanged < length;
                }
            }

            register.animation(__SimpleTransition, SimpleCssTransition);

            /**
             * @name ISimpleCssTransition
             * @memberof plat.ui.animations
             * @kind interface
             * 
             * @extends {plat.ui.animations.ISimpleCssAnimation}
             * 
             * @description
             * An object that allows for transitioned changes to an Element's style based on  
             * options passed in.
             */
            export interface ISimpleCssTransition extends ISimpleCssAnimation {
                /**
                 * @name options
                 * @memberof plat.ui.animations.ISimpleCssTransition
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.IObject<string>}
                 * 
                 * @description
                 * A JavaScript object with key value pairs for adjusting transition values. 
                 * (e.g. { width: '800px' } would set the element's width to 800px.
                 */
                options: plat.IObject<string>;
            }
        }

    /**
     * @name controls
     * @memberof plat.ui
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds classes and interfaces related to UI control components in platypus.
     */
        export module controls {
            /**
             * @name Baseport
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.TemplateControl}
             * @implements {plat.ui.controls.IBaseport}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} that acts as a base for all 
             * controls that can interchangeably swap out {@link plat.ui.IBaseViewControl|IBaseViewControls}.
             */
            export class Baseport extends TemplateControl implements IBaseport {
                /**
                 * @name $ManagerCache
                 * @memberof plat.ui.controls.Baseport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.storage.ICache<plat.processing.IElementManager>}
                 * 
                 * @description
                 * Reference to an injectable that caches {@link plat.processing.IElementManager|IElementManagers}.
                 */
                $ManagerCache: storage.ICache<processing.IElementManager> = acquire(__ManagerCache);
                /**
                 * @name $Document
                 * @memberof plat.ui.controls.Baseport
                 * @kind property
                 * @access public
                 * 
                 * @type {Document}
                 * 
                 * @description
                 * Reference to the Document injectable.
                 */
                $Document: Document = acquire(__Document);
                /**
                 * @name $ElementManagerFactory
                 * @memberof plat.ui.controls.Baseport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.processing.IElementManagerFactory}
                 * 
                 * @description
                 * Reference to the {@link plat.processing.IElementManagerFactory|IElementManagerFactory} injectable.
                 */
                $ElementManagerFactory: processing.IElementManagerFactory = acquire(__ElementManagerFactory);
                /**
                 * @name $Animator
                 * @memberof plat.ui.controls.Baseport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ui.animations.IAnimator}
                 * 
                 * @description
                 * Reference to the {@link plat.ui.animations.IAnimator|IAnimator} injectable.
                 */
                $Animator: animations.IAnimator = acquire(__Animator);
                /**
                 * @name $Promise
                 * @memberof plat.ui.controls.Baseport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.async.IPromise}
                 * 
                 * @description
                 * Reference to the {@link plat.async.IPromise|IPromise} injectable.
                 */
                $Promise: async.IPromise = acquire(__Promise);

                /**
                 * @name navigator
                 * @memberof plat.ui.controls.Baseport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.navigation.IBaseNavigator}
                 * 
                 * @description
                 * The navigator used for navigating between {@link plat.ui.IBaseViewControl|IBaseViewControls}.
                 */
                navigator: navigation.IBaseNavigator;

                /**
                 * @name constructor
                 * @memberof plat.ui.controls.Baseport
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * The constructor for a {@link plat.ui.controls.Baseport|Baseport}.
                 * 
                 * @param {plat.navigation.IBaseNavigator} navigator The navigator used for navigating between 
                 * {@link plat.ui.IBaseViewControl|IBaseViewControls}.
                 * 
                 * @returns {plat.ui.controls.Baseport} A {@link plat.ui.controls.Baseport|Baseport} instance.
                 */
                constructor(navigator: navigation.IBaseNavigator) {
                    super();
                    this.navigator = navigator;
                }

                /**
                 * @name setTemplate
                 * @memberof plat.ui.controls.Baseport
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Clears the control element's innerHTML.
                 * 
                 * @returns {void}
                 */
                setTemplate(): void {
                    this.dom.clearNode(this.element);
                    this._load();
                }
        
                /**
                 * @name dispose
                 * @memberof plat.ui.controls.Baseport
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Clean up any memory being held.
                 * 
                 * @returns {void}
                 */
                dispose() {
                    this.navigator.dispose();
                }
        
                /**
                 * @name navigateTo
                 * @memberof plat.ui.controls.Baseport
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Grabs the root of this control's manager 
                 * tree, clears it, and initializes the 
                 * creation of a new one by kicking off a 
                 * navigate.
                 * 
                 * @param {plat.ui.controls.IBaseportNavigateToOptions} ev The navigation options.
                 * 
                 * @returns {void}
                 */
                navigateTo(ev: IBaseportNavigateToOptions): void {
                    var control = ev.target,
                        parameter = ev.parameter,
                        options = ev.options,
                        element = this.element,
                        controlType = ev.type,
                        newControl = dependency.Injector.isInjector(control),
                        injectedControl = newControl ? control.inject() : control,
                        replaceType = injectedControl.replaceWith,
                        node = (isEmpty(replaceType) || replaceType === 'any') ? this.$Document.createElement('div') :
                            <HTMLElement>this.$Document.createElement(replaceType),
                        attributes: IObject<string> = {},
                        nodeMap: processing.INodeMap = {
                            element: node,
                            attributes: attributes,
                            nodes: [],
                            uiControlNode: {
                                control: injectedControl,
                                nodeName: controlType,
                                expressions: [],
                                injector: control,
                                childManagerLength: 0
                            }
                        };

                    node.setAttribute('plat-control', controlType);
                    node.className = controlType;
                    element.appendChild(node);

                    this.$Animator.animate(this.element, __Enter);

                    var viewportManager = this.$ManagerCache.read(this.uid),
                        manager = this.$ElementManagerFactory.getInstance(),
                        navigator = this.navigator;

                    viewportManager.children = [];
                    manager.initialize(nodeMap, viewportManager, !newControl);

                    control = this.controls[0];
                    control.navigator = navigator;
                    navigator.navigated(control, parameter, options);

                    if (navigator.navigating) {
                        return;
                    }

                    manager.setUiControlTemplate();
                }
        
                /**
                 * @name navigateFrom
                 * @memberof plat.ui.controls.Baseport
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Manages the navigatingFrom lifecycle event for 
                 * {@link plat.ui.IBaseViewControl|IBaseViewControls}.
                 * 
                 * @param {plat.ui.IBaseViewControl} fromControl The {@link plat.ui.IBaseViewControl|IBaseViewControl} 
                 * being navigated away from.
                 * 
                 * @returns {plat.async.IThenable<void>} A promise that resolves when the current view is done animating 
                 * away.
                 */
                navigateFrom(fromControl: IBaseViewControl): async.IThenable<void> {
                    if (isNull(fromControl) || !isFunction(fromControl.navigatingFrom)) {
                        return this.$Promise.resolve<void>(null);
                    }

                    fromControl.navigatingFrom();
                    return this.$Animator.animate(this.element, __Leave);
                }

                /**
                 * @name _load
                 * @memberof plat.ui.controls.Baseport
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Initializes the navigator.
                 * 
                 * @param {any} navigationParameter? A parameter needed 
                 * to perform the specified type of navigation.
                 * @param {plat.navigation.IBaseNavigationOptions} options? The options 
                 * needed on load for the inherited form of navigation.
                 * 
                 * @returns {void}
                 */
                _load(navigationParameter?: any, options?: navigation.IBaseNavigationOptions): void {
                    var navigator = this.navigator;
                    navigator.initialize(this);
                    navigator.navigate(navigationParameter, options);
                }
            }

            /**
             * @name IBaseport
             * @memberof plat.ui.controls
             * @kind interface
             * 
             * @extends {plat.ui.ITemplateControl}
             * 
             * @description
             * Describes an object that acts as a base for all controls that can interchangeably 
             * swap out {@link plat.ui.IBaseViewControl|IBaseViewControls}.
             */
            export interface IBaseport extends ITemplateControl {
                /**
                 * @name navigator
                 * @memberof plat.ui.controls.IBaseport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.navigation.IBaseNavigator}
                 * 
                 * @description
                 * The navigator used for navigating between {@link plat.ui.IBaseViewControl|IBaseViewControls}.
                 */
                navigator: navigation.IBaseNavigator;

                /**
                 * @name navigateTo
                 * @memberof plat.ui.controls.IBaseport
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Grabs the root of this control's manager 
                 * tree, clears it, and initializes the 
                 * creation of a new one by kicking off a 
                 * navigate.
                 * 
                 * @param {plat.ui.controls.IBaseportNavigateToOptions} ev The navigation options.
                 * 
                 * @returns {void}
                 */
                navigateTo(ev: IBaseportNavigateToOptions): void;

                /**
                 * @name navigateFrom
                 * @memberof plat.ui.controls.IBaseport
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Manages the navigatingFrom lifecycle event for 
                 * {@link plat.ui.IBaseViewControl|IBaseViewControls}.
                 * 
                 * @param {plat.ui.IBaseViewControl} fromControl The {@link plat.ui.IBaseViewControl|IBaseViewControl} 
                 * being navigated away from.
                 * 
                 * @returns {plat.async.IThenable<void>} A promise that resolves when the current view is done animating 
                 * away.
                 */
                navigateFrom(fromControl: IBaseViewControl): async.IThenable<void>;
            }

            /**
             * @name IBaseportNavigateToOptions
             * @memberof plat.ui.controls
             * @kind interface
             * 
             * @description
             * Navigation options for a {@link plat.ui.controls.Baseport|Baseport} and all 
             * controls that inherit from {@link plat.ui.controls.Baseport|Baseport}.
             */
            export interface IBaseportNavigateToOptions {
                /**
                 * @name target
                 * @memberof plat.ui.controls.IBaseportNavigateToOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {any}
                 * 
                 * @description
                 * Either an {@link plat.ui.IBaseViewControl|IBaseViewControls} or an injector for an 
                 * {@link plat.ui.IBaseViewControl|IBaseViewControls} to be used.
                 */
                target: any;

                /**
                 * @name parameter
                 * @memberof plat.ui.controls.IBaseportNavigateToOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {any}
                 * 
                 * @description
                 * The navigation parameter.
                 */
                parameter: any;
        
                /**
                 * @name parameter
                 * @memberof plat.ui.controls.IBaseportNavigateToOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.navigation.IBaseNavigationOptions}
                 * 
                 * @description
                 * The options used for navigation.
                 */
                options: navigation.IBaseNavigationOptions;

                /**
                 * @name type
                 * @memberof plat.ui.controls.IBaseportNavigateToOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The type of {@link plat.ui.IBaseViewControl|IBaseViewControls} to navigate to.
                 */
                type: string;
            }

            /**
             * @name Viewport
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.controls.Baseport}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} that can interchangeably swap out 
             * {@link plat.ui.IViewControl|IViewControls}.
             */
            export class Viewport extends Baseport {
                /**
                 * @name options
                 * @memberof plat.ui.controls.Viewport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.observable.IObservableProperty<plat.ui.controls.IViewportOptions>}
                 * 
                 * @description
                 * The evaluated {@link plat.controls.Options|plat-options} object.
                 */
                options: observable.IObservableProperty<IViewportOptions>;

                /**
                 * @name navigator
                 * @memberof plat.ui.controls.Viewport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.navigation.INavigatorInstance}
                 * 
                 * @description
                 * A type of navigator that uses either the {@link plat.ui.ViewControl|ViewControl's} 
                 * Constructors or their registered names for navigation 
                 * from one to another.
                 */
                navigator: navigation.INavigatorInstance;

                /**
                 * @name _load
                 * @memberof plat.ui.controls.Viewport
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Checks for a default view, finds the {@link plat.ui.ViewControl|ViewControl's} injector, 
                 * and initializes the loading of the view.
                 * 
                 * @returns {void}
                 */
                _load(): void {
                    var $exception: IExceptionStatic;
                    if (isNull(this.options)) {
                        $exception = acquire(__ExceptionStatic);
                        $exception.warn('No defaultView specified in plat-options for plat-viewport.',
                            $exception.NAVIGATION);
                        return;
                    }

                    var options = this.options.value || <IViewportOptions>{},
                        controlType = options.defaultView,
                        injector = viewControlInjectors[controlType];

                    if (isNull(injector)) {
                        $exception = acquire(__ExceptionStatic);
                        $exception.fatal('The defaultView ' + controlType + ' is not a registered view control.',
                            $exception.NAVIGATION);
                        return;
                    }

                    super._load(injector);
                }
            }

            /**
             * @name IViewportOptions
             * @memberof plat.ui.controls
             * @kind interface
             * 
             * @description
             * The available options for a {@link plat.ui.controls.Viewport|Viewport}.
             */
            export interface IViewportOptions {
                /**
                 * @name defaultView
                 * @memberof plat.ui.controls.IViewportOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The registered name of the default 
                 * {@link plat.ui.IViewControl|IViewControl} to initially navigate to.
                 */
                defaultView: string;
            }

            register.control(__Viewport, Viewport, [__NavigatorInstance]);

            /**
             * @name Routeport
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.controls.Baseport}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} that can interchangeably swap out 
             * {@link plat.ui.IWebViewControl|IWebViewControls} based on their defined routes.
             */
            export class Routeport extends Baseport {
                /**
                 * @name options
                 * @memberof plat.ui.controls.Routeport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.observable.IObservableProperty<plat.ui.controls.IRouteportOptions>}
                 * 
                 * @description
                 * The evaluated {@link plat.controls.Options|plat-options} object.
                 */
                options: observable.IObservableProperty<IRouteportOptions>;

                /**
                 * @name navigator
                 * @memberof plat.ui.controls.Routeport
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.navigation.IRoutingNavigator}
                 * 
                 * @description
                 * A type of navigator that uses the registered routes 
                 * for {@link plat.ui.IWebViewControl|IWebViewControls} to navigate to and from one another.
                 */
                navigator: navigation.IRoutingNavigator;

                /**
                 * @name _load
                 * @memberof plat.ui.controls.Routeport
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Looks for a default route and initializes the loading 
                 * of the view.
                 * 
                 * @returns {void}
                 */
                _load(): void {
                    var path = '',
                        options = this.options;

                    if (!isNull(options) && !isNull(options.value)) {
                        path = options.value.defaultRoute || '';
                    }

                    super._load(path, {
                        replace: true
                    });
                }
            }

            /**
             * @name IRouteportOptions
             * @memberof plat.ui.controls
             * @kind interface
             * 
             * @description
             * The available options for a {@link plat.ui.controls.Routeport|Routeport}.
             */
            export interface IRouteportOptions {
                /**
                 * @name defaultRoute
                 * @memberof plat.ui.controls.IRouteportOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The registered route of the default 
                 * {@link plat.ui.IWebViewControl|IWebViewControl} to initially navigate to.
                 */
                defaultRoute: string;
            }

            register.control(__Routeport, Routeport, [__RoutingNavigator]);

            /**
             * @name Template
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.TemplateControl}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} for easily reusing a 
             * defined HTML template.
             */
            export class Template extends TemplateControl {
                /**
                 * @name $Promise
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.async.IPromise}
                 * 
                 * @description
                 * Reference to the {@link plat.async.IPromise|IPromise} injectable.
                 */
                $Promise: async.IPromise = acquire(__Promise);
                /**
                 * @name $TemplateCache
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.storage.ITemplateCache}
                 * 
                 * @description
                 * Reference to an injectable for storing HTML templates.
                 */
                $TemplateCache: storage.ITemplateCache = acquire(__TemplateCache);
                /**
                 * @name $Document
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access public
                 * 
                 * @type {Document}
                 * 
                 * @description
                 * Reference to the Document injectable.
                 */
                $Document: Document = acquire(__Document);

                /**
                 * @name replaceWith
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Removes the <plat-template> node from the DOM
                 */
                replaceWith: string = null;

                /**
                 * @name options
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.observable.IObservableProperty<plat.ui.controls.ITemplateOptions>}
                 * 
                 * @description
                 * The evaluated {@link plat.controls.Options|plat-options} object.
                 */
                options: observable.IObservableProperty<ITemplateOptions>;
        
                /**
                 * @name _id
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access protected
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The unique ID used to reference a particular 
                 * template.
                 */
                _id: string;
        
                /**
                 * @name _url
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access protected
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The optional URL associated with this 
                 * particular template.
                 */
                _url: string;
        
                /**
                 * @name __isFirst
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access private
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Whether or not this is the first instance of the control, 
                 * specifying that it defines the template to copy.
                 */
                private __isFirst = false;
                /**
                 * @name __templatePromise
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.async.IThenable<plat.ui.controls.Template>}
                 * 
                 * @description
                 * A promise that resolves when the template is retrieved and ready.
                 */
                private __templatePromise: async.IThenable<Template>;
                /**
                 * @name __templateControlCache
                 * @memberof plat.ui.controls.Template
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.storage.ICache<any>}
                 * 
                 * @description
                 * HTML template storage for all instances of this control.
                 */
                private __templateControlCache: storage.ICache<any>;

                /**
                 * @name constructor
                 * @memberof plat.ui.controls.Template
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * The constructor for a {@link plat.ui.controls.Template|Template}. Creates the control cache.
                 * 
                 * @returns {plat.ui.controls.Template} A {@link plat.ui.controls.Template|Template} instance.
                 */
                constructor() {
                    super();
                    var $cacheFactory: storage.ICacheFactory = acquire(__CacheFactory);
                    this.__templateControlCache = $cacheFactory.create<any>('__templateControlCache');
                }

                /**
                 * @name initialize
                 * @memberof plat.ui.controls.Template
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Initializes the creation of the template.
                 * 
                 * @returns {void}
                 */
                initialize(): void {
                    var id = this._id = this.options.value.id,
                        options = this.options.value;

                    if (isNull(id)) {
                        return;
                    }

                    this._url = options.templateUrl;

                    var templatePromise: async.IThenable<Template> = this.__templateControlCache.read(id);
                    if (!isNull(templatePromise)) {
                        this.__templatePromise = templatePromise;
                        return;
                    }

                    this.__isFirst = true;
                    this._initializeTemplate();
                }
        
                /**
                 * @name loaded
                 * @memberof plat.ui.controls.Template
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Decides if this is a template definition or 
                 * a template instance.
                 * 
                 * @returns {void}
                 */
                loaded(): void {
                    if (!this.__isFirst) {
                        this._waitForTemplateControl(this.__templatePromise);
                    }
                }
        
                /**
                 * @name dispose
                 * @memberof plat.ui.controls.Template
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Removes the template from the template cache.
                 * 
                 * @returns {void}
                 */
                dispose(): void {
                    if (this.__isFirst) {
                        this.__templateControlCache.dispose();
                    }
                }
        
                /**
                 * @name _initializeTemplate
                 * @memberof plat.ui.controls.Template
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Determines whether a URL or innerHTML is being used, 
                 * creates the bindable template, and stores the template 
                 * in a template cache for later use.
                 * 
                 * @returns {void}
                 */
                _initializeTemplate(): void {
                    var id = this._id;

                    if (isNull(id)) {
                        return;
                    }

                    var parentNode = this.endNode.parentNode,
                        url = this._url,
                        template: any;

                    if (!isNull(url)) {
                        template = this.$TemplateCache.read(url);
                        this.dom.clearNodeBlock(this.elementNodes, parentNode);
                    } else {
                        template = this.$Document.createDocumentFragment();
                        this.dom.appendChildren(this.elementNodes, template);
                    }

                    var controlPromise: async.IThenable<ITemplateControl>;
                    if (isPromise(template)) {
                        controlPromise = template.catch((error: Error) => {
                            if (isNull(error)) {
                                return TemplateControl.determineTemplate(this, url);
                            }
                        }).then((template: DocumentFragment) => {
                            this.bindableTemplates.add(id, template.cloneNode(true));
                            return this;
                        });
                    } else {
                        this.bindableTemplates.add(id, template.cloneNode(true));

                        controlPromise = this.$Promise.resolve(this);
                    }

                    this.__templateControlCache.put(id, controlPromise);
                }
        
                /**
                 * @name _waitForTemplateControl
                 * @memberof plat.ui.controls.Template
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Waits for the template promise to resolve, then initializes 
                 * the binding of the bindable template and places it into the 
                 * DOM.
                 * 
                 * @param {plat.async.IThenable<plat.ui.controls.Template>} templatePromise The promise 
                 * associated with the first instance of the control with this ID.
                 * 
                 * @returns {void}
                 */
                _waitForTemplateControl(templatePromise: async.IThenable<Template>): void {
                    var $exception: IExceptionStatic;
                    templatePromise.then((templateControl: Template) => {
                        if (!(isNull(this._url) || (this._url === templateControl._url))) {
                            $exception = acquire(__ExceptionStatic);
                            $exception.warn('The specified url: ' + this._url +
                                ' does not match the original plat-template with id: ' +
                                '"' + this._id + '". The original url will be loaded.',
                                $exception.TEMPLATE);
                        }

                        this.__mapBindableTemplates(templateControl);
                        return this.bindableTemplates.bind(this._id);
                    }).then((clone) => {
                        var endNode = this.endNode;
                        this.dom.insertBefore(endNode.parentNode, clone, endNode);
                    }).catch((error) => {
                        postpone(() => {
                            $exception = acquire(__ExceptionStatic);
                            $exception.warn('Problem resolving plat-template url: ' +
                                error.response, $exception.TEMPLATE);
                        });
                    });
                }
        
                /**
                 * @name __mapBindableTemplates
                 * @memberof plat.ui.controls.Template
                 * @kind function
                 * @access private
                 * 
                 * @description
                 * Maps the bindable templates cache and html templates of the first 
                 * control with the proper ID to this control's bindable templates.
                 * 
                 * @param {plat.ui.controls.Template} control The first of the controls 
                 * with this corresponding ID that defined the HTML template to reuse.
                 * 
                 * @returns {void}
                 */
                private __mapBindableTemplates(control: Template): void {
                    var bindableTemplates = <BindableTemplates>this.bindableTemplates;
                    bindableTemplates._cache = (<BindableTemplates>control.bindableTemplates)._cache;
                    bindableTemplates.templates = control.bindableTemplates.templates;
                }
            }

            /**
             * @name ITemplateOptions
             * @memberof plat.ui.controls
             * @kind interface
             * 
             * @description
             * The available {@link plat.controls.Options|options} for the {@link plat.ui.controls.Template|Template} control.
             */
            export interface ITemplateOptions {
                /**
                 * @name id
                 * @memberof plat.ui.controls.ITemplateOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The unique ID used to label a template 
                 * and use it as DOM.
                 */
                id: string;

                /**
                 * @name templateUrl
                 * @memberof plat.ui.controls.ITemplateOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * An optional URL to specify a template 
                 * instead of using the element's innerHTML.
                 */
                templateUrl: string;
            }

            register.control(__Template, Template);

            /**
             * @name Ignore
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.TemplateControl}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} for inner HTML that contains controls  
             * and/or markup and not having it bind or evaluate.
             */
            export class Ignore extends TemplateControl {
                /**
                 * @name setTemplate
                 * @memberof plat.ui.controls.Ignore
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Removes the innerHTML from the DOM and saves it.
                 * 
                 * @returns {void}
                 */
                setTemplate(): void {
                    this.innerTemplate = this.dom.appendChildren(this.element.childNodes);
                }

                /**
                 * @name loaded
                 * @memberof plat.ui.controls.Ignore
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Places the saved innerHTML back into the DOM.
                 * 
                 * @returns {void}
                 */
                loaded(): void {
                    this.element.appendChild(this.innerTemplate.cloneNode(true));
                }
            }

            register.control(__Ignore, Ignore);

            /**
             * @name ForEach
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.TemplateControl}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} for repeating a block of 
             * DOM nodes bound to an array.
             */
            export class ForEach extends TemplateControl {
                /**
                 * @name $Animator
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ui.animations.IAnimator}
                 * 
                 * @description
                 * Reference to the {@link plat.ui.animations.IAnimator|IAnimator} injectable.
                 */
                $Animator: animations.IAnimator = acquire(__Animator);
                /**
                 * @name $Promise
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.async.IPromise}
                 * 
                 * @description
                 * Reference to the {@link plat.async.IPromise|IPromise} injectable.
                 */
                $Promise: async.IPromise = acquire(__Promise);

                /**
                 * @name context
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access public
                 * 
                 * @type {Array<any>}
                 * 
                 * @description
                 * The required context of the control (must be of type Array).
                 */
                context: Array<any>;

                /**
                 * @name priority
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access public
                 * 
                 * @type {number}
                 * 
                 * @description
                 * The load priority of the control (needs to load before a {@link plat.controls.Bind|Bind} control).
                 */
                priority = 120;

                /**
                 * @name controls
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access public
                 * 
                 * @type {Array<plat.ui.ITemplateControl>}
                 * 
                 * @description
                 * The child controls of the control. All will be of type {@link plat.ui.ITemplateControl|ITemplateControl}.
                 */
                controls: Array<ITemplateControl>;

                /**
                 * @name itemsLoaded
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.async.IThenable<void>}
                 * 
                 * @description
                 * A Promise that fulfills when the items are loaded.
                 */
                itemsLoaded: async.IThenable<void>;

                /**
                 * @name _blockLength
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access protected
                 * 
                 * @type {number}
                 * 
                 * @description
                 * The node length of the element's childNodes (innerHTML).
                 */
                _blockLength = 0;

                /**
                 * @name __removeListener
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.IRemoveListener}
                 * 
                 * @description
                 * A function to stop listening for array (context) mutations.
                 */
                private __removeListener: IRemoveListener;
                /**
                 * @name __currentAnimations
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access private
                 * 
                 * @type {Array<plat.ui.animations.IAnimationThenable<void>>}
                 * 
                 * @description
                 * An array to aggregate all current animation promises.
                 */
                private __currentAnimations: Array<animations.IAnimationThenable<void>> = [];
                /**
                 * @name __resolveFn
                 * @memberof plat.ui.controls.ForEach
                 * @kind property
                 * @access private
                 * 
                 * @type {() => void}
                 * 
                 * @description
                 * The resolve function for the itemsLoaded promise.
                 */
                private __resolveFn: () => void;

                /**
                 * @name constructor
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * The constructor for a {@link plat.ui.controls.ForEach|ForEach}. Creates the itemsLoaded promise.
                 * 
                 * @returns {plat.ui.controls.ForEach} A {@link plat.ui.controls.ForEach|ForEach} instance.
                 */
                constructor() {
                    super();
                    this.itemsLoaded = new this.$Promise<void>((resolve) => {
                        this.__resolveFn = resolve;
                    });
                }

                /**
                 * @name setTemplate
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Creates a bindable template with the control element's childNodes (innerHTML).
                 * 
                 * @returns {void}
                 */
                setTemplate(): void {
                    var childNodes: Array<Node> = Array.prototype.slice.call(this.element.childNodes);
                    this.bindableTemplates.add('item', childNodes);
                }

                /**
                 * @name contextChanged
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Re-syncs the ForEach children controls and DOM with the new 
                 * array.
                 * 
                 * @param {Array<any>} newValue? The new Array
                 * @param {Array<any>} oldValue? The old Array
                 * 
                 * @returns {void}
                 */
                contextChanged(newValue?: Array<any>, oldValue?: Array<any>): void {
                    if (isNull(this.__removeListener)) {
                        this._setListener();
                    }

                    if (!isArray(newValue)) {
                        return;
                    }

                    if (newValue.length === 0) {
                        this._removeItems(this.controls.length);
                        return;
                    }

                    this._executeEvent({
                        method: 'splice',
                        arguments: null,
                        returnValue: null,
                        oldArray: oldValue || [],
                        newArray: newValue || []
                    });
                }

                /**
                 * @name loaded
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Observes the Array context for changes and adds initial items to the DOM.
                 * 
                 * @returns {void}
                 */
                loaded(): void {
                    var context = this.context;

                    if (!isArray(context)) {
                        return;
                    }

                    this._addItems(context.length, 0);

                    this._setListener();
                }

                /**
                 * @name dispose
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Removes the Array context mutation listener
                 * 
                 * @returns {void}
                 */
                dispose(): void {
                    if (isFunction(this.__removeListener)) {
                        this.__removeListener();
                        this.__removeListener = null;
                    }

                    this.__resolveFn = null;
                }

                /**
                 * @name _addItem
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Adds an item to the control's element.
                 * 
                 * @param {DocumentFragment} item The HTML fragment representing a single item
                 * @param {boolean} animate? Whether or not to animate the entering item
                 * 
                 * @returns {void}
                 */
                _addItem(item: DocumentFragment, animate?: boolean): void {
                    if (!isNode(item) ||
                        !isArray(this.context) ||
                        this.context.length === 0 ||
                        this.controls.length === 0) {
                        return;
                    }

                    var $animator = this.$Animator,
                        childNodes: Array<Element>,
                        childNode: Element;

                    if (animate === true) {
                        childNodes = Array.prototype.slice.call(item.childNodes);
                        if (this._blockLength === 0) {
                            this._blockLength = childNodes.length;
                        }
                    } else {
                        if (this._blockLength === 0) {
                            this._blockLength = item.childNodes.length;
                        }
                        this.dom.insertBefore(this.element, item);
                        return;
                    }

                    this.dom.insertBefore(this.element, item);

                    var currentAnimations = this.__currentAnimations;
                    while (childNodes.length > 0) {
                        childNode = childNodes.shift();
                        if (childNode.nodeType === Node.ELEMENT_NODE) {
                            currentAnimations.push($animator.animate(childNode, __Enter).then(() => {
                                currentAnimations.shift();
                            }));
                        }
                    }
                }

                /**
                 * @name _removeItem
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Removes an item from the control's element.
                 * 
                 * @returns {void}
                 */
                _removeItem(): void {
                    var controls = this.controls,
                        length = controls.length - 1;

                    TemplateControl.dispose(controls[length]);
                }

                /**
                 * @name _updateResources
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Updates the control's children resource objects when 
                 * the array changes.
                 * 
                 * @returns {void}
                 */
                _updateResources(): void {
                    var controls = this.controls,
                        length = controls.length;

                    for (var i = 0; i < length; ++i) {
                        controls[i].resources.add(this._getAliases(i));
                    }
                }

                /**
                 * @name _setListener
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Sets a listener for the changes to the array.
                 * 
                 * @returns {void}
                 */
                _setListener(): void {
                    this.__removeListener = this.observeArray(this, 'context', this._executeEvent);
                }

                /**
                 * @name _executeEvent
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Receives an event when a method has been called on an array and maps the array 
                 * method to its associated method handler.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _executeEvent(ev: observable.IArrayMethodInfo<any>): void {
                    var method = '_' + ev.method;
                    if (isFunction((<any>this)[method])) {
                        (<any>this)[method](ev);
                    }
                }

                /**
                 * @name _addItems
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Adds new items to the control's element when items are added to 
                 * the array.
                 * 
                 * @param {number} numberOfItems The number of items to add.
                 * @param {number} index The point in the array to start adding items.
                 * @param {boolean} animate? Whether or not to animate the new items
                 * 
                 * @returns {plat.async.IThenable<void>} The itemsLoaded promise.
                 */
                _addItems(numberOfItems: number, index: number, animate?: boolean): async.IThenable<void> {
                    var bindableTemplates = this.bindableTemplates,
                        promises: Array<async.IThenable<void>> = [];

                    for (var i = 0; i < numberOfItems; ++i, ++index) {
                        promises.push(bindableTemplates.bind('item', index, this._getAliases(index)).then((fragment: DocumentFragment) => {
                            this._addItem(fragment, animate);
                        }).catch((error: any) => {
                            postpone(() => {
                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                                $exception.fatal(error, $exception.BIND);
                            });
                        }));
                    }

                    if (promises.length > 0) {
                        this.itemsLoaded = this.$Promise.all(promises).then<void>(() => {
                            if (isFunction(this.__resolveFn)) {
                                this.__resolveFn();
                                this.__resolveFn = null;
                            }
                        });
                    } else {
                        if (isFunction(this.__resolveFn)) {
                            this.__resolveFn();
                            this.__resolveFn = null;
                        }
                        this.itemsLoaded = new this.$Promise<void>((resolve) => {
                            this.__resolveFn = resolve;
                        });
                    }

                    return this.itemsLoaded;
                }

                /**
                 * @name _removeItems
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Removes items from the control's element.
                 * 
                 * @param {number} numberOfItems The number of items to remove.
                 * 
                 * @returns {void}
                 */
                _removeItems(numberOfItems: number): void {
                    for (var i = 0; i < numberOfItems; ++i) {
                        this._removeItem();
                    }

                    if (this.controls.length > 0) {
                        this._updateResources();
                    }
                }

                /**
                 * @name _getAliases
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Returns a resource alias object for an item in the array. The 
                 * resource object contains index:number, even:boolean, odd:boolean, 
                 * first:boolean, and last:boolean.
                 * 
                 * @param {number} index The index used to create the resource aliases.
                 * 
                 * @returns {plat.IObject<plat.ui.IResource>} An object consisting of {@link plat.ui.IResource|IResources}.
                 */
                _getAliases(index: number): IObject<IResource> {
                    var isEven = (index & 1) === 0;
                    return {
                        index: {
                            value: index,
                            type: 'observable'
                        },
                        even: {
                            value: isEven,
                            type: 'observable'
                        },
                        odd: {
                            value: !isEven,
                            type: 'observable'
                        },
                        first: {
                            value: index === 0,
                            type: 'observable'
                        },
                        last: {
                            value: index === (this.context.length - 1),
                            type: 'observable'
                        }
                    };
                }

                /**
                 * @name _push
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Handles items being pushed into the array.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _push(ev: observable.IArrayMethodInfo<any>): void {
                    this._addItems(ev.arguments.length, ev.oldArray.length, true);
                }

                /**
                 * @name _pop
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Handles items being popped off the array.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _pop(ev: observable.IArrayMethodInfo<any>): void {
                    var blockLength = this._blockLength,
                        startNode: number,
                        animationPromise: plat.ui.animations.IAnimationThenable<void>;

                    if (blockLength > 0) {
                        startNode = blockLength * ev.newArray.length;
                        animationPromise = this._animateItems(startNode, undefined, __Leave);
                    }

                    if (isNull(animationPromise)) {
                        this._removeItems(1);
                        return;
                    }

                    this.itemsLoaded = animationPromise.then(() => {
                        this._removeItems(1);
                    });
                }

                /**
                 * @name _shift
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Handles items being shifted off the array.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _shift(ev: observable.IArrayMethodInfo<any>): void {
                    this._removeItems(1);
                }

                /**
                 * @name _splice
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Handles adding/removing items when an array is spliced.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _splice(ev: observable.IArrayMethodInfo<any>): void {
                    var oldLength = this.controls.length,
                        newLength = ev.newArray.length;

                    if (newLength > oldLength) {
                        this._addItems(newLength - oldLength, oldLength, oldLength === 0);
                    } else if (oldLength > newLength) {
                        this._removeItems(oldLength - newLength);
                    }
                }

                /**
                 * @name _unshift
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Handles items being unshifted into the array.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _unshift(ev: observable.IArrayMethodInfo<any>): void {
                    this._addItems(ev.arguments.length, ev.oldArray.length);
                }

                /**
                 * @name _sort
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Handles when the array is sorted.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _sort(ev: observable.IArrayMethodInfo<any>): void { }

                /**
                 * @name _reverse
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Handles when the array is reversed.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The Array mutation event information.
                 * 
                 * @returns {void}
                 */
                _reverse(ev: observable.IArrayMethodInfo<any>): void { }

                /**
                 * @name _animateItems
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Animates a block of elements.
                 * 
                 * @param {number} startNode The starting childNode of the ForEach to animate
                 * @param {number} endNode The ending childNode of the ForEach to animate
                 * @param {string} key The animation key/type
                 * @param {boolean} cancel? Whether or not the animation should cancel all current animations. 
                 * Defaults to true.
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<void>} A promise that resolves when all animations are complete.
                 */
                _animateItems(startNode: number, endNode: number, key: string, cancel?: boolean): animations.IAnimationThenable<void> {
                    var currentAnimations = this.__currentAnimations,
                        length = currentAnimations.length;

                    if (length === 0 || cancel === false) {
                        return this.__handleAnimation(startNode, endNode, key);
                    }

                    var animationPromises: Array<animations.IAnimationThenable<void>> = [];
                    while (length-- > 0) {
                        animationPromises.push(currentAnimations[length].cancel());
                    }

                    return <animations.IAnimationThenable<void>>this.$Promise.all(animationPromises).then(() => {
                        return this.__handleAnimation(startNode, endNode, key);
                    });
                }

                /**
                 * @name __handleAnimation
                 * @memberof plat.ui.controls.ForEach
                 * @kind function
                 * @access private
                 * 
                 * @description
                 * Handles the animation of a block of elements.
                 * 
                 * @param {number} startNode The starting childNode of the ForEach to animate
                 * @param {number} endNode The ending childNode of the ForEach to animate
                 * @param {string} key The animation key/type
                 * 
                 * @returns {plat.ui.animations.IAnimationThenable<void>} The last element node's animation promise.
                 */
                private __handleAnimation(startNode: number, endNode: number, key: string): animations.IAnimationThenable<void> {
                    var nodes: Array<Node> = Array.prototype.slice.call(this.element.childNodes, startNode, endNode),
                        node: Node,
                        $animator = this.$Animator,
                        currentAnimations = this.__currentAnimations,
                        animationPromise: animations.IAnimationThenable<void>;

                    while (nodes.length > 0) {
                        node = nodes.shift();
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            animationPromise = $animator.animate(<Element>node, key).then(() => {
                                currentAnimations.shift();
                            });
                            currentAnimations.push(animationPromise);
                        }
                    }

                    return animationPromise;
                }
            }

            register.control(__ForEach, ForEach);

            /**
             * @name Html
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.TemplateControl}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} for adding HTML to the 
             * DOM through bound context strings.
             */
            export class Html extends TemplateControl {
                /**
                 * @name contextChanged
                 * @memberof plat.ui.controls.Html
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Loads the DOM with the new HTML String.
                 * 
                 * @returns {void}
                 */
                contextChanged(): void {
                    this.loaded();
                }

                /**
                 * @name loaded
                 * @memberof plat.ui.controls.Html
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Loads the context string as the innerHTML of the element.
                 * 
                 * @returns {void}
                 */
                loaded(): void {
                    var context = this.context;

                    if (!isString(context)) {
                        return;
                    }

                    this.dom.setInnerHtml(this.element, context);
                }
            }

            register.control(__Html, Html);

            /**
             * @name Select
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.TemplateControl}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} for binding an HTML select element 
             * to an Array context.
             */
            export class Select extends TemplateControl {
                /**
                 * @name $Promise
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.async.IPromise}
                 * 
                 * @description
                 * Reference to the {@link plat.async.IPromise|IPromise} injectable.
                 */
                $Promise: async.IPromise = acquire(__Promise);
                /**
                 * @name $Document
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {Document}
                 * 
                 * @description
                 * Reference to the Document injectable.
                 */
                $Document: Document = acquire(__Document);

                /**
                 * @name replaceWith
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Replaces the <plat-select> node with 
                 * a <select> node.
                 */
                replaceWith = 'select';

                /**
                 * @name priority
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {number}
                 * 
                 * @description
                 * The load priority of the control (needs to load before a {@link plat.controls.Bind|Bind} control).
                 */
                priority = 120;

                /**
                 * @name context
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {Array<any>}
                 * 
                 * @description
                 * The required context of the control (must be of type Array).
                 */
                context: Array<any>;

                /**
                 * @name groups
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.IObject<Element>}
                 * 
                 * @description
                 * An object that keeps track of unique 
                 * optgroups.
                 */
                groups: IObject<Element> = {};

                /**
                 * @name options
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.observable.IObservableProperty<plat.ui.controls.ISelectOptions>}
                 * 
                 * @description
                 * The evaluated {@link plat.controls.Options|plat-options} object.
                 */
                options: observable.IObservableProperty<ISelectOptions>;

                /**
                 * @name itemsLoaded
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.async.IThenable<void>}
                 * 
                 * @description
                 * A Promise that will fulfill whenever all items are loaded.
                 */
                itemsLoaded: async.IThenable<void>;

                /**
                 * @name __removeListener
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.IRemoveListener}
                 * 
                 * @description
                 * A function to stop listening to Array context mutations.
                 */
                private __removeListener: IRemoveListener;
                /**
                 * @name __isGrouped
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access private
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * Whether or not the select is grouped.
                 */
                private __isGrouped = false;
                /**
                 * @name __isNativeSelect
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access private
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * Whether or not the select should be treated as a 
                 * native (unbound) select element.
                 */
                private __isNativeSelect = false;
                /**
                 * @name __group
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access private
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The property used to group the objects.
                 */
                private __group: string;
                /**
                 * @name __defaultOption
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access private
                 * 
                 * @type {HTMLOptionElement}
                 * 
                 * @description
                 * An optional default option specified in the control element's 
                 * innerHTML.
                 */
                private __defaultOption: HTMLOptionElement;
                /**
                 * @name __resolveFn
                 * @memberof plat.ui.controls.Select
                 * @kind property
                 * @access private
                 * 
                 * @type {() => void}
                 * 
                 * @description
                 * The function to resolve the itemsLoaded promise.
                 */
                private __resolveFn: () => void;

                /**
                 * @name constructor
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * The constructor for a {@link plat.ui.controls.Select|Select}. Creates the itemsLoaded promise.
                 * 
                 * @returns {plat.ui.controls.Select} A {@link plat.ui.controls.Select|Select} instance.
                 */
                constructor() {
                    super();
                    this.itemsLoaded = new this.$Promise<void>((resolve) => {
                        this.__resolveFn = resolve;
                    });
                }

                /**
                 * @name setTemplate
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Creates the bindable option template and grouping 
                 * template if necessary.
                 * 
                 * @returns {void}
                 */
                setTemplate(): void {
                    var $document = this.$Document,
                        options = this.options || <observable.IObservableProperty<ISelectOptions>>{},
                        platOptions = options.value || <ISelectOptions>{},
                        option = $document.createElement('option'),
                        value = platOptions.value,
                        textContent = platOptions.textContent;

                    // check if the element should be treated as a normal select.
                    if (isUndefined(value) && isUndefined(textContent)) {
                        this.__isNativeSelect = true;
                        return;
                    }

                    if (!isNull(platOptions.group)) {
                        var group = this.__group = platOptions.group,
                            optionGroup = $document.createElement('optgroup');

                        optionGroup.label = __startSymbol + group + __endSymbol;

                        this.bindableTemplates.add('group', optionGroup);
                    }

                    if (!isString(value) || isEmpty(value)) {
                        value = undefined;
                    }

                    if (!isString(textContent) || isEmpty(textContent)) {
                        textContent = undefined;
                    }

                    option.value = __startSymbol + (value || textContent) + __endSymbol;
                    option.textContent = __startSymbol + (textContent || value) + __endSymbol;

                    this.bindableTemplates.add('option', option);
                }

                /**
                 * @name contextChanged
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Re-observes the new array context and modifies 
                 * the options accordingly.
                 * 
                 * @param {Array<any>} newValue? The new array context.
                 * @param {Array<any>} oldValue? The old array context.
                 * 
                 * @returns {void}
                 */
                contextChanged(newValue?: Array<any>, oldValue?: Array<any>): void {
                    if (this.__isNativeSelect || !isArray(newValue)) {
                        return;
                    }

                    var newLength = isArray(newValue) ? newValue.length : 0,
                        oldLength = isArray(oldValue) ? oldValue.length : 0;

                    if (isNull(this.__removeListener)) {
                        this.__removeListener = this.observeArray(this, 'context',
                        (ev?: observable.IArrayMethodInfo<any>) => {
                            if (isFunction((<any>this)['_' + ev.method])) {
                                (<any>this)['_' + ev.method](ev);
                            }
                        });
                    }

                    if (newLength > oldLength) {
                        this._addItems(newLength - oldLength, oldLength);
                    } else if (newLength < oldLength) {
                        this._removeItems(oldLength - newLength);
                    }
                }

                /**
                 * @name loaded
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Observes the new array context and adds 
                 * the options accordingly.
                 * 
                 * @returns {void}
                 */
                loaded(): void {
                    if (this.__isNativeSelect) {
                        return;
                    }

                    var options = this.options || <observable.IObservableProperty<ISelectOptions>>{},
                        platOptions = options.value || <ISelectOptions>{};
                    if (isUndefined(platOptions.value) && isUndefined(platOptions.textContent)) {
                        this.__isNativeSelect = true;
                        return;
                    }

                    var context = this.context,
                        element = this.element,
                        firstElementChild = element.firstElementChild;
                    if (isNode(firstElementChild) && firstElementChild.nodeName.toLowerCase() === 'option') {
                        this.__defaultOption = <HTMLOptionElement>firstElementChild.cloneNode(true);
                    }

                    this.__isGrouped = !isNull((this.__group = platOptions.group));

                    if (!isArray(context)) {
                        return;
                    }

                    this._addItems(context.length, 0);

                    this.__removeListener = this.observeArray(this, 'context', (ev?: observable.IArrayMethodInfo<any>) => {
                        if (isFunction((<any>this)['_' + ev.method])) {
                            (<any>this)['_' + ev.method](ev);
                        }
                    });
                }

                /**
                 * @name dispose
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Stops observing the array context.
                 * 
                 * @returns {void}
                 */
                dispose(): void {
                    if (isFunction(this.__removeListener)) {
                        this.__removeListener();
                        this.__removeListener = null;
                    }

                    this.__resolveFn = null;
                    this.__defaultOption = null;
                }

                /**
                 * @name _addItems
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Adds the options to the select element.
                 * 
                 * @param {number} numberOfItems The number of items to add.
                 * @param {number} length The current index of the next 
                 * set of items to add.
                 * 
                 * @returns {plat.async.IThenable<void>} The itemsLoaded promise.
                 */
                _addItems(numberOfItems: number, length: number): async.IThenable<void> {
                    var index = length,
                        item: any,
                        bindableTemplates = this.bindableTemplates,
                        promises: Array<async.IThenable<void>> = [];

                    for (var i = 0; i < numberOfItems; ++i, ++index) {
                        item = this.context[index];

                        promises.push(bindableTemplates.bind('option', index).then<void>(this._insertOptions.bind(this, index, item)));
                    }

                    if (promises.length > 0) {
                        this.itemsLoaded = this.$Promise.all(promises).then(() => {
                            if (isFunction(this.__resolveFn)) {
                                this.__resolveFn();
                                this.__resolveFn = null;
                            }
                            return;
                        });
                    } else {
                        if (isFunction(this.__resolveFn)) {
                            this.__resolveFn();
                            this.__resolveFn = null;
                        }
                        this.itemsLoaded = new this.$Promise<void>((resolve) => {
                            this.__resolveFn = resolve;
                        });
                    }

                    return this.itemsLoaded;
                }

                /**
                 * @name _insertOptions
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The callback used to add an option after 
                 * its template has been bound.
                 * 
                 * @param {number} index The current index of the item being added.
                 * @param {any} item The item being added.
                 * @param {DocumentFragment} optionClone The bound DocumentFragment to be 
                 * inserted into the DOM.
                 * 
                 * @returns {plat.async.IThenable<void>} A promise that resolves when the option 
                 * or optgroup has successfully be inserted.
                 */
                _insertOptions(index: number, item: any, optionClone: DocumentFragment): async.IThenable<any> {
                    var element = this.element;
                    if (this.__isGrouped) {
                        var groups = this.groups,
                            newGroup = item[this.__group],
                            optgroup: any = groups[newGroup];

                        if (isNull(optgroup)) {
                            return (groups[newGroup] = <any>this.bindableTemplates.bind('group', index)
                                .then((groupClone: DocumentFragment) => {
                                    optgroup = groups[newGroup] = <Element>groupClone.childNodes[1];

                                    optgroup.appendChild(optionClone);
                                    element.appendChild(groupClone);
                                    return optgroup;
                                }));
                        } else if (isPromise(optgroup)) {
                            return optgroup.then((group: Element) => {
                                group.appendChild(optionClone);
                                return group;
                            });
                        }

                        optgroup.appendChild(optionClone);
                        return this.$Promise.resolve(null);
                    }

                    element.appendChild(optionClone);
                    return this.$Promise.resolve(null);
                }

                /**
                 * @name _removeItem
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Removes the specified option item from the DOM.
                 * 
                 * @param {number} index The control index to remove.
                 * 
                 * @returns {void}
                 */
                _removeItem(index: number): void {
                    if (index < 0) {
                        return;
                    }

                    TemplateControl.dispose(this.controls[index]);
                }

                /**
                 * @name _removeItems
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Removes a specified number of elements.
                 * 
                 * @param {number} numberOfItems The number of items 
                 * to remove.
                 * 
                 * @returns {void}
                 */
                _removeItems(numberOfItems: number): void {
                    var controls = this.controls,
                        length = controls.length - 1;

                    while (numberOfItems-- > 0) {
                        this._removeItem(length--);
                    }
                }

                /**
                 * @name _itemRemoved
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when an item has been removed 
                 * from the array context.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _itemRemoved(ev: observable.IArrayMethodInfo<any>): void {
                    if (ev.oldArray.length === 0) {
                        return;
                    } else if (this.__isGrouped) {
                        this._resetSelect();
                        return;
                    }

                    this._removeItems(1);
                }

                /**
                 * @name _resetSelect
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Resets the select element by removing all its 
                 * items and adding them back.
                 * 
                 * @returns {void}
                 */
                _resetSelect(): void {
                    var itemLength = this.context.length,
                        element = this.element,
                        nodeLength = element.childNodes.length;

                    this._removeItems(nodeLength);
                    this.groups = {};
                    if (!isNull(this.__defaultOption)) {
                        element.appendChild(this.__defaultOption.cloneNode(true));
                    }

                    this._addItems(itemLength, 0);
                }

                /**
                 * @name _push
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when an element is pushed to 
                 * the array context.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _push(ev: observable.IArrayMethodInfo<any>): void {
                    this._addItems(ev.arguments.length, ev.oldArray.length);
                }

                /**
                 * @name _pop
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when an item is popped 
                 * from the array context.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _pop(ev: observable.IArrayMethodInfo<any>): void {
                    this._itemRemoved(ev);
                }
        
                /**
                 * @name _shift
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when an item is shifted 
                 * from the array context.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _shift(ev: observable.IArrayMethodInfo<any>): void {
                    this._itemRemoved(ev);
                }
        
                /**
                 * @name _splice
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when items are spliced 
                 * from the array context.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _splice(ev: observable.IArrayMethodInfo<any>): void {
                    if (this.__isGrouped) {
                        this._resetSelect();
                        return;
                    }

                    var oldLength = ev.oldArray.length,
                        newLength = ev.newArray.length;

                    if (newLength > oldLength) {
                        this._addItems(newLength - oldLength, oldLength);
                    } else if (oldLength > newLength) {
                        this._removeItems(oldLength - newLength);
                    }
                }
        
                /**
                 * @name _unshift
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when an item is unshifted 
                 * onto the array context.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _unshift(ev: observable.IArrayMethodInfo<any>): void {
                    if (this.__isGrouped) {
                        this._resetSelect();
                        return;
                    }

                    this._addItems(ev.arguments.length, ev.oldArray.length);
                }
        
                /**
                 * @name _sort
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when the array context 
                 * is sorted.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _sort(ev: observable.IArrayMethodInfo<any>): void {
                    if (this.__isGrouped) {
                        this._resetSelect();
                    }
                }
        
                /**
                 * @name _reverse
                 * @memberof plat.ui.controls.Select
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * The function called when the array context 
                 * is reversed.
                 * 
                 * @param {plat.observable.IArrayMethodInfo<any>} ev The array mutation object
                 * 
                 * @returns {void}
                 */
                _reverse(ev: observable.IArrayMethodInfo<any>): void {
                    if (this.__isGrouped) {
                        this._resetSelect();
                    }
                }
            }

            /**
             * @name ISelectOptions
             * @memberof plat.ui.controls
             * @kind interface
             * 
             * @description
             * The available {@link plat.controls.Options|options} for the {@link plat.ui.controls.Select|Select} control.
             */
            export interface ISelectOptions {
                /**
                 * @name group
                 * @memberof plat.ui.controls.ISelectOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The property in your context array 
                 * of objects to use to group the objects 
                 * into optgroups.
                 */
                group: string;

                /**
                 * @name value
                 * @memberof plat.ui.controls.ISelectOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The property in your context array of 
                 * objects with which to use to bind to the 
                 * option's value.
                 */
                value: string;
        
                /**
                 * @name textContent
                 * @memberof plat.ui.controls.ISelectOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * The property in your context array of 
                 * objects with which to use to bind to the 
                 * option's textContent.
                 */
                textContent: string;
            }

            register.control(__Select, Select);

            /**
             * @name If
             * @memberof plat.ui.controls
             * @kind class
             * 
             * @extends {plat.ui.TemplateControl}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} conditionally adding or removing 
             * a block of nodes to or from the DOM.
             */
            export class If extends TemplateControl {
                /**
                 * @name $Animator
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.ui.animations.IAnimator}
                 * 
                 * @description
                 * Reference to the {@link plat.ui.animations.IAnimator|IAnimator} injectable.
                 */
                $Animator: animations.IAnimator = acquire(__Animator);

                /**
                 * @name options
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access public
                 * 
                 * @type {plat.observable.IObservableProperty<plat.ui.controls.IIfOptions>}
                 * 
                 * @description
                 * The evaluated {@link plat.controls.Options|plat-options} object.
                 */
                options: observable.IObservableProperty<IIfOptions>;

                /**
                 * @name commentNode
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access public
                 * 
                 * @type {Comment}
                 * 
                 * @description
                 * The Comment used to hold the place of the plat-if element.
                 */
                commentNode: Comment;

                /**
                 * @name fragmentStore
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access public
                 * 
                 * @type {DocumentFragment}
                 * 
                 * @description
                 * The DocumentFragment that stores the plat-if element when hidden.
                 */
                fragmentStore: DocumentFragment;

                /**
                 * @name __condition
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access private
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * The current evaluated condition (whether or not the 
                 * control is visible) of the control.
                 */
                private __condition = true;
                /**
                 * @name __firstTime
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access private
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * A boolean value stating whether or not the condition has already 
                 * been evaluated.
                 */
                private __firstTime = true;
                /**
                 * @name __removeListener
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.IRemoveListener}
                 * 
                 * @description
                 * A function to stop listening to changes on the options object.
                 */
                private __removeListener: IRemoveListener;
                /**
                 * @name __leaveAnimation
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.ui.animations.IAnimationThenable<void>}
                 * 
                 * @description
                 * A promise that resolves when the leave animation is finished.
                 */
                private __leaveAnimation: animations.IAnimationThenable<void>;
                /**
                 * @name __enterAnimation
                 * @memberof plat.ui.controls.If
                 * @kind property
                 * @access private
                 * 
                 * @type {plat.ui.animations.IAnimationThenable<void>}
                 * 
                 * @description
                 * A promise that resolves when the entrance animation is finished.
                 */
                private __enterAnimation: animations.IAnimationThenable<void>;

                /**
                 * @name constructor
                 * @memberof plat.ui.controls.If
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * The constructor for a {@link plat.ui.controls.If|If}. Creates the 
                 * DocumentFragment for holding the conditional nodes.
                 * 
                 * @returns {plat.ui.controls.If} A {@link plat.ui.controls.If|If} instance.
                 */
                constructor() {
                    super();
                    var $document: Document = acquire(__Document);
                    this.commentNode = $document.createComment('plat-if' + __BOUND_PREFIX + 'placeholder');
                    this.fragmentStore = $document.createDocumentFragment();
                }

                /**
                 * @name contextChanged
                 * @memberof plat.ui.controls.If
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Checks the options and initializes the 
                 * evaluation.
                 * 
                 * @returns {void}
                 */
                contextChanged(): void {
                    var options = this.options.value;

                    if (isEmpty(options)) {
                        return;
                    }

                    this._setter(options);
                }

                /**
                 * @name loaded
                 * @memberof plat.ui.controls.If
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Sets the visibility to true if no options are 
                 * defined, kicks off the evaluation, and observes 
                 * the options for changes.
                 * 
                 * @returns {void}
                 */
                loaded(): void {
                    if (isNull(this.options)) {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.warn('No condition specified in plat-options for plat-if.', $exception.BIND);

                        this.options = {
                            value: {
                                condition: true
                            },
                            observe: <any>noop
                        };
                    }

                    this.contextChanged();
                    this.__firstTime = false;
                    this.__removeListener = this.options.observe(this._setter);
                }

                /**
                 * @name dispose
                 * @memberof plat.ui.controls.If
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Stops listening to the options for changes.
                 * 
                 * @returns {void}
                 */
                dispose(): void {
                    if (isFunction(this.__removeListener)) {
                        this.__removeListener();
                        this.__removeListener = null;
                    }

                    this.commentNode = null;
                    this.fragmentStore = null;
                }

                /**
                 * @name _setter
                 * @memberof plat.ui.controls.If
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Checks the condition and decides 
                 * whether or not to add or remove 
                 * the node from the DOM.
                 * 
                 * @returns {void}
                 */
                _setter(options: IIfOptions): void {
                    var value = !!options.condition;

                    if (value === this.__condition) {
                        return;
                    }

                    if (value) {
                        if (!isNull(this.__leaveAnimation)) {
                            this.__leaveAnimation.cancel().then(() => {
                                this.__leaveAnimation = null;
                                this._addItem();
                            });
                        } else {
                            this._addItem();
                        }
                    } else {
                        if (!isNull(this.__enterAnimation)) {
                            this.__enterAnimation.cancel().then(() => {
                                this.__enterAnimation = null;
                                this._removeItem();
                            });
                        } else {
                            this._removeItem();
                        }
                    }

                    this.__condition = value;
                }

                /**
                 * @name _addItem
                 * @memberof plat.ui.controls.If
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Adds the conditional nodes to the DOM.
                 * 
                 * @returns {void}
                 */
                _addItem(): void {
                    var commentNode = this.commentNode,
                        parentNode = commentNode.parentNode;

                    if (!isNode(parentNode)) {
                        return;
                    }

                    parentNode.replaceChild(this.fragmentStore, commentNode);
                    this.__enterAnimation = this.$Animator.animate(this.element, __Enter).then(() => {
                        this.__enterAnimation = null;
                    });
                }

                /**
                 * @name _removeItem
                 * @memberof plat.ui.controls.If
                 * @kind function
                 * @access protected
                 * 
                 * @description
                 * Removes the conditional nodes from the DOM.
                 * 
                 * @returns {void}
                 */
                _removeItem(): void {
                    var element = this.element;

                    if (this.__firstTime) {
                        element.parentNode.insertBefore(this.commentNode, element);
                        insertBefore(this.fragmentStore, element);
                        return;
                    }

                    this.__leaveAnimation = this.$Animator.animate(element, __Leave).then(() => {
                        this.__leaveAnimation = null;
                        element.parentNode.insertBefore(this.commentNode, element);
                        insertBefore(this.fragmentStore, element);
                    });
                }
            }

            /**
             * @name IIfOptions
             * @memberof plat.ui.controls
             * @kind interface
             * 
             * @description
             * The available {@link plat.controls.Options|options} for the {@link plat.ui.controls.If|If} control.
             */
            export interface IIfOptions {
                /**
                 * @name condition
                 * @memberof plat.ui.controls.IIfOptions
                 * @kind property
                 * @access public
                 * 
                 * @type {boolean}
                 * 
                 * @description
                 * A boolean expression to bind to whether or not the conditional 
                 * nodes are present on the DOM.
                 */
                condition: boolean;
            }

            register.control(__If, If);

            /**
             * @name Anchor
             * @memberof plat.ui.controls
             * @kind class
             * @exported false
             * 
             * @extends {plat.ui.TemplateControl}
             * 
             * @description
             * A {@link plat.ui.TemplateControl|TemplateControl} for adding additonal 
             * functionality to a native HTML anchor tag.
             */
            class Anchor extends TemplateControl {
                /**
                 * @name replaceWith
                 * @memberof plat.ui.controls.Anchor
                 * @kind property
                 * @access public
                 * 
                 * @type {string}
                 * 
                 * @description
                 * Replaces the {@link plat.ui.controls.Anchor|Anchor's} element with a native anchor tag.
                 */
                replaceWith = 'a';
                /**
                 * @name element
                 * @memberof plat.ui.controls.Anchor
                 * @kind property
                 * @access public
                 * 
                 * @type {HTMLAnchorElement}
                 * 
                 * @description
                 * The control's anchor element.
                 */
                element: HTMLAnchorElement;
                /**
                 * @name initialize
                 * @memberof plat.ui.controls.Anchor
                 * @kind function
                 * @access public
                 * 
                 * @description
                 * Prevents default on the anchor tag if the href attribute is left empty.
                 * 
                 * @returns {void}
                 */
                initialize(): void {
                    var element = this.element;
                    if (isEmpty(element.href)) {
                        this.addEventListener(element, 'click', (ev: Event) => {
                            if (isEmpty(element.href)) {
                                ev.preventDefault();
                            }
                        }, false);
                    }
                }
            }

            register.control(__Anchor, Anchor);
        }
    }
    /**
     * @name processing
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds classes and interfaces related to Document processing in platypus.
     */
    export module processing {
        /**
         * @name Compiler
         * @memberof plat.processing
         * @kind class
         * 
         * @implements {plat.processing.ICompiler}
         * 
         * @description
         * Responsible for iterating through the DOM and collecting controls.
         */
        export class Compiler implements ICompiler {
            /**
             * @name $ElementManagerFactory
             * @memberof plat.processing.Compiler
             * @kind property
             * @access public
             * 
             * @type {plat.processing.IElementManagerFactory}
             * 
             * @description
             * Reference to the {@link plat.processing.IElementManagerFactory|IElementManagerFactory} injectable.
             */
            $ElementManagerFactory: IElementManagerFactory = acquire(__ElementManagerFactory);
            /**
             * @name $TextManagerFactory
             * @memberof plat.processing.Compiler
             * @kind property
             * @access public
             * 
             * @type {plat.processing.IElementManagerFactory}
             * 
             * @description
             * Reference to the {@link plat.processing.ITextManagerFactory|ITextManagerFactory} injectable.
             */
            $TextManagerFactory: ITextManagerFactory = acquire(__TextManagerFactory);
            /**
             * @name $CommentManagerFactory
             * @memberof plat.processing.Compiler
             * @kind property
             * @access public
             * 
             * @type {plat.processing.ICommentManagerFactory}
             * 
             * @description
             * Reference to the {@link plat.processing.ICommentManagerFactory|ICommentManagerFactory} injectable.
             */
            $CommentManagerFactory: ICommentManagerFactory = acquire(__CommentManagerFactory);
            /**
             * @name $ManagerCache
             * @memberof plat.processing.Compiler
             * @kind property
             * @access public
             * 
             * @type {plat.storage.ICache<processing.IElementManager>}
             * 
             * @description
             * Reference to a cache injectable that stores {@link plat.processing.IElementManager|IElementManagers}.
             */
            $ManagerCache: storage.ICache<INodeManager> = acquire(__ManagerCache);
        
            /**
             * @name compile
             * @memberof plat.processing.Compiler
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Goes through the child Nodes of the given Node, finding elements that contain controls as well as
             * text that contains markup.
             * 
             * @param {Node} node The node whose childNodes are going to be compiled.
             * @param {plat.ui.ITemplateControl} control? The parent control for the given Node. The parent must implement the 
             * {@link plat.ui.ITemplateControl|ITemplateControl interface} since only they can contain templates.
             * 
             * @returns {void}
             */
            compile(node: Node, control?: ui.ITemplateControl): void;
            /**
             * @name compile
             * @memberof plat.processing.Compiler
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Goes through the Node array, finding elements that contain controls as well as
             * text that contains markup.
             * 
             * @param {Array<Node>} nodes The nodes that are going to be compiled.
             * @param {plat.ui.ITemplateControl} control? The parent control for the given Node. The parent must implement the 
             * {@link plat.ui.ITemplateControl|ITemplateControl interface} since only they can contain templates.
             * 
             * @returns {void}
             */
            compile(nodes: Array<Node>, control?: ui.ITemplateControl): void;
            /**
             * @name compile
             * @memberof plat.processing.Compiler
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Goes through the NodeList, finding elements that contain controls as well as
             * text that contains markup.
             * 
             * @param {NodeList} nodes The NodeList that is going to be compiled.
             * @param {plat.ui.ITemplateControl} control? The parent control for the given Node. The parent must implement the 
             * {@link plat.ui.ITemplateControl|ITemplateControl interface} since only they can contain templates.
             * 
             * @returns {void}
             */
            compile(nodes: NodeList, control?: ui.ITemplateControl): void;
            compile(node: any, control?: ui.ITemplateControl): void {
                var childNodes = node.childNodes,
                    length: number,
                    newLength: number,
                    childNode: Node,
                    hasControl = !isNull(control),
                    manager = <IElementManager>(hasControl ? this.$ManagerCache.read(control.uid) : null),
                    create = this.$ElementManagerFactory.create;

                if (!isUndefined(childNodes)) {
                    childNodes = Array.prototype.slice.call(childNodes);
                } else if (isFunction(node.push)) {
                    childNodes = node;
                } else {
                    childNodes = Array.prototype.slice.call(node);
                }

                if (isNull(manager)) {
                    length = childNodes.length;

                    for (var i = 0; i < length; ++i) {
                        childNode = childNodes[i];
                        if (childNode.nodeType === Node.ELEMENT_NODE) {
                            if (!isNull(create(<Element>childNode))) {
                                this.compile(childNode);
                            }
                        }

                        newLength = childNodes.length;
                        i += newLength - length;
                        length = newLength;
                    }
                } else {
                    this._compileNodes(childNodes, manager);
                }
            }
        
            /**
             * @name _compileNodes
             * @memberof plat.processing.Compiler
             * @kind function
             * @access protected
             * 
             * @description
             * Iterates through the array of nodes creating {@link plat.processing.IElementManager|IElementManagers} on Element 
             * nodes, {@link plat.processing.ITextManager|ITextManagers} on text nodes, and 
             * {@link plat.processing.ICommentManager|ICommentManagers} on comment nodes.
             * 
             * @param {Array<Node>} nodes The array of nodes to be compiled. 
             * @param {plat.processing.IElementManager} manager The parent {@link plat.processing.IElementManager|IElementManagers} 
             * for the given array of nodes.
             * 
             * @returns {void}
             */
            /**
             * Iterates through the array of nodes creating Element Managers on Element 
             * nodes, Text Managers on text nodes, and Comment Managers on comment nodes.
             * 
             * @param nodes The NodeList to be compiled. 
             * @param manager The parent Element Manager for the given array of nodes.
             */
            _compileNodes(nodes: Array<Node>, manager: IElementManager): void {
                var length = nodes.length,
                    node: Node,
                    newManager: IElementManager,
                    newLength: number,
                    create = this.$ElementManagerFactory.create,
                    commentCreate = this.$CommentManagerFactory.create,
                    textCreate = this.$TextManagerFactory.create;

                for (var i = 0; i < length; ++i) {
                    node = nodes[i];
                    switch (node.nodeType) {
                        case Node.ELEMENT_NODE:
                            newManager = create(<Element>node, manager);
                            if (!isNull(newManager)) {
                                this._compileNodes(Array.prototype.slice.call(node.childNodes), newManager);
                            }
                            break;
                        case Node.TEXT_NODE:
                            textCreate(node, manager);
                            break;
                        case Node.COMMENT_NODE:
                            commentCreate(node, manager);
                            break;
                    }
                    newLength = nodes.length;
                    i += newLength - length;
                    length = newLength;
                }
            }
        }

        /**
         * The Type for referencing the '$Compiler' injectable as a dependency.
         */
        export function ICompiler(): ICompiler {
            return new Compiler();
        }

        register.injectable(__Compiler, ICompiler);
    
        /**
         * @name ICompiler
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Describes an object that iterates through the DOM and collects controls.
         */
        export interface ICompiler {
            /**
             * @name compile
             * @memberof plat.processing.ICompiler
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Goes through the child Nodes of the given Node, finding elements that contain controls as well as
             * text that contains markup.
             * 
             * @param {Node} node The node whose childNodes are going to be compiled.
             * @param {plat.ui.ITemplateControl} control? The parent control for the given Node. The parent must implement the 
             * {@link plat.ui.ITemplateControl|ITemplateControl interface} since only they can contain templates.
             * 
             * @returns {void}
             */
            compile(node: Node, control?: ui.ITemplateControl): void;
            /**
             * @name compile
             * @memberof plat.processing.ICompiler
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Goes through the Node array, finding elements that contain controls as well as
             * text that contains markup.
             * 
             * @param {Array<Node>} nodes The nodes that are going to be compiled.
             * @param {plat.ui.ITemplateControl} control? The parent control for the given Node. The parent must implement the 
             * {@link plat.ui.ITemplateControl|ITemplateControl interface} since only they can contain templates.
             * 
             * @returns {void}
             */
            compile(nodes: Array<Node>, control?: ui.ITemplateControl): void;
            /**
             * @name compile
             * @memberof plat.processing.ICompiler
             * @kind function
             * @access public
             * @variation 2
             * 
             * @description
             * Goes through the NodeList, finding elements that contain controls as well as
             * text that contains markup.
             * 
             * @param {NodeList} nodes The NodeList that is going to be compiled.
             * @param {plat.ui.ITemplateControl} control? The parent control for the given Node. The parent must implement the 
             * {@link plat.ui.ITemplateControl|ITemplateControl interface} since only they can contain templates.
             * 
             * @returns {void}
             */
            compile(nodes: NodeList, control?: ui.ITemplateControl): void;
        }

        /**
         * @name NodeManager
         * @memberof plat.processing
         * @kind class
         * 
         * @implements {plat.processing.INodeManager}
         * 
         * @description
         * Responsible for data binding a data context to a Node.
         */
        export class NodeManager implements INodeManager {
            /**
             * @name $ContextManagerStatic
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.observable.IContextManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
             */
            static $ContextManagerStatic: observable.IContextManagerStatic;
            /**
             * @name $Parser
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.expressions.IParser}
             * 
             * @description
             * Reference to the {@link plat.expressions.IParser|IParser} injectable.
             */
            static $Parser: expressions.IParser;
            /**
             * @name $TemplateControlFactory
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {plat.ui.ITemplateControlFactory}
             * 
             * @description
             * Reference to the {@link ui.ITemplateControlFactory|ITemplateControlFactory} injectable.
             */
            static $TemplateControlFactory: ui.ITemplateControlFactory;
        
            /**
             * @name findUniqueIdentifiers
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Given an {@link plat.expressions.IParsedExpression|IParsedExpression} array, creates an array of unique identifers 
             * to use with binding. This allows us to avoid creating multiple listeners for the identifier and node.
             * 
             * @param {Array<plat.expressions.IParsedExpression>} expressions An array of parsed expressions to search for identifiers.
             * 
             * @returns {Array<string>} An array of unique identifiers.
             */
            static findUniqueIdentifiers(expressions: Array<expressions.IParsedExpression>): Array<string> {
                var length = expressions.length,
                    uniqueIdentifierObject: IObject<boolean> = {},
                    uniqueIdentifiers: Array<string> = [],
                    identifiers: Array<string>,
                    identifier: string,
                    j: number,
                    jLength: number;

                if (length === 1) {
                    return expressions[0].identifiers.slice(0);
                }

                for (var i = 0; i < length; ++i) {
                    identifiers = expressions[i].identifiers;
                    jLength = identifiers.length;

                    for (j = 0; j < jLength; ++j) {
                        identifier = identifiers[j];
                        if (isNull(uniqueIdentifierObject[identifier])) {
                            uniqueIdentifierObject[identifier] = true;
                            uniqueIdentifiers.push(identifier);
                        }
                    }
                }

                return uniqueIdentifiers;
            }
        
            /**
             * @name hasMarkup
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines if a string has the markup notation.
             * 
             * @param {string} text The text string in which to search for markup.
             * 
             * @returns {boolean} Indicates whether or not there is markup.
             */
            static hasMarkup(text: string): boolean {
                return NodeManager._markupRegex.test(text);
            }
        
            /**
             * @name findMarkup
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Given a string, finds markup in the string and creates an array of 
             * {@link plat.expressions.IParsedExpression|IParsedExpression}.
             * 
             * @param {string} text The text string in which to search for markup.
             * 
             * @returns {Array<plat.expressions.IParsedExpression>} An array of parsed expressions that 
             * composes the output given a proper context.
             */
            static findMarkup(text: string): Array<expressions.IParsedExpression> {
                var start: number,
                    end: number,
                    parsedExpressions: Array<expressions.IParsedExpression> = [],
                    wrapExpression = NodeManager._wrapExpression,
                    substring: string,
                    expression: expressions.IParsedExpression,
                    $parser = NodeManager.$Parser;

                text = text.replace(NodeManager._newLineRegex, '');

                while ((start = text.indexOf(__startSymbol)) !== -1 && (end = text.indexOf(__endSymbol)) !== -1) {
                    if (start !== 0) {
                        parsedExpressions.push(wrapExpression(text.slice(0, start)));
                    }

                    // incremement with while loop instead of just += 2 for nested object literal case.
                    while (text[++end] === '}') { }

                    substring = text.slice(start + 2, end - 2);

                    // check for one-time databinding
                    if (substring[0] === '=') {
                        substring = substring.slice(1).trim();
                        expression = $parser.parse(substring);
                        expression = {
                            expression: expression.expression,
                            evaluate: expression.evaluate,
                            identifiers: [],
                            aliases: expression.aliases,
                            oneTime: true
                        };
                        parsedExpressions.push(expression);
                    } else {
                        parsedExpressions.push($parser.parse(substring.trim()));
                    }

                    text = text.slice(end);
                }

                if (start > -1 && end >= 0) {
                    parsedExpressions.push(wrapExpression(text.slice(end)));
                } else if (text !== '') {
                    parsedExpressions.push(wrapExpression(text));
                }

                return parsedExpressions;
            }
        
            /**
             * @name build
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Takes in a control with a data context and an array of {@link plat.expressions.IParsedExpression|IParsedExpression} 
             * and outputs a string of the evaluated expressions.
             * 
             * @param {Array<plat.expressions.IParsedExpression>} expressions The composition array to evaluate.
             * @param {plat.ui.ITemplateControl} control? The {@link plat.ui.ITemplateControl|ITemplateControl} used to parse 
             * the expressions.
             * 
             * @returns {string} The output text with all markup bound.
             */
            static build(expressions: Array<expressions.IParsedExpression>, control?: ui.ITemplateControl): string {
                var text = '',
                    length = expressions.length,
                    resources = {},
                    expression: expressions.IParsedExpression,
                    value: any,
                    evaluateExpression = NodeManager.$TemplateControlFactory.evaluateExpression;

                for (var i = 0; i < length; ++i) {
                    expression = expressions[i];

                    value = evaluateExpression(expression, control, resources);

                    if (isObject(value)) {
                        try {
                            text += JSON.stringify(value, null, 4);
                        } catch (e) {
                            if (!isNull(e.description)) {
                                e.description = 'Cannot stringify object: ' + e.description;
                            }
                            e.message = 'Cannot stringify object: ' + e.message;

                            var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                            $exception.warn(e, $exception.PARSE);
                        }
                    } else if (!isNull(value)) {
                        text += value;
                    }

                    if (expression.oneTime) {
                        expressions[i] = NodeManager._wrapExpression(value);
                    }
                }

                return text;
            }
        
            /**
             * @name observeIdentifiers
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Registers a listener to be notified of a change in any associated identifier.
             * 
             * @param {Array<string>} identifiers An Array of identifiers to observe.
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} associated 
             * to the identifiers.
             * @param {(...args: Array<any>) => void} listener The listener to call when any identifier property changes.
             * 
             * @returns {void}
             */
            static observeIdentifiers(identifiers: Array<string>, control: ui.ITemplateControl,
                listener: (...args: Array<any>) => void): void {
                var length = identifiers.length,
                    $contextManager = NodeManager.$ContextManagerStatic,
                    rootManager = $contextManager.getManager(Control.getRootControl(control)),
                    absoluteContextPath = control.absoluteContextPath,
                    context = control.context,
                    observableCallback = {
                        listener: listener,
                        uid: control.uid
                    },
                    resources: IObject<{
                        resource: ui.IResource;
                        control: ui.ITemplateControl;
                    }>  = {},
                    resourceObj: {
                        resource: ui.IResource;
                        control: ui.ITemplateControl;
                    },
                    manager: observable.IContextManager,
                    split: Array<string>,
                    alias: string,
                    absoluteIdentifier: string,
                    identifier: string;

                for (var i = 0; i < length; ++i) {
                    identifier = identifiers[i];
                    absoluteIdentifier = '';

                    if (identifier[0] === '@') {
                        // we found an alias
                        split = identifier.split('.');
                        alias = split.shift().slice(1);

                        if (split.length > 0) {
                            absoluteIdentifier = '.' + split.join('.');
                        }

                        resourceObj = resources[alias];

                        if (isNull(resourceObj)) {
                            resourceObj = resources[alias] = control.findResource(alias);
                        }

                        if (!isNull(resourceObj) && !isNull(resourceObj.resource) && resourceObj.resource.type === 'observable') {
                            manager = $contextManager.getManager(resources[alias].control);
                            absoluteIdentifier = 'resources.' + alias + '.value' + absoluteIdentifier;
                        } else {
                            continue;
                        }
                    } else {
                        // look on the control.context
                        split = identifier.split('.');

                        if (!isNull($contextManager.getContext(context, split))) {
                            manager = rootManager;
                            absoluteIdentifier = absoluteContextPath + '.' + identifier;
                        } else if (!isNull($contextManager.getContext(control, split))) {
                            manager = null;
                        } else {
                            manager = rootManager;
                            absoluteIdentifier = absoluteContextPath + '.' + identifier;
                        }
                    }

                    if (!isNull(manager)) {
                        manager.observe(absoluteIdentifier, observableCallback);
                    }
                }
            }
        
            /**
             * @name _markupRegex
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access protected
             * @static
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for finding markup
             */
            static _markupRegex: RegExp;
        
            /**
             * @name _newLineRegex
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access protected
             * @static
             * 
             * @type {RegExp}
             * 
             * @description
             * A regular expression for finding newline characters.
             */
            static _newLineRegex: RegExp;
        
            /**
             * @name _wrapExpression
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Wraps constant text as a static {@link plat.expressions.IParsedExpression|IParsedExpression}.
             * 
             * @param text The text to wrap into a static expression.
             * 
             * @returns {plat.expressions.IParsedExpression} The wrapped, static expression.
             */
            static _wrapExpression(text: string): expressions.IParsedExpression {
                return {
                    evaluate: () => text,
                    identifiers: [],
                    aliases: [],
                    expression: text
                };
            }
        
            /**
             * @name type
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of {@link plat.processing.INodeManager|INodeManager}.
             */
            type: string;
            /**
             * @name nodeMap
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access public
             * 
             * @type {plat.processing.INodeMap}
             * 
             * @description
             * The {@link plat.processing.INodeMap|INodeMap} for this {@link plat.processing.INodeManager|INodeManager}. 
             * Contains the compiled Node.
             */
            nodeMap: INodeMap;
            /**
             * @name parent
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access public
             * 
             * @type {plat.processing.IElementManager}
             * 
             * @description
             * The parent {@link plat.processing.IElementManager|IElementManager}.
             */
            parent: IElementManager;
            /**
             * @name isClone
             * @memberof plat.processing.NodeManager
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not this {@link plat.processing.INodeManager|INodeManager} is a clone.
             */
            isClone = false;
        
            /**
             * @name initialize
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the manager's properties.
             * 
             * @param {plat.processing.INodeMap} nodeMap The mapping associated with this manager. We have to use an 
             * Used to treat all {@link plat.processing.INodeManager|INodeManagers} the same.
             * @param {plat.processing.IElementManager} parent The parent {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {void}
             */
            initialize(nodeMap: INodeMap, parent: IElementManager): void {
                this.nodeMap = nodeMap;
                this.parent = parent;

                if (!isNull(parent)) {
                    this.isClone = parent.isClone;
                    parent.children.push(this);
                }
            }
        
            /**
             * @name getParentControl
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * 
             * @description
             * Retrieves the parent control associated with the parent manager.
             * 
             * @returns {plat.ui.ITemplateControl} The parent {@link plat.ui.ITemplateControl|ITemplateControl}.
             */
            getParentControl(): ui.ITemplateControl {
                var parent = this.parent,
                    control: ui.ITemplateControl;

                while (isNull(control)) {
                    if (isNull(parent)) {
                        break;
                    }

                    control = parent.getUiControl();
                    parent = parent.parent;
                }

                return control;
            }
        
            /**
             * @name clone
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * 
             * @description
             * Clones this {@link plat.processing.INodeManager|INodeManager} with the new node.
             * 
             * @param {Node} newNode The new node associated with the new manager.
             * @param {plat.processing.IElementManager} parentManager The parent 
             * {@link plat.processing.IElementManager|IElementManager} for the clone.
             * 
             * @returns {number} The number of nodes to advance while node traversal is in progress.
             */
            clone(newNode: Node, parentManager: IElementManager): number {
                return 1;
            }
        
            /**
             * @name bind
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * 
             * @description
             * The function used for data-binding a data context to the DOM.
             * 
             * @returns {void}
             */
            bind(): void { }
        }

        /**
         * The Type for referencing the '$NodeManagerStatic' injectable as a dependency.
         */
        export function INodeManagerStatic(
            $Regex?: expressions.IRegex,
            $ContextManagerStatic?: observable.IContextManagerStatic,
            $Parser?: expressions.IParser,
            $TemplateControlFactory?: ui.ITemplateControlFactory): INodeManagerStatic {
                NodeManager._markupRegex = $Regex.markupRegex;
                NodeManager._newLineRegex = $Regex.newLineRegex;
                NodeManager.$ContextManagerStatic = $ContextManagerStatic;
                NodeManager.$Parser = $Parser;
                NodeManager.$TemplateControlFactory = $TemplateControlFactory;
                return NodeManager;
        }

        register.injectable(__NodeManagerStatic, INodeManagerStatic, [
            __Regex,
            __ContextManagerStatic,
            __Parser,
            __TemplateControlFactory
        ], __STATIC);
    
        /**
         * @name INodeManagerStatic
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Performs essential Node management and binding functions. 
         */
        export interface INodeManagerStatic {
            /**
             * @name findUniqueIdentifiers
             * @memberof plat.processing.INodeManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Given an {@link plat.expressions.IParsedExpression|IParsedExpression} array, creates an array of unique identifers 
             * to use with binding. This allows us to avoid creating multiple listeners for the identifier and node.
             * 
             * @param {Array<plat.expressions.IParsedExpression>} expressions An array of parsed expressions to search for identifiers.
             * 
             * @returns {Array<string>} An array of unique identifiers.
             */
            findUniqueIdentifiers(expressions: Array<expressions.IParsedExpression>): Array<string>;

            /**
             * @name hasMarkup
             * @memberof plat.processing.INodeManagerStatic
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines if a string has the markup notation.
             * 
             * @param {string} text The text string in which to search for markup.
             * 
             * @returns {boolean} Indicates whether or not there is markup.
             */
            hasMarkup(text: string): boolean;

            /**
             * @name findMarkup
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Given a string, finds markup in the string and creates an array of 
             * {@link plat.expressions.IParsedExpression|IParsedExpression}.
             * 
             * @param {string} text The text string in which to search for markup.
             * 
             * @returns {Array<plat.expressions.IParsedExpression>} An array of parsed expressions that 
             * composes the output given a proper context.
             */
            findMarkup(text: string): Array<expressions.IParsedExpression>;

            /**
             * @name build
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Takes in a control with a data context and an array of {@link plat.expressions.IParsedExpression|IParsedExpression} 
             * and outputs a string of the evaluated expressions.
             * 
             * @param {Array<plat.expressions.IParsedExpression>} expressions The composition array to evaluate.
             * @param {plat.ui.ITemplateControl} control? The {@link plat.ui.ITemplateControl|ITemplateControl} used to parse 
             * the expressions.
             * 
             * @returns {string} The output text with all markup bound.
             */
            build(expressions: Array<expressions.IParsedExpression>, control?: ui.ITemplateControl): string;

            /**
             * @name observeIdentifiers
             * @memberof plat.processing.NodeManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Registers a listener to be notified of a change in any associated identifier.
             * 
             * @param {Array<string>} identifiers An Array of identifiers to observe.
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} associated 
             * to the identifiers.
             * @param {(...args: Array<any>) => void} listener The listener to call when any identifier property changes.
             * 
             * @returns {void}
             */
            observeIdentifiers(identifiers: Array<string>,
                control: ui.ITemplateControl, listener: (...args: Array<any>) => void): void;
        }
    
        /**
         * @name INodeManager
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Describes an object that takes a Node and provides a way to data-bind to that node.
         */
        export interface INodeManager {
            /**
             * @name type
             * @memberof plat.processing.INodeManager
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The type of {@link plat.processing.INodeManager|INodeManager}.
             */
            type: string;
        
            /**
             * @name nodeMap
             * @memberof plat.processing.INodeManager
             * @kind property
             * @access public
             * 
             * @type {plat.processing.INodeMap}
             * 
             * @description
             * The {@link plat.processing.INodeMap|INodeMap} for this {@link plat.processing.INodeManager|INodeManager}. 
             * Contains the compiled Node.
             */
            nodeMap?: INodeMap;
        
            /**
             * @name parent
             * @memberof plat.processing.INodeManager
             * @kind property
             * @access public
             * 
             * @type {plat.processing.IElementManager}
             * 
             * @description
             * The parent {@link plat.processing.IElementManager|IElementManager}.
             */
            parent?: IElementManager;
        
            /**
             * @name isClone
             * @memberof plat.processing.INodeManager
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Whether or not this {@link plat.processing.INodeManager|INodeManager} is a clone.
             */
            isClone?: boolean;

            /**
             * @name initialize
             * @memberof plat.processing.INodeManager
             * @kind function
             * @access public
             * 
             * @description
             * Initializes the manager's properties.
             * 
             * @param {plat.processing.INodeMap} nodeMap The mapping associated with this manager. We have to use an 
             * Used to treat all {@link plat.processing.INodeManager|INodeManagers} the same.
             * @param {plat.processing.IElementManager} parent The parent {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {void}
             */
            initialize? (nodeMap: INodeMap, parent: IElementManager): void;

            /**
             * @name getParentControl
             * @memberof plat.processing.INodeManager
             * @kind function
             * @access public
             * 
             * @description
             * Retrieves the parent control associated with the parent manager.
             * 
             * @returns {plat.ui.ITemplateControl} The parent {@link plat.ui.ITemplateControl|ITemplateControl}.
             */
            getParentControl? (): ui.ITemplateControl;

            /**
             * @name clone
             * @memberof plat.processing.INodeManager
             * @kind function
             * @access public
             * 
             * @description
             * Clones this {@link plat.processing.INodeManager|INodeManager} with the new node.
             * 
             * @param {Node} newNode The new node associated with the new manager.
             * @param {plat.processing.IElementManager} parentManager The parent 
             * {@link plat.processing.IElementManager|IElementManager} for the clone.
             * 
             * @returns {number} The number of nodes to advance while node traversal is in progress.
             */
            clone? (newNode: Node, parentManager: IElementManager): number;

            /**
             * @name bind
             * @memberof plat.processing.INodeManager
             * @kind function
             * @access public
             * 
             * @description
             * The function used for data-binding a data context to the DOM.
             * 
             * @returns {void}
             */
            bind(): void;
        }
    
        /**
         * @name INode
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Describes a compiled Node.
         */
        export interface INode {
            /**
             * @name control
             * @memberof plat.processing.INode
             * @kind property
             * @access public
             * 
             * @type {plat.IControl}
             * 
             * @description
             * The control associated with the Node, if one exists.
             */
            control?: IControl;
        
            /**
             * @name node
             * @memberof plat.processing.INode
             * @kind property
             * @access public
             * 
             * @type {Node}
             * 
             * @description
             * The Node that is compiled.
             */
            node?: Node;
        
            /**
             * @name nodeName
             * @memberof plat.processing.INode
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The name of the Node.
             */
            nodeName?: string;
        
            /**
             * @name expressions
             * @memberof plat.processing.INode
             * @kind property
             * @access public
             * 
             * @type {Array<plat.expressions.IParsedExpression>}
             * 
             * @description
             * Any {@link plat.expressions.IParsedExpressions|IParsedExpressions} contained in the Node.
             */
            expressions?: Array<expressions.IParsedExpression>;
        
            /**
             * @name identifiers
             * @memberof plat.processing.INode
             * @kind property
             * @access public
             * 
             * @type {Array<string>}
             * 
             * @description
             * Unique identifiers contained in the Node.
             */
            identifiers?: Array<string>;
        
            /**
             * @name injector
             * @memberof plat.processing.INode
             * @kind property
             * @access public
             * 
             * @type {plat.dependency.IInjector<plat.IControl>}
             * 
             * @description
             * The injector for a control associated with the Node, if one exists.
             */
            injector?: dependency.IInjector<IControl>;
        }

        /**
         * @name IUiControlNode
         * @memberof plat.processing
         * @kind interface
         * 
         * @extends {plat.processing.INode}
         * 
         * @description
         * Defines the interface for a compiled Element.
         */
        export interface IUiControlNode extends INode {
            /**
             * @name control
             * @memberof plat.processing.IUiControlNode
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControl}
             * 
             * @description
             * The control associated with the Element, if one exists.
             */
            control: ui.ITemplateControl;
        
            /**
             * @name resourceElement
             * @memberof plat.processing.IUiControlNode
             * @kind property
             * @access public
             * 
             * @type {HTMLElement}
             * 
             * @description
             * The resources element, if one exists, defined as the control element's first
             * element child.
             */
            resourceElement?: HTMLElement;
        }

        /**
         * @name INodeMap
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Describes a compiled Element with all 
         * associated nodes contained within its tag.
         */
        export interface INodeMap {
            /**
             * @name element
             * @memberof plat.processing.INodeMap
             * @kind property
             * @access public
             * 
             * @type {HTMLElement}
             * 
             * @description
             * The Element that is compiled.
             */
            element?: HTMLElement;
        
            /**
             * @name nodes
             * @memberof plat.processing.INodeMap
             * @kind property
             * @access public
             * 
             * @type {Array<plat.processing.INode>}
             * 
             * @description
             * The compiled attribute Nodes for the Element.
             */
            nodes: Array<INode>;
        
            /**
             * @name attributes
             * @memberof plat.processing.INodeMap
             * @kind property
             * @access public
             * 
             * @type {plat.IObject<string>}
             * 
             * @description
             * An object of key/value attribute pairs.
             */
            attributes?: IObject<string>;
        
            /**
             * @name childContext
             * @memberof plat.processing.INodeMap
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * The relative context path for the node's corresponding 
             * {@link plat.ui.ITemplateControl|ITemplateControl}, if specified.
             */
            childContext?: string;
        
            /**
             * @name hasControl
             * @memberof plat.processing.INodeMap
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Indicates whether or not an {@link plat.IControl|IControl} was found on the Element.
             */
            hasControl?: boolean;
        
            /**
             * @name uiControlNode
             * @memberof plat.processing.INodeMap
             * @kind property
             * @access public
             * 
             * @type {plat.processing.IUiControlNode}
             * 
             * @description
             * A type of {@link plat.processing.INode|INode} for a node that contains a {@link plat.ui.ITemplateControl|ITemplateControl}, 
             * if one was found for the Element.
             */
            uiControlNode?: IUiControlNode;
        }

        /**
         * @name ElementManager
         * @memberof plat.processing
         * @kind class
         * 
         * @extends {plat.processing.NodeManager}
         * @implements {plat.processing.IElementManager}
         * 
         * @description
         * A class used to manage element nodes. Provides a way for compiling and binding the 
         * element/template. Also provides methods for cloning an 
         * {@link plat.processing.IElementManager|IElementManager}.
         */
        export class ElementManager extends NodeManager implements IElementManager {
            /**
             * @name $Document
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * @static
             * 
             * @type {Document}
             * 
             * @description
             * Reference to the Document injectable.
             */
            static $Document: Document;
            /**
             * @name $ManagerCache
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.storage.ICache<processing.IElementManager>}
             * 
             * @description
             * Reference to a cache injectable that stores {@link plat.processing.IElementManager|IElementManagers}.
             */
            static $ManagerCache: storage.ICache<IElementManager>;
            /**
             * @name $ResourcesFactory
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IResourcesFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.IResourcesFactory|IResourcesFactory} injectable.
             */
            static $ResourcesFactory: ui.IResourcesFactory;
            /**
             * @name $BindableTemplatesFactory
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IBindableTemplatesFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.IBindableTemplatesFactory|IBindableTemplatesFactory} injectable.
             */
            static $BindableTemplatesFactory: ui.IBindableTemplatesFactory;
        
            /**
             * @name create
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines if the associated Element has controls that need to be instantiated or Attr nodes
             * containing text markup. If controls exist or markup is found a new 
             * {@link plat.processing.ElementManager|ElementManager} will be created,
             * else an empty {@link plat.processing.INodeManager|INodeManager} will be added to the Array of 
             * {@link plat.processing.INodeManager|INodeManagers}.
             * 
             * @param {Element} element The Element to use to identifier markup and controls.
             * @param {plat.processing.IElementManager} parent? The parent {@link plat.processing.IElementManager|IElementManager} 
             * used for context inheritance.
             * 
             * @returns {plat.processing.IElementManager}
             */
            static create(element: Element, parent?: IElementManager): IElementManager {
                var name = element.nodeName.toLowerCase(),
                    nodeName = name,
                    injector = controlInjectors[name] || viewControlInjectors[name],
                    noControlAttribute = true,
                    hasUiControl = false,
                    uiControlNode: IUiControlNode;

                if (isNull(injector)) {
                    if (element.hasAttribute('plat-control')) {
                        name = element.getAttribute('plat-control').toLowerCase();
                        injector = controlInjectors[name] || viewControlInjectors[name];
                        noControlAttribute = false;
                    } else if (element.hasAttribute('data-plat-control')) {
                        name = element.getAttribute('data-plat-control').toLowerCase();
                        injector = controlInjectors[name] || viewControlInjectors[name];
                        noControlAttribute = false;
                    }
                }

                if (!isNull(injector)) {
                    var uiControl = <ui.ITemplateControl>injector.inject(),
                        resourceElement = ElementManager.locateResources(element);

                    uiControlNode = {
                        control: uiControl,
                        resourceElement: resourceElement,
                        nodeName: name,
                        expressions: [],
                        injector: injector
                    };

                    hasUiControl = true;

                    if (noControlAttribute) {
                        element.setAttribute('plat-control', name);
                    }

                    var replacementType = uiControl.replaceWith,
                        replaceWithDiv = replacementType === 'any' && noControlAttribute;
                    if (!isEmpty(replacementType) && (replacementType !== 'any' || replaceWithDiv) &&
                            replacementType.toLowerCase() !== nodeName) {
                        if (replaceWithDiv) {
                            replacementType = 'div';
                        }

                        var replacement = ElementManager.$Document.createElement(replacementType);
                        if (replacement.nodeType === Node.ELEMENT_NODE) {
                            element = replaceWith(element, <HTMLElement>replacement.cloneNode(true));
                        }
                    }
                }

                var elementMap = ElementManager._collectAttributes(element.attributes),
                    manager = new ElementManager();

                elementMap.element = <HTMLElement>element;
                elementMap.uiControlNode = uiControlNode;

                manager.initialize(elementMap, parent);

                if (!(elementMap.hasControl || hasUiControl)) {
                    manager.bind = () => { return []; };
                } else {
                    manager.setUiControlTemplate();
                    return hasUiControl ? null : manager;
                }

                return manager;
            }
        
            /**
             * @name locateResources
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Looks through the Node's child nodes to try and find any 
             * defined {@link plat.ui.IResources|IResources} in a <plat-resources> tags.
             * 
             * @param {Node} node The node whose child nodes may contain {@link plat.ui.IResources|IResources}.
             * 
             * @returns {HTMLElement} The HTML element that represents the defined {@link plat.ui.IResources|IResources}.
             */
            static locateResources(node: Node): HTMLElement {
                var childNodes: Array<Node> = Array.prototype.slice.call(node.childNodes),
                    childNode: Node;

                while (childNodes.length > 0) {
                    childNode = childNodes.shift();

                    if (childNode.nodeName.toLowerCase() === 'plat-resources') {
                        return <HTMLElement>node.removeChild(childNode);
                    }
                }

                return null;
            }
        
            /**
             * @name clone
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clones an {@link plat.processing.IElementManager|IElementManager} with a new element.
             * 
             * @param {plat.processing.IElementManager} sourceManager The original {@link plat.processing.IElementManager|IElementManager}.
             * @param {plat.processing.IElementManager} parent The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the new clone.
             * @param {Element} element The new element to associate with the clone.
             * @param {plat.ui.ITemplateControl} newControl? An optional control to associate with the clone.
             * @param {plat.processing.INodeMap} nodeMap? The {@link plat.processing.INodeMap} used to clone this 
             * {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.processing.IElementManager} The cloned {@link plat.processing.IElementManager|IElementManager}.
             */
            static clone(sourceManager: IElementManager, parent: IElementManager,
                element: Element, newControl?: ui.ITemplateControl, nodeMap?: INodeMap): IElementManager {

                if (isNull(nodeMap)) {
                    nodeMap = ElementManager._cloneNodeMap(sourceManager.nodeMap, element, parent.getUiControl() ||
                        parent.getParentControl(), newControl);
                }

                var manager = new ElementManager(),
                    hasNewControl = !isNull(newControl);

                manager.nodeMap = nodeMap;
                manager.parent = parent;

                if (!isNull(parent)) {
                    parent.children.push(manager);
                }

                manager.replace = sourceManager.replace;
                manager.replaceNodeLength = sourceManager.replaceNodeLength;
                manager.hasOwnContext = sourceManager.hasOwnContext;
                manager.isClone = true;

                if (!(nodeMap.hasControl || hasNewControl)) {
                    manager.bind = () => { return []; };
                }

                if (hasNewControl) {
                    ElementManager.$ManagerCache.put(newControl.uid, manager);
                }

                return manager;
            }
        
            /**
             * @name cloneUiControl
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clones an {@link plat.ui.ITemplateControl|ITemplateControl} with a new {@link plat.processing.INodeMap|INodeMap}.
             * 
             * @param {plat.processing.INodeMap} sourceMap The source {@link plat.processing.INodeMap|INodeMap} used to clone the 
             * {@link plat.ui.ITemplateControl|ITemplateControl}.
             * @param {plat.ui.ITemplateControl} parent The parent control of the clone.
             * 
             * @returns {plat.ui.ITemplateControl} The cloned {@link plat.ui.ITemplateControl|ITemplateControl}.
             */
            static cloneUiControl(sourceMap: INodeMap, parent: ui.ITemplateControl): ui.ITemplateControl {
                var uiControlNode = sourceMap.uiControlNode;

                if (isNull(uiControlNode) || isNull(uiControlNode.injector)) {
                    return;
                }

                var uiControl = uiControlNode.control,
                    newUiControl = <ui.ITemplateControl>uiControlNode.injector.inject(),
                    resources = ElementManager.$ResourcesFactory.getInstance(),
                    attributes: ui.IAttributesInstance = acquire(__AttributesInstance);

                newUiControl.parent = parent;
                parent.controls.push(newUiControl);
                newUiControl.controls = [];

                attributes.initialize(newUiControl, sourceMap.attributes);
                newUiControl.attributes = attributes;

                resources.initialize(newUiControl, uiControl.resources);
                newUiControl.resources = resources;

                ElementManager.$ResourcesFactory.addControlResources(newUiControl);

                if (!isNull(uiControl.innerTemplate)) {
                    newUiControl.innerTemplate = <DocumentFragment>uiControl.innerTemplate.cloneNode(true);
                }

                newUiControl.type = uiControl.type;
                newUiControl.bindableTemplates = ElementManager.$BindableTemplatesFactory.create(newUiControl, uiControl.bindableTemplates);
                newUiControl.replaceWith = uiControl.replaceWith;

                return newUiControl;
            }
        
            /**
             * @name createAttributeControls
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates new {@link plat.processing.INode|INodes} corresponding to the element 
             * associated with the {@link plat.processing.INodeMap|INodeMap} or the passed-in element.
             * 
             * @param {plat.processing.INodeMap} nodeMap The {@link plat.processing.INodeMap|INodeMap} that contains 
             * the attribute nodes.
             * @param {plat.ui.ITemplateControl} parent The parent {@link plat.ui.ITemplateControl|ITemplateControl} for 
             * the newly created controls.
             * @param {plat.ui.ITemplateControl} templateControl? The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * linked to these created controls if one exists.
             * @param {Element} newElement? An optional element to use for attributes (used in cloning).
             * @param {boolean} isClone? Whether or not these controls are clones.
             * 
             * @returns {Array<plat.processing.INode>} An array of the newly created {@link plat.processing.INode|INodes}.
             */
            static createAttributeControls(nodeMap: INodeMap, parent: ui.ITemplateControl,
                templateControl?: ui.ITemplateControl, newElement?: Element, isClone?: boolean): Array<INode> {
                var nodes = nodeMap.nodes,
                    element = isClone === true ? newElement : nodeMap.element,
                    attributes: NamedNodeMap;

                if (isNode(element)) {
                    if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                        return isClone === true ? ElementManager._copyAttributeNodes(nodes) : [];
                    }

                    attributes = element.attributes;
                }

                var attrs = nodeMap.attributes,
                    newAttributes: ui.IAttributesInstance,
                    node: INode,
                    injector: dependency.IInjector<IControl>,
                    control: controls.IAttributeControl,
                    newNodes: Array<INode> = [],
                    length = nodes.length,
                    nodeName: string,
                    i: number;

                for (i = 0; i < length; ++i) {
                    node = nodes[i];
                    nodeName = node.nodeName;
                    injector = node.injector;
                    control = null;

                    if (!isNull(injector)) {
                        control = <controls.IAttributeControl>injector.inject();
                        node.control = control;
                        control.parent = parent;
                        control.element = <HTMLElement>element;

                        newAttributes = acquire(__AttributesInstance);
                        newAttributes.initialize(control, attrs);
                        control.attributes = newAttributes;

                        control.type = nodeName;

                        if (!isString(control.uid)) {
                            control.uid = uniqueId('plat_');
                        }

                        control.templateControl = templateControl;
                    }

                    if (isClone === true) {
                        newNodes.push({
                            control: control,
                            expressions: node.expressions,
                            identifiers: node.identifiers,
                            node: !attributes ? null : (attributes.getNamedItem(nodeName) || attributes.getNamedItem('data-' + nodeName)),
                            nodeName: nodeName,
                            injector: injector
                        });

                        if (!isNull(control)) {
                            if (!isNull(parent)) {
                                parent.controls.push(control);
                            }

                            if (isFunction(control.initialize)) {
                                control.initialize();
                            }
                        }
                    }
                }

                if (!isClone) {
                    nodes.sort((a, b) => {
                        var aControl = <controls.IAttributeControl>a.control,
                            bControl = <controls.IAttributeControl>b.control;

                        if (isNull(aControl)) {
                            return 1;
                        } else if (isNull(bControl)) {
                            return -1;
                        }

                        var aPriority = isNumber(aControl.priority) ? aControl.priority : 0,
                            bPriority = isNumber(bControl.priority) ? bControl.priority : 0;

                        return bPriority - aPriority;
                    });

                    for (i = 0; i < length; ++i) {
                        node = nodes[i];
                        control = <controls.IAttributeControl>node.control;

                        if (!isNull(control)) {
                            if (!isNull(parent)) {
                                parent.controls.push(control);
                            }

                            if (isFunction(control.initialize)) {
                                control.initialize();
                            }
                        }
                    }
                }

                return newNodes;
            }
        
            /**
             * @name getInstance
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of an {@link plat.processing.ElementManager|ElementManager}.
             * 
             * @returns {plat.processing.IElementManager}
             */
            static getInstance(): IElementManager {
                return new ElementManager();
            }
        
            /**
             * @name _collectAttributes
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Iterates over the attributes (NamedNodeMap), creating an {@link plat.processing.INodeMap|INodeMap}. 
             * This map will contain injectors for all the {@link plat.IControls|IControls} as well as parsed expressions 
             * and identifiers found for each Attribute (useful for data binding).
             * 
             * @param {NamedNodeMap} attributes The attributes used to create the {@link plat.processing.INodeMap|INodeMap}.
             * 
             * @returns {plat.processing.INodeMap} The compiled {@link plat.processing.INodeMap|INodeMap}.
             */
            static _collectAttributes(attributes: NamedNodeMap): INodeMap {
                var nodes: Array<INode> = [],
                    attribute: Attr,
                    name: string,
                    value: string,
                    childContext: expressions.IParsedExpression,
                    childIdentifier: string,
                    hasMarkup: boolean,
                    hasMarkupFn = NodeManager.hasMarkup,
                    findMarkup = NodeManager.findMarkup,
                    findUniqueIdentifiers = NodeManager.findUniqueIdentifiers,
                    $parser = NodeManager.$Parser,
                    build = NodeManager.build,
                    expressions: Array<expressions.IParsedExpression>,
                    hasControl = false,
                    injector: dependency.IInjector<IControl>,
                    length = attributes.length,
                    controlAttributes: IObject<string> = {},
                    uniqueIdentifiers: Array<string>;

                for (var i = 0; i < length; ++i) {
                    attribute = attributes[i];
                    value = attribute.value;
                    name = attribute.name.replace(/^data-/i, '').toLowerCase();
                    injector = controlInjectors[name] || viewControlInjectors[name];
                    expressions = [];
                    uniqueIdentifiers = [];

                    if (name === 'plat-context') {
                        if (value !== '') {
                            childContext = $parser.parse(value);
                            if (childContext.identifiers.length !== 1) {
                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                                $exception.warn('Incorrect plat-context: ' +
                                    value + ', must contain a single identifier.', $exception.COMPILE);
                            }
                            childIdentifier = childContext.identifiers[0];
                        }
                    } else if (name !== 'plat-control') {
                        hasMarkup = hasMarkupFn(value);

                        if (hasMarkup) {
                            expressions = findMarkup(value);
                            uniqueIdentifiers = findUniqueIdentifiers(expressions);
                            if (uniqueIdentifiers.length === 0) {
                                attribute.value = value = build(expressions);
                            }
                        }

                        if (!hasControl && (hasMarkup || !isNull(injector))) {
                            hasControl = true;
                        }

                        nodes.push({
                            control: null,
                            node: attribute,
                            nodeName: name,
                            expressions: expressions,
                            identifiers: uniqueIdentifiers,
                            injector: injector
                        });
                    }

                    controlAttributes[camelCase(name)] = value;
                }

                return {
                    element: null,
                    attributes: controlAttributes,
                    nodes: nodes,
                    childContext: childIdentifier,
                    hasControl: hasControl
                };
            }
        
            /**
             * @name _copyAttributeNodes
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Used to copy the attribute nodes during the cloning process.
             * 
             * @param {Array<plat.processing.INode>} nodes The compiled {@link plat.processing.INode|INodes} 
             * to be cloned.
             * 
             * @returns {Array<plat.processing.INode>} The cloned array of {@link plat.processing.INode|INodes}.
             */
            static _copyAttributeNodes(nodes: Array<INode>): Array<INode> {
                var newNodes: Array<INode> = [],
                    length = nodes.length,
                    node: INode;

                for (var i = 0; i < length; ++i) {
                    node = nodes[i];
                    newNodes.push({
                        identifiers: node.identifiers,
                        expressions: node.expressions,
                        nodeName: node.nodeName
                    });
                }

                return newNodes;
            }
        
            /**
             * @name _cloneNode
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Clones an {@link plat.processing.INode|INode} with a new node.
             * 
             * @param {plat.processing.INode} sourceNode The original {@link plat.processing.INode|INode}.
             * @param {Node} node The new node used for cloning.
             * @param {plat.ui.ITemplateControl} newControl? An optional new control to associate with the cloned node.
             * 
             * @returns {plat.processing.INode} The cloned {@link plat.processing.INode|INode}.
             */
            static _cloneNode(sourceNode: INode, node: Node, newControl?: ui.ITemplateControl): INode {
                return {
                    control: newControl,
                    injector: sourceNode.injector,
                    identifiers: sourceNode.identifiers,
                    expressions: sourceNode.expressions,
                    node: node,
                    nodeName: sourceNode.nodeName
                };
            }
        
            /**
             * @name _cloneNodeMap
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Clones an {@link plat.processing.INodeMap|INodeMap} with a new element.
             * 
             * @param {plat.processing.INodeMap} sourceMap The original {@link plat.processing.INodeMap|INodeMap}.
             * @param {Element} element The new Element used for cloning.
             * @param {plat.ui.ITemplateControl} parent The {@link plat.ui.ITemplateControl|ITemplateControl} associated 
             * with the parent {@link plat.processing.IElementManager|IElementManager}. 
             * @param {plat.ui.ITemplateControl} newControl? An optional new {@link plat.ui.ITemplateControl|ITemplateControl} 
             * to associate with the element.
             * 
             * @returns {plat.processing.INodeMap} The cloned {@link plat.processing.INodeMap|INodeMap}.
             */
            static _cloneNodeMap(sourceMap: INodeMap, element: Element,
                parent: ui.ITemplateControl, newControl?: ui.ITemplateControl): INodeMap {
                var hasControl = sourceMap.hasControl,
                    nodeMap: INodeMap = {
                        attributes: sourceMap.attributes,
                        childContext: sourceMap.childContext,
                        nodes: [],
                        element: <HTMLElement>element,
                        uiControlNode: !isNull(sourceMap.uiControlNode) ?
                        <IUiControlNode>ElementManager._cloneNode(sourceMap.uiControlNode, element, newControl) : null,
                        hasControl: hasControl
                    };

                if (hasControl) {
                    nodeMap.nodes = ElementManager.createAttributeControls(sourceMap, parent, newControl, element, true);
                }

                return nodeMap;
            }
        
            /**
             * @name $Promise
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.async.IPromise}
             * 
             * @description
             * Reference to the {@link plat.async.IPromise|IPromise} injectable.
             */
            $Promise: async.IPromise = acquire(__Promise);
            /**
             * @name $Compiler
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.processing.ICompiler}
             * 
             * @description
             * Reference to the {@link plat.processing.ICompiler|ICompiler} injectable.
             */
            $Compiler: ICompiler = acquire(__Compiler);
            /**
             * @name $ContextManagerStatic
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.observable.IContextManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
             */
            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);
            /**
             * @name $CommentManagerFactory
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.processing.ICommentManagerFactory}
             * 
             * @description
             * Reference to the {@link plat.processing.ICommentManagerFactory|ICommentManagerFactory} injectable.
             */
            $CommentManagerFactory: ICommentManagerFactory = acquire(__CommentManagerFactory);
            /**
             * @name $ControlFactory
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.IControlFactory}
             * 
             * @description
             * Reference to the {@link plat.IControlFactory|IControlFactory} injectable.
             */
            $ControlFactory: IControlFactory = acquire(__ControlFactory);
            /**
             * @name $TemplateControlFactory
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.ui.ITemplateControlFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.ITemplateControlFactory|ITemplateControlFactory} injectable.
             */
            $TemplateControlFactory: ui.ITemplateControlFactory = acquire(__TemplateControlFactory);

            /**
             * @name children
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {Array<plat.processing.INodeManager>}
             * 
             * @description
             * The child managers for this manager.
             */
            children: Array<INodeManager> = [];
            /**
             * @name type
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies the type for this {@link plat.processing.INodeManager|INodeManager}. 
             * It's value is "element".
             */
            type = 'element';
            /**
             * @name replace
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Specifies whether or not this manager has a {@link plat.ui.ITemplateControl|ITemplateControl} which has a 
             * replaceWith property set to null or empty string.
             */
            replace = false;
            /**
             * @name hasOwnContext
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Indicates whether the {@link plat.ui.ITemplateControl|ITemplateControl} for this manager has its own context 
             * or inherits it from a parent.
             */
            hasOwnContext = false;
            /**
             * @name replaceNodeLength
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The length of a replaced control, indicates the number of nodes to slice 
             * out of the parent's childNodes.
             */
            replaceNodeLength: number;
            /**
             * @name loadedPromise
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.async.IThenable<void>}
             * 
             * @description
             * In the event that a control has its own context, we need a promise to fullfill 
             * when the control is loaded to avoid loading its parent control first.
             */
            loadedPromise: async.IThenable<void>;
            /**
             * @name templatePromise
             * @memberof plat.processing.ElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.async.IThenable<void>}
             * 
             * @description
             * A promise that is set when an {@link plat.ui.ITemplateControl|ITemplateControl} specifies a templateUrl 
             * and its HTML needs to be asynchronously obtained.
             */
            templatePromise: async.IThenable<void>;
        
            /**
             * @name clone
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Clones the {@link plat.processing.IElementManager|IElementManager} with a new node.
             * 
             * @param {Node} newNode The new element used to clone the ElementManager.
             * @param {plat.processing.IElementManager} parentManager The parent manager for the clone.
             * @param {plat.processing.INodeMap} nodeMap? An optional INodeMap to clone a ui control if needed.
             * 
             * @returns {number} The number of nodes to advance while node traversal is in progress.
             */
            clone(newNode: Node, parentManager: IElementManager, nodeMap?: INodeMap): number {
                var childNodes: Array<Node>,
                    clonedManager: IElementManager,
                    replace = this.replace,
                    children = this.children,
                    newControl = !isNull(nodeMap) ? nodeMap.uiControlNode.control : null,
                    newControlExists = !isNull(newControl),
                    startNodeManager: INodeManager,
                    endNodeManager: INodeManager;

                if (!newControlExists) {
                    // create new control
                    newControl = ElementManager.cloneUiControl(this.nodeMap,
                        (parentManager.getUiControl() || parentManager.getParentControl()));

                    newControlExists = !isNull(newControl);
                }

                if (replace) {
                    // definitely have newControl
                    var nodes = newNode.parentNode.childNodes,
                        arrayProto = Array.prototype,
                        startIndex = arrayProto.indexOf.call(nodes, newNode);

                    childNodes = arrayProto.slice.call(nodes, startIndex + 1, startIndex + this.replaceNodeLength);
                    clonedManager = ElementManager.clone(this, parentManager, null, newControl, nodeMap);
                    newControl.elementNodes = childNodes;
                    newControl.startNode = newNode;
                    newControl.endNode = childNodes.pop();

                    startNodeManager = children.shift();
                    endNodeManager = children.shift();

                    startNodeManager.clone(newControl.startNode, clonedManager);
                    endNodeManager.clone(newControl.endNode, clonedManager);

                    if (isFunction(newControl.initialize)) {
                        newControl.initialize();
                    }
                } else {
                    childNodes = Array.prototype.slice.call(newNode.childNodes);
                    clonedManager = ElementManager.clone(this, parentManager, <Element>newNode, newControl, nodeMap);
                    nodeMap = clonedManager.nodeMap;

                    if (newControlExists) {
                        newControl.element = <HTMLElement>newNode;
                        if (isFunction(newControl.initialize)) {
                            newControl.initialize();
                        }
                    }
                }

                if (clonedManager.hasOwnContext) {
                    postpone(() => {
                        clonedManager.observeRootContext(newControl, clonedManager.bindAndLoad);
                    });
                }

                var length = children.length,
                    childNodeOffset = 0;

                for (var i = 0; i < length; ++i) {
                    // clone children
                    childNodeOffset += children[i].clone(childNodes[childNodeOffset], clonedManager);
                }

                if (replace) {
                    children.unshift(endNodeManager);
                    children.unshift(startNodeManager);

                    return childNodeOffset + 2;
                }

                return 1;
            }
        
            /**
             * @name initialize
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Initializes both the manager itself and all the controls associated to the manager's 
             * {@link plat.processing.NodeMap|NodeMap}.
             * 
             * @param {plat.processing.INodeMap} nodeMap A map of the nodes (element and attributes) 
             * associated with this {@link plat.processing.IElementManager|IElementManager}.
             * @param {plat.processing.IElementManager} parent The parent 
             * {@link plat.processing.IElementManager|IElementManager}.
             * @param {boolean} dontInitialize? Specifies whether or not the initialize method should 
             * be called for a {@link plat.ui.ITemplateControl|ITemplateControl} if one is attached 
             * to this {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {void}
             */
            initialize(nodeMap: INodeMap, parent: IElementManager, dontInitialize?: boolean): void {
                super.initialize(nodeMap, parent);

                var controlNode = nodeMap.uiControlNode,
                    hasUiControl = !isNull(controlNode),
                    control: ui.ITemplateControl;

                if (hasUiControl) {
                    this._populateUiControl();
                    control = controlNode.control;
                    this.hasOwnContext = control.hasOwnContext;
                }

                if (nodeMap.hasControl) {
                    ElementManager.createAttributeControls(nodeMap, this.getParentControl(), control);
                }

                if (!dontInitialize && hasUiControl && isFunction(control.initialize)) {
                    control.initialize();
                }
            }
        
            /**
             * @name bind
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Links the data context to the DOM (data-binding).
             * 
             * @returns {Array<plat.IControl>} An array of the controls contained within this 
             * {@link plat.processing.IElementManager|IElementManager's} associated 
             * {@link plat.processing.INodeMap|INodeMap}.
             */
            bind(): Array<IControl> {
                var nodeMap = this.nodeMap,
                    parent = this.getParentControl(),
                    controlNode = nodeMap.uiControlNode,
                    controls: Array<IControl> = [];

                if (!isNull(controlNode)) {
                    var uiControl = controlNode.control,
                        childContext = nodeMap.childContext,
                        getManager = this.$ContextManagerStatic.getManager,
                        contextManager: observable.IContextManager,
                        absoluteContextPath = isNull(parent) ? 'context' : parent.absoluteContextPath,
                        $TemplateControlFactory = this.$TemplateControlFactory,
                        inheritsContext = !uiControl.hasOwnContext;

                    controls.push(uiControl);

                    if (inheritsContext && !isNull(childContext)) {
                        if (childContext[0] === '@') {
                            var split = childContext.split('.'),
                                alias = split.shift().slice(1),
                                resourceObj = $TemplateControlFactory.findResource(uiControl, alias),
                                $exception: IExceptionStatic;

                            if (isObject(resourceObj)) {
                                var resource = resourceObj.resource;
                                if (isObject(resource) && resource.type === 'observable') {
                                    absoluteContextPath = 'resources.' + alias + '.value' + (split.length > 0 ? ('.' + split.join('.')) : '');
                                    uiControl.root = resourceObj.control;
                                } else {
                                    $exception = acquire(__ExceptionStatic);
                                    $exception.warn('Only resources of type "observable" can be set as context.',
                                        $exception.CONTEXT);
                                }
                            } else {
                                $exception = acquire(__ExceptionStatic);
                                $exception.warn('Could not set the context of ' + uiControl.type +
                                    ' with the resource specified as "' + childContext + '".',
                                    $exception.CONTEXT);
                            }
                        } else {
                            absoluteContextPath += '.' + childContext;
                        }
                    }

                    uiControl.root = this.$ControlFactory.getRootControl(uiControl) || uiControl;

                    contextManager = getManager(uiControl.root);

                    if (inheritsContext) {
                        uiControl.context = contextManager.getContext(absoluteContextPath.split('.'));
                    } else {
                        absoluteContextPath = 'context';
                    }

                    (<any>uiControl).zCC__plat = contextManager.observe(absoluteContextPath, {
                        uid: uiControl.uid,
                        listener: (newValue, oldValue) => {
                            uiControl.context = newValue;
                        }
                    });

                    $TemplateControlFactory.setAbsoluteContextPath(uiControl, absoluteContextPath);
                    $TemplateControlFactory.setContextResources(uiControl);
                    ElementManager.$ResourcesFactory.bindResources(uiControl.resources);

                    if (!this.replace) {
                        var element = uiControl.element;
                        if (!isNull(element) && isFunction(element.removeAttribute)) {
                            element.removeAttribute(__Hide);
                        }
                    }
                }

                this._observeControlIdentifiers(nodeMap.nodes, parent, controls);

                return controls;
            }
        
            /**
             * @name setUiControlTemplate
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Sets the template for an manager by obtaining any needed HTML templates and 
             * calling its associated {@link plat.ui.ITemplateControl|ITemplateControl's} 
             * setTemplate method.
             * 
             * @param {string} templateUrl? The URL for the associated {@link plat.ui.ITemplateControl|ITemplateControl's} 
             * HTML template.
             * 
             * @returns {void}
             */
            setUiControlTemplate(templateUrl?: string): void {
                var controlNode = this.nodeMap.uiControlNode;

                if (!isNull(controlNode)) {
                    var control = controlNode.control;

                    this.templatePromise = this.$TemplateControlFactory.determineTemplate(control, templateUrl).then((template) => {
                        this.templatePromise = null;
                        this._initializeControl(control, <DocumentFragment>template.cloneNode(true));
                    }, (error) => {
                        this.templatePromise = null;
                        if (isNull(error)) {
                            this._initializeControl(control, error);
                        } else {
                            postpone(() => {
                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                                $exception.fatal(error, $exception.COMPILE);
                            });
                        }
                    });

                    return;
                }

                if (!isNull(this.parent)) {
                    return;
                }

                this.bindAndLoad();
            }
        
            /**
             * @name getUiControl
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Retrieves the {@link plat.ui.ITemplateControl|ITemplateControl} instance 
             * associated with this {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.ui.ITemplateControl} The {@link plat.ui.ITemplateControl|ITemplateControl} instance 
             * associated with this {@link plat.processing.IElementManager|IElementManager}.
             */
            getUiControl(): ui.ITemplateControl {
                var uiControlNode = this.nodeMap.uiControlNode;
                if (isNull(uiControlNode)) {
                    return;
                }

                return uiControlNode.control;
            }
        
            /**
             * @name fulfillTemplate
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Fullfills any template promises and finishes the compile phase for the HTML template associated 
             * with this {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.async.IThenable<void>} A promise that resolves when this manager's template and all 
             * child manager's templates have been fulfilled.
             */
            fulfillTemplate(): async.IThenable<void> {
                if (!isNull(this.templatePromise)) {
                    return this.templatePromise.then(() => {
                        return this._fulfillChildTemplates();
                    });
                }

                return this._fulfillChildTemplates();
            }
        
            /**
             * @name bindAndLoad
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Binds context to the DOM and loads controls.
             * 
             * @returns {plat.async.IThenable<void>} A promise that resolves when this manager's controls and all 
             * child manager's controls have been bound and loaded.
             */
            bindAndLoad(): async.IThenable<void> {
                var children = this.children,
                    length = children.length,
                    child: IElementManager,
                    promises: Array<async.IThenable<void>> = [],
                    controls = this.bind();

                for (var i = 0; i < length; ++i) {
                    child = <IElementManager>children[i];

                    if (child.hasOwnContext) {
                        promises.push(child.loadedPromise);
                    } else if (!isUndefined(child.children)) {
                        promises.push(child.bindAndLoad());
                    } else {
                        child.bind();
                    }
                }

                return this.$Promise.all(promises).then(() => {
                    this._loadControls(<Array<controls.IAttributeControl>>controls, this.getUiControl());
                }).catch((error: any) => {
                    postpone(() => {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.fatal(error, $exception.BIND);
                    });
                });
            }
        
            /**
             * @name observeRootContext
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Observes the root context for controls that specify their own context, and initiates 
             * a load upon a successful set of the context.
             * 
             * @param {plat.ui.ITemplateControl} root The {@link plat.ui.ITemplateControl|ITemplateControl} specifying its own context.
             * @param {() => async.IThenable<void>} loadMethod The function to initiate the loading of the root control and its 
             * children.
             * 
             * @returns {void}
             */
            observeRootContext(root: ui.ITemplateControl, loadMethod: () => async.IThenable<void>): void {
                if (!isNull(root.context)) {
                    this.loadedPromise = loadMethod.call(this);
                    return;
                }

                this.loadedPromise = new this.$Promise<void>((resolve) => {
                    var removeListener = this.$ContextManagerStatic.getManager(root).observe('context', {
                        listener: () => {
                            removeListener();
                            loadMethod.call(this).then(resolve);
                        },
                        uid: root.uid
                    });
                }).catch((error) => {
                    postpone(() => {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.fatal(error, $exception.BIND);
                    });
                });
            }
        
            /**
             * @name _observeControlIdentifiers
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * Observes the identifiers associated with this manager's {@link plat.processing.INode|INodes}.
             * 
             * @param {Array<plat.processing.INode>} nodes The array of {@link plat.processing.INode|INodes} to iterate through.
             * @param {plat.ui.ITemplateControl} parent The parent {@link plat.ui.ITemplateControl|ITemplateControl} for context.
             * @param {Array<plat.IControl>} controls The array of controls whose attributes will need to be updated 
             * upon the context changing.
             * 
             * @returns {void}
             */
            _observeControlIdentifiers(nodes: Array<INode>, parent: ui.ITemplateControl, controls: Array<IControl>): void {
                var length = nodes.length,
                    bindings: Array<INode> = [],
                    attributeChanged = this._attributeChanged,
                    hasParent = !isNull(parent),
                    node: INode,
                    control: IControl,
                    i = 0;

                for (; i < length; ++i) {
                    node = nodes[i];
                    control = node.control;

                    if (hasParent && node.identifiers.length > 0) {
                        NodeManager.observeIdentifiers(node.identifiers, parent,
                            attributeChanged.bind(this, node, parent, controls));
                        bindings.push(node);
                    }

                    if (!isNull(control)) {
                        controls.push(control);
                    }
                }

                length = bindings.length;
                for (i = 0; i < length; ++i) {
                    this._attributeChanged(bindings[i], parent, controls);
                }
            }
        
            /**
             * @name _loadControls
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * Loads the potential attribute based controls associated with this 
             * {@link plat.processing.IElementManager|IElementManager} and 
             * attaches the corresponding {@link plat.ui.ITemplateControl|ITemplateControl} if available.
             * 
             * @param {Array<plat.controls.IAttributeControl>} controls The array of attribute based controls to load.
             * @param {plat.ui.ITemplateControl} templateControl The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * associated with this manager.
             * 
             * @returns {void}
             */
            _loadControls(controls: Array<controls.IAttributeControl>, templateControl: ui.ITemplateControl): void {
                var length = controls.length,
                    control: controls.IAttributeControl,
                    load = this.$ControlFactory.load,
                    templateControlLoaded = isNull(templateControl),
                    templateControlPriority: number,
                    i: number;

                if (templateControlLoaded) {
                    // don't need to set templateControlPriority because it will never be checked.
                    i = 0;
                } else {
                    var priority = templateControl.priority;
                    templateControlPriority = isNumber(priority) ? priority : 100;
                    i = 1;
                }

                for (; i < length; ++i) {
                    control = controls[i];
                    control.templateControl = templateControl;

                    if (!templateControlLoaded && templateControlPriority > control.priority) {
                        templateControlLoaded = true;
                        load(templateControl);
                    }

                    load(control);
                }

                if (!templateControlLoaded) {
                    load(templateControl);
                }
            }
        
            /**
             * @name _fulfillAndLoad
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * Fulfills the template promise prior to binding and loading the control.
             * 
             * @returns {plat.async.IThenable<void>} A promise that fulfills when this manager and 
             * its associated controls are bound and loaded.
             */
            _fulfillAndLoad(): async.IThenable<void> {
                return this.fulfillTemplate().then(() => {
                    return this.bindAndLoad();
                }).catch((error) => {
                    postpone(() => {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.fatal(error, $exception.BIND);
                    });
                });
            }
        
            /**
             * @name _populateUiControl
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * Populates the {@link plat.ui.ITemplateControl|ITemplateControl} properties associated with this manager  
             * if one exists.
             * 
             * @returns {void}
             */
            _populateUiControl(): void {
                var nodeMap = this.nodeMap,
                    parent = this.getParentControl(),
                    controlNode = nodeMap.uiControlNode,
                    uiControl = controlNode.control,
                    uid = uiControl.uid,
                    resources = uiControl.resources,
                    element = nodeMap.element,
                    childNodes = Array.prototype.slice.call(element.childNodes),
                    newAttributes: ui.IAttributesInstance = acquire(__AttributesInstance),
                    replace = this.replace = (uiControl.replaceWith === null || uiControl.replaceWith === '');

                if (!isString(uid)) {
                    uid = uiControl.uid = uniqueId('plat_');
                }

                ElementManager.$ManagerCache.put(uid, this);

                if (!isNull(parent) && uiControl.parent !== parent) {
                    parent.controls.push(uiControl);
                    uiControl.parent = parent;
                }

                if (isFunction(element.setAttribute)) {
                    element.setAttribute(__Hide, '');
                }

                uiControl.element = element;
                uiControl.controls = [];

                newAttributes.initialize(uiControl, nodeMap.attributes);
                uiControl.attributes = newAttributes;

                if (isObject(resources) && isFunction(resources.add)) {
                    resources.add(controlNode.resourceElement);
                } else {
                    resources = ElementManager.$ResourcesFactory.getInstance();
                    resources.initialize(uiControl, controlNode.resourceElement);
                    uiControl.resources = resources;
                }

                ElementManager.$ResourcesFactory.addControlResources(uiControl);
                uiControl.type = controlNode.nodeName;

                uiControl.bindableTemplates = uiControl.bindableTemplates ||
                    ElementManager.$BindableTemplatesFactory.create(uiControl);

                if (childNodes.length > 0 && (!isEmpty(uiControl.templateString) || !isEmpty(uiControl.templateUrl))) {
                    uiControl.innerTemplate = <DocumentFragment>appendChildren(childNodes);
                }

                if (replace) {
                    this._replaceElement(uiControl, nodeMap);
                }
            }
        
            /**
             * @name _replaceElement
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * Removes the {@link plat.ui.ITemplateControl|ITemplateControl's} element. Called if its replaceWith property is 
             * null or empty string.
             * 
             * @param {plat.ui.ITemplateControl} control The {@link plat.ui.ITemplateControl|ITemplateControl} whose element 
             * will be removed.
             * @param {plat.processing.INodeMap} nodeMap The {@link plat.processing.INodeMap|INodeMap} associated with this manager.
             * 
             * @returns {void}
             */
            _replaceElement(control: ui.ITemplateControl, nodeMap: INodeMap): void {
                var element = nodeMap.element,
                    parentNode = element.parentNode,
                    $document = ElementManager.$Document,
                    controlType = control.type,
                    controlUid = control.uid,
                    startNode = control.startNode = $document.createComment(controlType + ' ' + controlUid + __START_NODE),
                    endNode = control.endNode = $document.createComment(controlType + ' ' + controlUid + __END_NODE),
                    create = this.$CommentManagerFactory.create;

                create(startNode, this);
                create(endNode, this);

                parentNode.insertBefore(startNode, element);
                parentNode.insertBefore(endNode, element.nextSibling);
                control.elementNodes = replace(element);

                control.element = nodeMap.element = null;
            }
        
            /**
             * @name _initializeControl
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * Initializes a control's template and compiles the control.
             * 
             * @param {plat.ui.ITemplateControl} uiControl The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * associated with this manager.
             * @param {DocumentFragment} template The associated {@link plat.ui.ITemplateControl|ITemplateControl's} 
             * template.
             * 
             * @returns {void}
             */
            _initializeControl(uiControl: ui.ITemplateControl, template: DocumentFragment): void {
                var element = this.nodeMap.element,
                    // have to check if null since isNull checks for undefined case
                    replaceElement = this.replace,
                    endNode: Node;

                if (!isNull(template)) {
                    var resourceElement = ElementManager.locateResources(template);

                    if (!isNull(resourceElement)) {
                        uiControl.resources.add(ElementManager.$ResourcesFactory.parseElement(resourceElement));
                    }

                    if (replaceElement) {
                        endNode = uiControl.endNode;
                        uiControl.elementNodes = Array.prototype.slice.call(template.childNodes);
                        insertBefore(endNode.parentNode, template, endNode);
                    } else {
                        insertBefore(element, template, element.lastChild);
                    }
                }

                if (isFunction(uiControl.setTemplate)) {
                    uiControl.setTemplate();
                }

                if (replaceElement) {
                    this.$Compiler.compile(uiControl.elementNodes, uiControl);
                    var startNode = uiControl.startNode,
                        parentNode = startNode.parentNode,
                        childNodes: Array<Node> = Array.prototype.slice.call(parentNode.childNodes);

                    endNode = uiControl.endNode;

                    uiControl.elementNodes = childNodes.slice(childNodes.indexOf(startNode) + 1, childNodes.indexOf(endNode));
                    this.replaceNodeLength = uiControl.elementNodes.length + 2;
                } else {
                    this.$Compiler.compile(element, uiControl);
                }

                if (uiControl.hasOwnContext && !this.isClone) {
                    this.observeRootContext(uiControl, this._fulfillAndLoad);
                } else if (isNull(uiControl.parent)) {
                    this._fulfillAndLoad();
                }
            }
        
            /**
             * @name _attributeChanged
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * A function to handle updating an attribute on all controls that have it 
             * as a property upon a change in its value.
             * 
             * @param {plat.processing.INode} node The {@link plat.processing.INode|INode} where the change occurred.
             * @param {plat.ui.ITemplateControl} parent The parent {@link plat.ui.ITemplateControl|ITemplateControl} used for context.
             * @param {Array<plat.IControl>} controls The controls that have the changed attribute as a property.
             * 
             * @returns {void}
             */
            _attributeChanged(node: INode, parent: ui.ITemplateControl, controls: Array<IControl>): void {
                var length = controls.length,
                    key = camelCase(node.nodeName),
                    value = NodeManager.build(node.expressions, parent),
                    attributes: ui.Attributes,
                    oldValue: any;

                for (var i = 0; i < length; ++i) {
                    attributes = <ui.Attributes>controls[i].attributes;
                    oldValue = (<any>attributes)[key];
                    (<any>attributes)[key] = value;
                    attributes._attributeChanged(key, value, oldValue);
                }

                if (!this.replace) {
                    (<Attr>node.node).value = value;
                }
            }
        
            /**
             * @name _fulfillChildTemplates
             * @memberof plat.processing.ElementManager
             * @kind function
             * @access protected
             * 
             * @description
             * Runs through all the children of this manager and calls fulfillTemplate.
             * 
             * @returns {plat.async.IThenable<void>} A promise that fullfills when all 
             * child managers have fullfilled their templates.
             */
            _fulfillChildTemplates(): async.IThenable<void> {
                var children = this.children,
                    child: IElementManager,
                    length = children.length,
                    promises: Array<async.IThenable<void>> = [];

                for (var i = 0; i < length; ++i) {
                    child = <IElementManager>children[i];
                    if (!isUndefined(child.children)) {
                        promises.push(child.fulfillTemplate());
                    }
                }

                return this.$Promise.all(promises).catch((error) => {
                    postpone(() => {
                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                        $exception.fatal(error, $exception.COMPILE);
                    });
                });
            }
        }

        /**
         * The Type for referencing the '$ElementManagerFactory' injectable as a dependency.
         */
        export function IElementManagerFactory(
            $Document?: Document,
            $ManagerCache?: storage.ICache<IElementManager>,
            $ResourcesFactory?: ui.IResourcesFactory,
            $BindableTemplatesFactory?: ui.IBindableTemplatesFactory): IElementManagerFactory {
                ElementManager.$Document = $Document;
                ElementManager.$ManagerCache = $ManagerCache;
                ElementManager.$ResourcesFactory = $ResourcesFactory;
                ElementManager.$BindableTemplatesFactory = $BindableTemplatesFactory;
                return ElementManager;
        }

        register.injectable(__ElementManagerFactory, IElementManagerFactory, [
            __Document,
            __ManagerCache,
            __ResourcesFactory,
            __BindableTemplatesFactory
        ], __FACTORY);
    
        /**
         * @name IElementManagerFactory
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Creates and manages a class for dealing with Element nodes.
         */
        export interface IElementManagerFactory {
            /**
             * @name create
             * @memberof plat.processing.IElementManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines if the associated Element has controls that need to be instantiated or Attr nodes
             * containing text markup. If controls exist or markup is found a new 
             * {@link plat.processing.ElementManager|ElementManager} will be created,
             * else an empty {@link plat.processing.INodeManager|INodeManager} will be added to the Array of 
             * {@link plat.processing.INodeManager|INodeManagers}.
             * 
             * @param {Element} element The Element to use to identifier markup and controls.
             * @param {plat.processing.IElementManager} parent? The parent {@link plat.processing.IElementManager|IElementManager} 
             * used for context inheritance.
             * 
             * @returns {plat.processing.IElementManager}
             */
            create(element: Element, parent?: IElementManager): IElementManager;

            /**
             * @name createAttributeControls
             * @memberof plat.processing.IElementManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates new {@link plat.processing.INode|INodes} corresponding to the element 
             * associated with the {@link plat.processing.INodeMap|INodeMap} or the passed-in element.
             * 
             * @param {plat.processing.INodeMap} nodeMap The {@link plat.processing.INodeMap|INodeMap} that contains 
             * the attribute nodes.
             * @param {plat.ui.ITemplateControl} parent The parent {@link plat.ui.ITemplateControl|ITemplateControl} for 
             * the newly created controls.
             * @param {plat.ui.ITemplateControl} templateControl? The {@link plat.ui.ITemplateControl|ITemplateControl} 
             * linked to these created controls if one exists.
             * @param {Element} newElement? An optional element to use for attributes (used in cloning).
             * @param {boolean} isClone? Whether or not these controls are clones.
             * 
             * @returns {Array<plat.processing.INode>} An array of the newly created {@link plat.processing.INode|INodes}.
             */
            createAttributeControls(nodeMap: INodeMap, parent: ui.ITemplateControl,
                templateControl?: ui.ITemplateControl, newElement?: Element, isClone?: boolean): Array<INode>;

            /**
             * @name cloneUiControl
             * @memberof plat.processing.IElementManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clones an {@link plat.ui.ITemplateControl|ITemplateControl} with a new {@link plat.processing.INodeMap|INodeMap}.
             * 
             * @param {plat.processing.INodeMap} sourceMap The source {@link plat.processing.INodeMap|INodeMap} used to clone the 
             * {@link plat.ui.ITemplateControl|ITemplateControl}.
             * @param {plat.ui.ITemplateControl} parent The parent control of the clone.
             * 
             * @returns {plat.ui.ITemplateControl} The cloned {@link plat.ui.ITemplateControl|ITemplateControl}.
             */
            cloneUiControl(sourceMap: INodeMap, parent: ui.ITemplateControl): ui.ITemplateControl;

            /**
             * @name clone
             * @memberof plat.processing.IElementManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Clones an {@link plat.processing.IElementManager|IElementManager} with a new element.
             * 
             * @param {plat.processing.IElementManager} sourceManager The original {@link plat.processing.IElementManager|IElementManager}.
             * @param {plat.processing.IElementManager} parent The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the new clone.
             * @param {Element} element The new element to associate with the clone.
             * @param {plat.ui.ITemplateControl} newControl? An optional control to associate with the clone.
             * @param {plat.processing.INodeMap} nodeMap? The {@link plat.processing.INodeMap} used to clone this 
             * {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.processing.IElementManager} The cloned {@link plat.processing.IElementManager|IElementManager}.
             */
            clone(sourceManager: IElementManager, parent: IElementManager,
                element: Element, newControl?: ui.ITemplateControl, nodeMap?: INodeMap): IElementManager;

            /**
             * @name locateResources
             * @memberof plat.processing.IElementManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Looks through the Node's child nodes to try and find any 
             * defined {@link plat.ui.IResources|IResources} in a <plat-resources> tags.
             * 
             * @param {Node} node The node whose child nodes may contain {@link plat.ui.IResources|IResources}.
             * 
             * @returns {HTMLElement} The HTML element that represents the defined {@link plat.ui.IResources|IResources}.
             */
            locateResources(node: Node): HTMLElement;

            /**
             * @name getInstance
             * @memberof plat.processing.IElementManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Returns a new instance of an {@link plat.processing.ElementManager|ElementManager}.
             * 
             * @returns {plat.processing.IElementManager}
             */
            getInstance(): IElementManager;
        }
    
        /**
         * @name IElementManager
         * @memberof plat.processing
         * @kind interface
         * 
         * @extends {plat.processing.INodeManager}
         * 
         * @description
         * Responsible for initializing and data-binding controls associated to an Element.
         */
        export interface IElementManager extends INodeManager {
            /**
             * @name children
             * @memberof plat.processing.IElementManager
             * @kind property
             * @access public
             * 
             * @type {Array<plat.processing.INodeManager>}
             * 
             * @description
             * The child managers for this manager.
             */
            children: Array<INodeManager>;

            /**
             * @name replace
             * @memberof plat.processing.IElementManager
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Specifies whether or not this manager has a {@link plat.ui.ITemplateControl|ITemplateControl} which has a 
             * replaceWith property set to null or empty string.
             */
            replace: boolean;

            /**
             * @name replaceNodeLength
             * @memberof plat.processing.IElementManager
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * The length of a replaced control, indicates the number of nodes to slice 
             * out of the parent's childNodes.
             */
            replaceNodeLength: number;

            /**
             * @name hasOwnContext
             * @memberof plat.processing.IElementManager
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Indicates whether the {@link plat.ui.ITemplateControl|ITemplateControl} for this manager has its own context 
             * or inherits it from a parent.
             */
            hasOwnContext: boolean;
        
            /**
             * @name isClone
             * @memberof plat.processing.IElementManager
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Lets us know when an {@link plat.processing.IElementManager|IElementManager} is a cloned manager, or the compiled 
             * manager from {@link plat.ui.IBindableTemplates|IBindableTemplates}. We do not want to bind and load compiled 
             * managers that are clones.
             */
            isClone: boolean;

            /**
             * @name loadedPromise
             * @memberof plat.processing.IElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.async.IThenable<void>}
             * 
             * @description
             * In the event that a control has its own context, we need a promise to fullfill 
             * when the control is loaded to avoid loading its parent control first.
             */
            loadedPromise: async.IThenable<void>;

            /**
             * @name templatePromise
             * @memberof plat.processing.IElementManager
             * @kind property
             * @access public
             * 
             * @type {plat.async.IThenable<void>}
             * 
             * @description
             * A promise that is set when an {@link plat.ui.ITemplateControl|ITemplateControl} specifies a templateUrl 
             * and its HTML needs to be asynchronously obtained.
             */
            templatePromise: async.IThenable<void>;

            /**
             * @name clone
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Clones the {@link plat.processing.IElementManager|IElementManager} with a new node.
             * 
             * @param {Node} newNode The new element used to clone the ElementManager.
             * @param {plat.processing.IElementManager} parentManager The parent manager for the clone.
             * @param {plat.processing.INodeMap} nodeMap? An optional INodeMap to clone a ui control if needed.
             * 
             * @returns {number} The number of nodes to advance while node traversal is in progress.
             */
            clone(newNode: Node, parentManager: IElementManager, nodeMap?: INodeMap): number;

            /**
             * @name initialize
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Initializes both the manager itself and all the controls associated to the manager's 
             * {@link plat.processing.NodeMap|NodeMap}.
             * 
             * @param {plat.processing.INodeMap} nodeMap A map of the nodes (element and attributes) 
             * associated with this {@link plat.processing.IElementManager|IElementManager}.
             * @param {plat.processing.IElementManager} parent The parent 
             * {@link plat.processing.IElementManager|IElementManager}.
             * @param {boolean} dontInitialize? Specifies whether or not the initialize method should 
             * be called for a {@link plat.ui.ITemplateControl|ITemplateControl} if one is attached 
             * to this {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {void}
             */
            initialize(nodeMap: INodeMap, parent: IElementManager, dontInitialize?: boolean): void;

            /**
             * @name bind
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Links the data context to the DOM (data-binding).
             * 
             * @returns {Array<plat.IControl>} An array of the controls contained within this 
             * {@link plat.processing.IElementManager|IElementManager's} associated 
             * {@link plat.processing.INodeMap|INodeMap}.
             */
            bind(): void;

            /**
             * @name setUiControlTemplate
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Sets the template for an manager by obtaining any needed HTML templates and 
             * calling its associated {@link plat.ui.ITemplateControl|ITemplateControl's} 
             * setTemplate method.
             * 
             * @param {string} templateUrl? The URL for the associated {@link plat.ui.ITemplateControl|ITemplateControl's} 
             * HTML template.
             * 
             * @returns {void}
             */
            setUiControlTemplate(templateUrl?: string): void;

            /**
             * @name getUiControl
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Retrieves the {@link plat.ui.ITemplateControl|ITemplateControl} instance 
             * associated with this {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.ui.ITemplateControl} The {@link plat.ui.ITemplateControl|ITemplateControl} instance 
             * associated with this {@link plat.processing.IElementManager|IElementManager}.
             */
            getUiControl(): ui.ITemplateControl;

            /**
             * @name fulfillTemplate
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Fullfills any template promises and finishes the compile phase for the HTML template associated 
             * with this {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.async.IThenable<void>} A promise that resolves when this manager's template and all 
             * child manager's templates have been fulfilled.
             */
            fulfillTemplate(): async.IThenable<void>;

            /**
             * @name observeRootContext
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Observes the root context for controls that specify their own context, and initiates 
             * a load upon a successful set of the context.
             * 
             * @param {plat.ui.ITemplateControl} root The {@link plat.ui.ITemplateControl|ITemplateControl} specifying its own context.
             * @param {() => async.IThenable<void>} loadMethod The function to initiate the loading of the root control and its 
             * children.
             * 
             * @returns {void}
             */
            observeRootContext(root: ui.ITemplateControl, loadMethod: () => async.IThenable<void>): void;

            /**
             * @name bindAndLoad
             * @memberof plat.processing.IElementManager
             * @kind function
             * @access public
             * 
             * @description
             * Binds context to the DOM and loads controls.
             * 
             * @returns {plat.async.IThenable<void>} A promise that resolves when this manager's controls and all 
             * child manager's controls have been bound and loaded.
             */
            bindAndLoad(): async.IThenable<void>;
        }

        /**
         * @name TextManager
         * @memberof plat.processing
         * @kind class
         * 
         * @extends {plat.processing.NodeManager}
         * @implements {plat.processing.ITextManager}
         * 
         * @description
         * The class responsible for initializing and data-binding values to text nodes.
         */
        export class TextManager extends NodeManager implements ITextManager {
            /**
             * @name create
             * @memberof plat.processing.TextManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines if a text node has markup, and creates a {@link plat.processing.ITextManager|ITextManager} if it does. 
             * An {@link plat.processing.ITextManager|ITextManager} responsible for markup in the passed in node or an empty 
             * {@link plat.processing.ITextManager|ITextManager} if not markup is found will be added to the managers array.
             * 
             * @param {Node} node The Node used to find markup.
             * @param {plat.processing.IElementManager} parent The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the node.
             * 
             * @returns {plat.processing.TextManager} The newly created {@link plat.processing.ITextManager|ITextManager} 
             * responsible for the passed in Text Node.
             */
            static create(node: Node, parent: IElementManager): ITextManager {
                var value = node.nodeValue,
                    manager = new TextManager();

                if (NodeManager.hasMarkup(value)) {
                    var expressions = NodeManager.findMarkup(value),
                        map = {
                            nodes: [{
                                node: node,
                                expressions: expressions,
                                identifiers: NodeManager.findUniqueIdentifiers(expressions),
                            }]
                        };

                    manager.initialize(map, parent);

                    return manager;
                }

                manager.initialize(null, parent);
                manager.bind = noop;

                return manager;
            }
        
            /**
             * @name _cloneNodeMap
             * @memberof plat.processing.TextManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Clones an {@link plat.processing.INodeMap|INodeMap} with a new text node.
             * 
             * @param {plat.processing.INodeMap} sourceMap The original {@link plat.processing.INodeMap|INodeMap}.
             * @param {Node} newNode The new text node used for cloning.
             * 
             * @returns {plat.processing.INodeMap} The cloned {@link plat.processing.INodeMap|INodeMap}.
             */
            static _cloneNodeMap(sourceMap: INodeMap, newNode: Node): INodeMap {
                var node = sourceMap.nodes[0],
                    nodeMap: INodeMap = {
                        nodes: [{
                            identifiers: node.identifiers,
                            expressions: node.expressions,
                            nodeName: node.nodeName,
                            node: newNode
                        }]
                    };
                return nodeMap;
            }
        
            /**
             * @name _clone
             * @memberof plat.processing.TextManager
             * @kind function
             * @access protected
             * @static
             * 
             * @description
             * Clones a {@link plat.processing.ITextManager|ITextManager} with a new text node.
             * 
             * @param {plat.processing.INodeManager} sourceManager The original {@link plat.processing.INodeManager|INodeManager}.
             * @param {Node} node The new text node to associate with the clone.
             * @param {plat.processing.IElementManager} parent The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the new clone.
             * 
             * @returns {plat.processing.ITextManager} The cloned {@link plat.processing.ITextManager|ITextManager}.
             */
            static _clone(sourceManager: INodeManager, node: Node, parent: IElementManager): ITextManager {
                var map = sourceManager.nodeMap,
                    manager = new TextManager();

                if (!isNull(map)) {
                    manager.initialize(TextManager._cloneNodeMap(map, node), parent);
                } else {
                    manager.initialize(null, parent);
                    manager.bind = noop;
                }

                return manager;
            }
        
            /**
             * @name type
             * @memberof plat.processing.TextManager
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies the type for this {@link plat.processing.INodeManager|INodeManager}. 
             * It's value is "text".
             */
            type = 'text';
        
            /**
             * @name clone
             * @memberof plat.processing.TextManager
             * @kind function
             * @access public
             * 
             * @description
             * Clones this {@link plat.processing.ITextManager|ITextManager} with a new node.
             * 
             * @param {Node} newNode The new node attached to the cloned {@link plat.processing.ITextManager|ITextManager}.
             * @param {plat.processing.IElementManager} parentManager The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the clone.
             * 
             * @returns {number} The number of nodes to advance while node traversal is in progress (returns 1).
             */
            clone(newNode: Node, parentManager: IElementManager): number {
                TextManager._clone(this, newNode, parentManager);
                return 1;
            }
        
            /**
             * @name bind
             * @memberof plat.processing.TextManager
             * @kind function
             * @access public
             * 
             * @description
             * The function used for data-binding a data context to the DOM.
             * 
             * @returns {void}
             */
            bind(): void {
                var parent = this.getParentControl(),
                    node = this.nodeMap.nodes[0],
                    textNode = node.node,
                    expressions = node.expressions;

                NodeManager.observeIdentifiers(node.identifiers, parent,
                    this._setText.bind(this, textNode, parent, expressions));

                this._setText(textNode, parent, expressions);
            }
        
            /**
             * @name _setText
             * @memberof plat.processing.TextManager
             * @kind function
             * @access protected
             * 
             * @description
             * Builds the node expression and sets the value.
             * 
             * @param {Node} Node The associated node whose value will be set.
             * @param {plat.ui.ITemplateControl} control The control whose context will be used to bind 
             * the data.
             * @param {Array<plat.expressions.IParsedExpression>} expressions An array of parsed expressions used to build 
             * the node value.
             * 
             * @returns {void}
             */
            _setText(node: Node, control: ui.ITemplateControl, expressions: Array<expressions.IParsedExpression>): void {
                control = control || <ui.ITemplateControl>{};
                node.nodeValue = NodeManager.build(expressions, control);
            }
        }

        /**
         * The Type for referencing the '$TextManagerFactory' injectable as a dependency.
         */
        export function ITextManagerFactory(): ITextManagerFactory {
            return TextManager;
        }

        register.injectable(__TextManagerFactory, ITextManagerFactory, null, __FACTORY);
    
        /**
         * @name ITextManagerFactory
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Creates and manages a class for dealing with DOM Text Nodes.
         */
        export interface ITextManagerFactory {
            /**
             * @name create
             * @memberof plat.processing.ITextManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Determines if a text node has markup, and creates a {@link plat.processing.ITextManager|ITextManager} if it does. 
             * An {@link plat.processing.ITextManager|ITextManager} responsible for markup in the passed in node or an empty 
             * {@link plat.processing.ITextManager|ITextManager} if not markup is found will be added to the managers array.
             * 
             * @param {Node} node The Node used to find markup.
             * @param {plat.processing.IElementManager} parent The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the node.
             * 
             * @returns {plat.processing.TextManager} The newly created {@link plat.processing.ITextManager|ITextManager} 
             * responsible for the passed in Text Node.
             */
            create(node: Node, parent?: IElementManager): ITextManager;
        }
    
        /**
         * @name ITextManager
         * @memberof plat.processing
         * @kind interface
         * 
         * @extends {plat.processing.INodeManager}
         * 
         * @description
         * An object responsible for initializing and data-binding values to text nodes.
         */
        export interface ITextManager extends INodeManager {
            /**
             * @name clone
             * @memberof plat.processing.ITextManager
             * @kind function
             * @access public
             * 
             * @description
             * Clones this {@link plat.processing.ITextManager|ITextManager} with a new node.
             * 
             * @param {Node} newNode The new node attached to the cloned {@link plat.processing.ITextManager|ITextManager}.
             * @param {plat.processing.IElementManager} parentManager The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the clone.
             * 
             * @returns {number} The number of nodes to advance while traversing is in progress.
             */
            clone(newNode: Node, parentManager: IElementManager): number;
        
            /**
             * @name bind
             * @memberof plat.processing.ITextManager
             * @kind function
             * @access public
             * 
             * @description
             * The function used for data-binding a data context to the DOM.
             * 
             * @returns {void}
             */
            bind(): void;
        }

        /**
         * @name CommentManager
         * @memberof plat.processing
         * @kind class
         * 
         * @extends {plat.processing.NodeManager}
         * @implements {plat.processing.ICommentManager}
         * 
         * @description
         * A class used to manage Comment nodes. Provides a way to 
         * clone a Comment node.
         */
        export class CommentManager extends NodeManager implements ICommentManager {
            /**
             * @name create
             * @memberof plat.processing.CommentManager
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a new CommentManager for the given Comment node.
             * 
             * @param {Node} node The Comment to associate with the new manager.
             * @param {plat.processing.IElementManager} parent The parent 
             * {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.processing.ICommentManager} The newly created {@link plat.processing.ICommentManager|ICommentManager} 
             * responsible for the passed in Comment Node.
             */
            static create(node: Node, parent: IElementManager): ICommentManager {
                var manager = new CommentManager();

                manager.initialize({
                    nodes: [{
                        node: node
                    }]
                }, parent);

                return manager;
            }
        
            /**
             * @name type
             * @memberof plat.processing.CommentManager
             * @kind property
             * @access public
             * 
             * @type {string}
             * 
             * @description
             * Specifies the type for this {@link plat.processing.INodeManager|INodeManager}. 
             * It's value is "comment".
             */
            type: string = 'comment';
        
            /**
             * @name clone
             * @memberof plat.processing.CommentManager
             * @kind function
             * @access public
             * 
             * @description
             * A method for cloning this manager with a new Comment.
             * 
             * @param {Node} newNode The new Comment node to associate with the cloned
             * manager.
             * @param {plat.processing.IElementManager} parentManager The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the clone.
             * 
             * @returns {number} The number of nodes to advance while node traversal is in progress (returns 1).
             */
            clone(newNode: Node, parentManager: IElementManager): number {
                CommentManager.create(newNode, parentManager);
                return 1;
            }
        }

        /**
         * The Type for referencing the '$CommentManagerFactory' injectable as a dependency.
         */
        export function ICommentManagerFactory(): ICommentManagerFactory {
            return CommentManager;
        }

        register.injectable(__CommentManagerFactory, ICommentManagerFactory, null, __FACTORY);
    
        /**
         * @name ICommentManagerFactory
         * @memberof plat.processing
         * @kind interface
         * 
         * @description
         * Creates and manages a class for dealing with Comment nodes.
         */
        export interface ICommentManagerFactory {
            /**
             * @name create
             * @memberof plat.processing.ICommentManagerFactory
             * @kind function
             * @access public
             * @static
             * 
             * @description
             * Creates a new CommentManager for the given Comment node.
             * 
             * @param {Node} node The Comment to associate with the new manager.
             * @param {plat.processing.IElementManager} parent The parent 
             * {@link plat.processing.IElementManager|IElementManager}.
             * 
             * @returns {plat.processing.ICommentManager} The newly created {@link plat.processing.ICommentManager|ICommentManager} 
             * responsible for the passed in Comment Node.
             */
            create(node: Node, parent: IElementManager): ICommentManager;
        }
    
        /**
         * @name ICommentManager
         * @memberof plat.processing
         * @kind interface
         * 
         * @extends {plat.processing.INodeManager}
         * 
         * @description
         * An object used to manage Comment nodes.
         */
        export interface ICommentManager extends INodeManager {
            /**
             * @name clone
             * @memberof plat.processing.ICommentManager
             * @kind function
             * @access public
             * 
             * @description
             * A method for cloning this manager with a new Comment.
             * 
             * @param {Node} newNode The new Comment node to associate with the cloned
             * manager.
             * @param {plat.processing.IElementManager} parentManager The parent {@link plat.processing.IElementManager|IElementManager} 
             * for the clone.
             * 
             * @returns {number} The number of nodes to advance while node traversal is in progress.
             */
            clone(newNode: Node, parentManager: IElementManager): number;
        }
    }
    /**
     * @name navigation
     * @memberof plat
     * @kind namespace
     * @access public
     * 
     * @description
     * Holds classes and interfaces related to navigation in platypus.
     */
    export module navigation {
        /**
         * @name BaseNavigator
         * @memberof plat.navigation
         * @kind class
         * 
         * @implements {plat.navigation.IBaseNavigator}
         * 
         * @description
         * A class that defines the base navigation properties and methods.
         */
        export class BaseNavigator implements IBaseNavigator {
            /**
             * @name $EventManagerStatic
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.events.IEventManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.
             */
            $EventManagerStatic: events.IEventManagerStatic = acquire(__EventManagerStatic);
            /**
             * @name $NavigationEventStatic
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.events.INavigationEventStatic}
             * 
             * @description
             * Reference to the {@link plat.events.INavigationEventStatic|INavigationEventStatic} injectable.
             */
            $NavigationEventStatic: events.INavigationEventStatic = acquire(__NavigationEventStatic);
            /**
             * @name $BaseViewControlFactory
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IBaseViewControlFactory}
             * 
             * @description
             * Reference to the {@link plat.ui.IBaseViewControlFactory|IBaseViewControlFactory} injectable.
             */
            $BaseViewControlFactory: ui.IBaseViewControlFactory = acquire(__BaseViewControlFactory);
            /**
             * @name $ContextManagerStatic
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.observable.IContextManagerStatic}
             * 
             * @description
             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.
             */
            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);

            /**
             * @name uid
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * A unique ID used to identify this navigator.
             */
            uid: string;
            /**
             * @name baseport
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.ui.controls.IBaseport}
             * 
             * @description
             * Every navigator will have an {@link plat.ui.controls.IBaseport|IBaseport} with which to communicate and 
             * facilitate navigation.
             */
            baseport: ui.controls.IBaseport;
            /**
             * @name currentState
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.IBaseNavigationState}
             * 
             * @description
             * Specifies the current state of navigation. This state should contain 
             * enough information for it to be pushed onto the history stack when 
             * necessary.
             */
            currentState: IBaseNavigationState;
            /**
             * @name navigating
             * @memberof plat.navigation.BaseNavigator
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Set to true during "navigate" (i.e. while navigation is in progress), set to false during 
             * "navigated" (i.e. after a navigation has successfully occurred).
             */
            navigating: boolean;

            /**
             * @name constructor
             * @memberof plat.navigation.BaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * The constructor for a {@link plat.navigation.BaseNavigator|BaseNavigator}. 
             * Defines a unique id and subscribes to the "goBack" event.
             * 
             * @returns {plat.navigation.BaseNavigator}
             */
            constructor() {
                var uid = uniqueId('plat_');
                this.$ContextManagerStatic.defineGetter(this, 'uid', uid);
                this.$EventManagerStatic.on(uid, 'goBack', this.goBack, this);
            }
        
            /**
             * @name initialize
             * @memberof plat.navigation.BaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Initializes this navigator. The {plat.ui.controls.IBaseport|IBaseport} will call this method and pass 
             * itself in so the navigator can store it and use it to facilitate navigation.
             * 
             * @param {plat.ui.controls.IBaseport} baseport The {plat.ui.controls.IBaseport|IBaseport} 
             * associated with this {@link plat.navigation.IBaseNavigator|IBaseNavigator}.
             * 
             * @returns {void}
             */
            initialize(baseport: ui.controls.IBaseport): void {
                this.baseport = baseport;
            }
        
            /**
             * @name navigate
             * @memberof plat.navigation.BaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Allows an {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent to the new {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {any} navigationParameter? An optional navigation parameter to send to the next 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * @param {plat.navigation.IBaseNavigationOptions} options? Optional 
             * {@link plat.navigation.IBaseNavigationOptions|IBaseNavigationOptions} used for navigation.
             * 
             * @returns {void}
             */
            navigate(navigationParameter?: any, options?: IBaseNavigationOptions): void {
                this.navigating = true;
            }
        
            /**
             * @name navigated
             * @memberof plat.navigation.BaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Called by the {plat.ui.controls.IBaseport|IBaseport} to make the 
             * {@link plat.navigation.IBaseNavigator|IBaseNavigator} aware of a successful 
             * navigation. The {@link plat.navigation.IBaseNavigator|IBaseNavigator} will 
             * in-turn send the app.navigated event.
             * 
             * @param {plat.ui.IBaseViewControl} control The {@link plat.ui.IBaseViewControl|IBaseViewControl} 
             * to which the navigation occurred.
             * @param {any} parameter The navigation parameter sent to the control.
             * @param {plat.navigation.IBaseNavigationOptions} options The 
             * {@link plat.navigation.IBaseNavigationOptions|IBaseNavigationOptions} used during navigation.
             * 
             * @returns {void}
             */
            navigated(control: ui.IBaseViewControl, parameter: any, options: IBaseNavigationOptions): void {
                this.currentState = {
                    control: control
                };

                this.navigating = false;
                control.navigator = this;
                control.navigatedTo(parameter);

                this._sendEvent('navigated', control, control.type, parameter, options, false);
            }
        
            /**
             * @name goBack
             * @memberof plat.navigation.BaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Every navigator must implement this method, defining what happens when an 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} wants to go back.
             * 
             * @param {plat.navigation.IBaseBackNavigationOptions} options? Optional backwards navigation options of type 
             * {@link plat.navigation.IBaseBackNavigationOptions|IBaseBackNavigationOptions}.
             * 
             * @returns {void}
             */
            goBack(options?: IBaseBackNavigationOptions): void { }
        
            /**
             * @name dispose
             * @memberof plat.navigation.BaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Cleans up memory.
             * 
             * @returns {void}
             */
            dispose(): void { }
        
            /**
             * @name _sendEvent
             * @memberof plat.navigation.BaseNavigator
             * @kind function
             * @access protected
             * 
             * @description
             * Sends an {@link plat.events.INavigationEvent|INavigationEvent} with the given parameters. 
             * The 'sender' property of the event will be this navigator.
             * 
             * @param {string} name The name of the event to send.
             * @param {any} target The target of the event, could be an {@link plat.ui.IBaseViewControl|IBaseViewControl} 
             * or a route depending upon this navigator and event name.
             * @param {plat.navigation.IBaseNavigationOptions} options The 
             * {@link plat.navigation.IBaseNavigationOptions|IBaseNavigationOptions} used during navigation
             * @param {boolean} cancelable Whether or not the event can be cancelled, preventing further navigation.
             * 
             * @returns {plat.events.INavigationEvent<any>} The {@link plat.events.INavigationEvent|INavigationEvent} to 
             * dispatch.
             */
            _sendEvent(name: string, target: any, type: string, parameter: any,
                options: IBaseNavigationOptions, cancelable: boolean): events.INavigationEvent<any> {
                return this.$NavigationEventStatic.dispatch(name, this, {
                    target: target,
                    type: type,
                    parameter: parameter,
                    options: options,
                    cancelable: cancelable
                });
            }
        }

        /**
         * @name IBaseNavigator
         * @memberof plat.navigation
         * @kind interface
         * 
         * @description
         * Defines the methods that a type of navigator must implement.
         */
        export interface IBaseNavigator {
            /**
             * @name uid
             * @memberof plat.navigation.IBaseNavigator
             * @kind property
             * @access public
             * @readonly
             * 
             * @type {string}
             * 
             * @description
             * A unique ID used to identify this navigator.
             */
            uid: string;

            /**
             * @name baseport
             * @memberof plat.navigation.IBaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.ui.controls.IBaseport}
             * 
             * @description
             * Every navigator will have an {@link plat.ui.controls.IBaseport|IBaseport} with which to communicate and 
             * facilitate navigation.
             */
            baseport: ui.controls.IBaseport;

            /**
             * @name currentState
             * @memberof plat.navigation.IBaseNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.IBaseNavigationState}
             * 
             * @description
             * Specifies the current state of navigation. This state should contain 
             * enough information for it to be pushed onto the history stack when 
             * necessary.
             */
            currentState: IBaseNavigationState;

            /**
             * @name navigating
             * @memberof plat.navigation.IBaseNavigator
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Set to true during "navigate" (i.e. while navigation is in progress), set to false during 
             * "navigated" (i.e. after a navigation has successfully occurred).
             */
            navigating: boolean;

            /**
             * @name initialize
             * @memberof plat.navigation.IBaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Initializes this navigator. The {plat.ui.controls.IBaseport|IBaseport} will call this method and pass 
             * itself in so the navigator can store it and use it to facilitate navigation.
             * 
             * @param {plat.ui.controls.IBaseport} baseport The {plat.ui.controls.IBaseport|IBaseport} 
             * associated with this {@link plat.navigation.IBaseNavigator|IBaseNavigator}.
             * 
             * @returns {void}
             */
            initialize(baseport: ui.controls.IBaseport): void;

            /**
             * @name navigate
             * @memberof plat.navigation.IBaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Allows an {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent to the new {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {any} navigationParameter? An optional navigation parameter to send to the next 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * @param {plat.navigation.IBaseNavigationOptions} options? Optional 
             * {@link plat.navigation.IBaseNavigationOptions|IBaseNavigationOptions} used for navigation.
             * 
             * @returns {void}
             */
            navigate(navigationParameter?: any, options?: IBaseNavigationOptions): void;

            /**
             * @name navigated
             * @memberof plat.navigation.IBaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Called by the {plat.ui.controls.IBaseport|IBaseport} to make the 
             * {@link plat.navigation.IBaseNavigator|IBaseNavigator} aware of a successful 
             * navigation. The {@link plat.navigation.IBaseNavigator|IBaseNavigator} will 
             * in-turn send the app.navigated event.
             * 
             * @param {plat.ui.IBaseViewControl} control The {@link plat.ui.IBaseViewControl|IBaseViewControl} 
             * to which the navigation occurred.
             * @param {any} parameter The navigation parameter sent to the control.
             * @param {plat.navigation.IBaseNavigationOptions} options The 
             * {@link plat.navigation.IBaseNavigationOptions|IBaseNavigationOptions} used during navigation.
             * 
             * @returns {void}
             */
            navigated(control: ui.IBaseViewControl, parameter: any, options: IBaseNavigationOptions): void;

            /**
             * @name goBack
             * @memberof plat.navigation.IBaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Every navigator must implement this method, defining what happens when an 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} wants to go back.
             * 
             * @param {plat.navigation.IBaseBackNavigationOptions} options? Optional backwards navigation options of type 
             * {@link plat.navigation.IBaseBackNavigationOptions|IBaseBackNavigationOptions}.
             * 
             * @returns {void}
             */
            goBack(options?: IBaseBackNavigationOptions): void;

            /**
             * @name dispose
             * @memberof plat.navigation.IBaseNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Cleans up memory.
             * 
             * @returns {void}
             */
            dispose(): void;
        }
    
        /**
         * @name IBaseNavigationOptions
         * @memberof plat.navigation
         * @kind interface
         * 
         * @description
         * Options that you can submit to an {@link plat.navigation.IBaseNavigator|IBaseNavigator} in order 
         * to customize navigation.
         */
        export interface IBaseNavigationOptions {
            /**
             * @name replace
             * @memberof plat.navigation.IBaseNavigationOptions
             * @kind property
             * @access public
             * 
             * @type {boolean}
             * 
             * @description
             * Allows an {@link plat.ui.IBaseViewControl|IBaseViewControl} to leave itself out of the 
             * navigation history.
             */
            replace?: boolean;
        }
    
        /**
         * @name IBaseBackNavigationOptions
         * @memberof plat.navigation
         * @kind interface
         * 
         * @description
         * Options that you can submit to an {@link plat.navigation.IBaseNavigator|IBaseNavigator} during a backward
         * navigation in order to customize the navigation.
         */
        export interface IBaseBackNavigationOptions {
            /**
             * @name length
             * @memberof plat.navigation.IBaseBackNavigationOptions
             * @kind property
             * @access public
             * 
             * @type {number}
             * 
             * @description
             * Lets the {@link plat.navigation.IBaseNavigator|IBaseNavigator} know to navigate back a specific length 
             * in history.
             */
            length?: number;
        }
    
        /**
         * @name IBaseNavigationState
         * @memberof plat.navigation
         * @kind interface
         * 
         * @description
         * Defines the base interface that needs to be implemented in the navigation history.
         */
        export interface IBaseNavigationState {
            /**
             * @name control
             * @memberof plat.navigation.IBaseNavigationState
             * @kind property
             * @access public
             * 
             * @type {plat.ui.IBaseViewControl}
             * 
             * @description
             * The {@link plat.ui.IBaseViewControl|IBaseViewControl} associated with a history entry.
             */
            control: ui.IBaseViewControl;
        }

        /**
         * @name Navigator
         * @memberof plat.navigation
         * @kind class
         * 
         * @extends plat.navigation.BaseNavigator
         * @implements {plat.navigation.INavigatorInstance}
         * 
         * @description
         * Allows {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate within a 
         * {@link plat.ui.controls.Viewport|Viewport}. Every {@link plat.ui.controls.Viewport|Viewport} 
         * has its own {@link plat.navigation.Navigator|Navigator} instance, allowing multiple navigators to 
         * coexist in one app.
         */
        export class Navigator extends BaseNavigator implements INavigatorInstance {
            /**
             * @name history
             * @memberof plat.navigation.Navigator
             * @kind property
             * @access public
             * 
             * @type {Array<plat.navigation.IBaseNavigationState>}
             * 
             * @description
             * Contains the navigation history stack for the associated {@link plat.ui.controls.Viewport|Viewport}.
             */
            history: Array<IBaseNavigationState> = [];
        
            /**
             * @name navigate
             * @memberof plat.navigation.Navigator
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Allows an {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent along with the navigation.
             * 
             * @param {new (...args: any[]) => ui.IBaseViewControl} Constructor The Constructor for the new 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. This navigator will find the injector for 
             * the Constructor and create a new instance of the control.
             * @param {plat.navigation.INavigationOptions} options? Optional 
             * {@link plat.navigation.INavigationOptions|INavigationOptions} used for navigation.
             * 
             * @returns {void}
             */
            navigate(Constructor: new (...args: any[]) => ui.IBaseViewControl, options?: INavigationOptions): void;
            /**
             * @name navigate
             * @memberof plat.navigation.Navigator
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Allows an {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent along with the navigation.
             * 
             * @param {new (...args: any[]) => plat.ui.IBaseViewControl} injector The {@link plat.dependency.IInjector|IInjector} 
             * for the new {@link plat.ui.IBaseViewControl|IBaseViewControl}. This navigator will create a new instance of the control.
             * @param {plat.navigation.INavigationOptions} options? Optional 
             * {@link plat.navigation.INavigationOptions|INavigationOptions} used for navigation.
             * 
             * @returns {void}
             */
            navigate(injector: dependency.IInjector<ui.IBaseViewControl>, options?: INavigationOptions): void;
            navigate(Constructor: any, options?: INavigationOptions): void {
                options = options || <IBaseNavigationOptions>{};

                var state = this.currentState || <IBaseNavigationState>{},
                    viewControl = state.control,
                    injector: dependency.IInjector<ui.IBaseViewControl>,
                    key: string,
                    parameter = options.parameter,
                    event: events.INavigationEvent<any>,
                    baseport = this.baseport,
                    BaseViewControlFactory = this.$BaseViewControlFactory;

                event = this._sendEvent('beforeNavigate', Constructor, null, parameter, options, true);

                if (event.cancelled) {
                    return;
                }

                this.navigating = true;
                BaseViewControlFactory.detach(viewControl);

                if (isObject(parameter)) {
                    parameter = _clone(parameter, true);
                }

                baseport.controls = [];

                if (isFunction(Constructor.inject)) {
                    injector = Constructor;
                    key = (<dependency.IInjector<any>>Constructor).name;
                } else {
                    var keys = Object.keys(viewControlInjectors),
                        control: dependency.IInjector<ui.IViewControl>;

                    while (keys.length > 0) {
                        key = keys.pop();
                        control = <any>viewControlInjectors[key];
                        if (control.Constructor === Constructor) {
                            injector = control;
                            break;
                        }
                    }
                }

                if (isNull(injector)) {
                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                    $exception.fatal('Attempting to navigate to unregistered view control.', $exception.NAVIGATION);
                }

                event.target = injector;
                event.type = key;

                if (!isNull(viewControl)) {
                    baseport.navigateFrom(viewControl).then(() => {
                        BaseViewControlFactory.detach(viewControl);

                        if (!options.replace) {
                            this.history.push({ control: viewControl });
                        }

                        baseport.navigateTo(event);
                    }).catch((error) => {
                        postpone(() => {
                            var Exception: IExceptionStatic = acquire(__ExceptionStatic);
                            Exception.fatal(error, Exception.NAVIGATION);
                        });
                    });

                    return;
                }

                // need to postpone so that the viewport can compile before the first navigation
                postpone(() => {
                    baseport.navigateTo(event);
                });
            }
        
            /**
             * @name goBack
             * @memberof plat.navigation.Navigator
             * @kind function
             * @access public
             * 
             * @description
             * Returns to the last visited {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {plat.navigation.IBackNavigationOptions} options? Optional 
             * {@link plat.navigation.IBackNavigationOptions|IBackNavigationOptions} allowing the 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} to customize navigation. Enables 
             * navigating back to a specified point in history as well as specifying a new templateUrl 
             * to use at the next {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @returns {void}
             */
            goBack(options?: IBackNavigationOptions): void {
                options = options || {};
                var currentState = this.currentState || <IBaseNavigationState>{},
                    viewControl = currentState.control,
                    length = isNumber(options.length) ? options.length : 1,
                    Constructor = options.ViewControl,
                    parameter = options.parameter,
                    history = this.history,
                    baseport = this.baseport;

                if (history.length === 0) {
                    var $EventManager = this.$EventManagerStatic;
                    $EventManager.dispatch('shutdown', this, $EventManager.DIRECT);
                }

                if (isNull(viewControl)) {
                    return;
                }

                var event = this._sendEvent('beforeNavigate', viewControl, viewControl.type, parameter, options, true);

                if (event.cancelled) {
                    return;
                }

                var $exception: IExceptionStatic;
                if (!isNull(Constructor)) {
                    var index = this._findInHistory(Constructor);

                    if (index > -1) {
                        length = history.length - index;
                    } else {
                        $exception = acquire(__ExceptionStatic);
                        $exception.warn('Cannot find ViewControl in navigation history.', $exception.NAVIGATION);
                        return;
                    }
                }

                if (!isNumber(length) || length > history.length) {
                    $exception = acquire(__ExceptionStatic);
                    $exception.warn('Not enough views in the navigation history in order to navigate back.',
                        $exception.NAVIGATION);
                    return;
                }

                baseport.navigateFrom(viewControl).then(() => {
                    this.$BaseViewControlFactory.dispose(viewControl);

                    var last = this._goBackLength(length);

                    if (isNull(last)) {
                        return;
                    }

                    viewControl = last.control;

                    this.currentState = last;

                    event.target = viewControl;
                    event.type = viewControl.type;

                    baseport.navigateTo(event);
                }).catch((error) => {
                    postpone(() => {
                        $exception = acquire(__ExceptionStatic);
                        $exception.fatal(error, $exception.NAVIGATION);
                    });
                });
            }
        
            /**
             * @name goBack
             * @memberof plat.navigation.Navigator
             * @kind function
             * @access public
             * 
             * @description
             * Lets the caller know if there are {@link plat.ui.IBaseViewControl|IBaseViewControl} in the history, 
             * meaning the caller is safe to perform a backward navigation.
             * 
             * @returns {boolean} Whether or not a backwards navigation can occur.
             */
            canGoBack(): boolean {
                return this.history.length > 0;
            }
        
            /**
             * @name clearHistory
             * @memberof plat.navigation.Navigator
             * @kind function
             * @access public
             * 
             * @description
             * Clears the navigation history, disposing all the controls.
             * 
             * @returns {void}
             */
            clearHistory(): void {
                var history = this.history,
                    dispose = this.$BaseViewControlFactory.dispose;

                while (history.length > 0) {
                    dispose(history.pop().control);
                }
            }
        
            /**
             * @name _findInHistory
             * @memberof plat.navigation.Navigator
             * @kind function
             * @access protected
             * 
             * @description
             * Finds the given constructor in the history stack. Returns the index in the history where
             * the constructor is found, or -1 if no constructor is found.
             * 
             * @param {new (...args: any[]) => plat.ui.IBaseViewControl} Constructor The 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} constructor to search for in the history stack.
             * 
             * @returns {number} The index in the history where the input Constructor was found.
             */
            _findInHistory(Constructor: new (...args: any[]) => ui.IBaseViewControl): number {
                var history = this.history,
                    index = -1;

                for (var i = (history.length - 1); i >= 0; --i) {
                    if (history[i].control.constructor === Constructor) {
                        index = i;
                        break;
                    }
                }

                return index;
            }
        
            /**
             * @name _goBackLength
             * @memberof plat.navigation.Navigator
             * @kind function
             * @access protected
             * 
             * @description
             * This method takes in a length and navigates back in the history, returning the 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} associated with length + 1 entries 
             * back in the history.  It disposes all the {@link plat.ui.IBaseViewControl|IBaseViewControls} 
             * encapsulated in the length, but does not dispose the current {@link plat.ui.IBaseViewControl|IBaseViewControls}.
             * 
             * @param {number} length The number of entries to go back in the history stack.
             * 
             * @returns {plat.navigation.IBaseNavigationState} The new current navigation state as a 
             * {@link plat.navigation.IBaseNavigationState|IBaseNavigationState}.
             */
            _goBackLength(length?: number): IBaseNavigationState {
                length = isNumber(length) ? length : 1;

                var last: IBaseNavigationState,
                    dispose = this.$BaseViewControlFactory.dispose,
                    history = this.history;

                while (length-- > 0) {
                    if (!isNull(last) && !isNull(last.control)) {
                        dispose(last.control);
                    }

                    last = history.pop();
                }

                return last;
            }
        }

        /**
         * The Type for referencing the '$Navigator' injectable as a dependency.
         */
        export function INavigatorInstance(): INavigatorInstance {
            return new Navigator();
        }

        register.injectable(__NavigatorInstance, INavigatorInstance, null, __INSTANCE);
    
        /**
         * @name INavigatorInstance
         * @memberof plat.navigation
         * @kind interface
         * 
         * @extends {plat.navigation.IBaseNavigator}
         * 
         * @description
         * An object that allows {@link plat.ui.IBaseViewControl|IBaseViewControl} to implement methods 
         * used to navigate within a {@link plat.ui.controls.Viewport|Viewport}.
         */
        export interface INavigatorInstance extends IBaseNavigator {
            /**
             * @name history
             * @memberof plat.navigation.INavigatorInstance
             * @kind property
             * @access public
             * 
             * @type {Array<plat.navigation.IBaseNavigationState>}
             * 
             * @description
             * Contains the navigation history stack for the associated {@link plat.ui.controls.Viewport|Viewport}.
             */
            history: Array<IBaseNavigationState>;
        
            /**
             * @name navigate
             * @memberof plat.navigation.INavigatorInstance
             * @kind function
             * @access public
             * @variation 0
             * 
             * @description
             * Allows an {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent along with the navigation.
             * 
             * @param {new (...args: any[]) => ui.IBaseViewControl} Constructor The Constructor for the new 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. This navigator will find the injector for 
             * the Constructor and create a new instance of the control.
             * @param {plat.navigation.INavigationOptions} options? Optional 
             * {@link plat.navigation.INavigationOptions|INavigationOptions} used for navigation.
             * 
             * @returns {void}
             */
            navigate(Constructor: new (...args: any[]) => ui.IBaseViewControl, options?: INavigationOptions): void;
            /**
             * @name navigate
             * @memberof plat.navigation.INavigatorInstance
             * @kind function
             * @access public
             * @variation 1
             * 
             * @description
             * Allows an {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent along with the navigation.
             * 
             * @param {new (...args: any[]) => plat.ui.IBaseViewControl} injector The {@link plat.dependency.IInjector|IInjector} 
             * for the new {@link plat.ui.IBaseViewControl|IBaseViewControl}. This navigator will create a new instance of the control.
             * @param {plat.navigation.INavigationOptions} options? Optional 
             * {@link plat.navigation.INavigationOptions|INavigationOptions} used for navigation.
             * 
             * @returns {void}
             */
            navigate(injector: dependency.IInjector<ui.IBaseViewControl>, options?: INavigationOptions): void;
        
            /**
             * @name goBack
             * @memberof plat.navigation.INavigatorInstance
             * @kind function
             * @access public
             * 
             * @description
             * Returns to the last visited {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {plat.navigation.IBackNavigationOptions} options? Optional 
             * {@link plat.navigation.IBackNavigationOptions|IBackNavigationOptions} allowing the 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} to customize navigation. Enables 
             * navigating back to a specified point in history as well as specifying a new templateUrl 
             * to use at the next {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @returns {void}
             */
            goBack(options?: IBackNavigationOptions): void;
        
            /**
             * @name goBack
             * @memberof plat.navigation.INavigatorInstance
             * @kind function
             * @access public
             * 
             * @description
             * Lets the caller know if there are {@link plat.ui.IBaseViewControl|IBaseViewControl} in the history, 
             * meaning the caller is safe to perform a backward navigation.
             * 
             * @returns {boolean} Whether or not a backwards navigation can occur.
             */
            canGoBack(): boolean;
        
            /**
             * @name clearHistory
             * @memberof plat.navigation.INavigatorInstance
             * @kind function
             * @access public
             * 
             * @description
             * Clears the navigation history, disposing all the controls.
             * 
             * @returns {void}
             */
            clearHistory(): void;
        }
    
        /**
         * @name INavigationOptions
         * @memberof plat.navigation
         * @kind interface
         * 
         * @extends {plat.navigation.IBaseNavigationOptions}
         * 
         * @description
         * Options that you can submit to an {@link plat.navigation.INavigatorInstance|INavigatorInstance} in order 
         * to customize navigation.
         */
        export interface INavigationOptions extends IBaseNavigationOptions {
            /**
             * @name parameter
             * @memberof plat.navigation.INavigationOptions
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * An optional parameter to send to the next {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             */
            parameter?: any;
        }
    
        /**
         * @name IBackNavigationOptions
         * @memberof plat.navigation
         * @kind interface
         * 
         * @extends {plat.navigation.IBaseBackNavigationOptions}
         * 
         * @description
         * Options that you can submit to an {@link plat.navigation.INavigatorInstance|INavigatorInstance} during a backward 
         * navigation in order to customize the navigation.
         */
        export interface IBackNavigationOptions extends IBaseBackNavigationOptions {
            /**
             * @name parameter
             * @memberof plat.navigation.IBackNavigationOptions
             * @kind property
             * @access public
             * 
             * @type {any}
             * 
             * @description
             * An optional parameter to send to the next {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             */
            parameter?: any;
        
            /**
             * @name ViewControl
             * @memberof plat.navigation.IBackNavigationOptions
             * @kind property
             * @access public
             * 
             * @type {new (...args: any[]) => plat.ui.IBaseViewControl}
             * 
             * @description
             * An {@link plat.ui.IBaseViewControl|IBaseViewControl} Constructor that the 
             * {@link plat.navigation.INavigatorInstance|INavigatorInstance} will use to navigate. 
             * The {@link plat.navigation.INavigatorInstance|INavigatorInstance} will search for an instance 
             * of the {@link plat.ui.IBaseViewControl|IBaseViewControl} in its history and navigate to it.
             */
            ViewControl?: new (...args: any[]) => ui.IBaseViewControl;
        }

        /**
         * @name RoutingNavigator
         * @memberof plat.navigation
         * @kind class
         * 
         * @extends plat.navigation.BaseNavigator
         * @implements {plat.navigation.IRoutingNavigator}
         * 
         * @description
         * A type of navigator class that utilizes routing capabilities. It is directly associated with a 
         * {@link plat.ui.controls.Routeport|Routeport}, thus only allowing one 
         * {@link plat.navigation.RoutingNavigator|RoutingNavigator} per app.
         */
        export class RoutingNavigator extends BaseNavigator implements IRoutingNavigator {
            /**
             * @name $Router
             * @memberof plat.navigation.RoutingNavigator
             * @kind property
             * @access public
             * 
             * @type {Window}
             * 
             * @description
             * Reference to the {@link plat.web.IRouter|IRouter} injectable.
             */
            $Router: web.IRouter = acquire(__Router);
            /**
             * @name $Window
             * @memberof plat.navigation.RoutingNavigator
             * @kind property
             * @access public
             * 
             * @type {Window}
             * 
             * @description
             * Reference to the Window injectable.
             */
            $Window: Window = acquire(__Window);
        
            /**
             * @name currentState
             * @memberof plat.navigation.RoutingNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.navigation.IRouteNavigationState}
             * 
             * @description
             * The routing information for the {@link plat.ui.controls.Routeport|Routeport's} current state.
             */
            currentState: IRouteNavigationState;
        
            /**
             * @name __removeListeners
             * @memberof plat.navigation.RoutingNavigator
             * @kind property
             * @access private
             * 
             * @type {Array<plat.IRemoveListener>}
             * 
             * @description
             * A collection of listeners for removing event based listeners.
             */
            private __removeListeners: Array<IRemoveListener> = [];
            /**
             * @name __historyLength
             * @memberof plat.navigation.RoutingNavigator
             * @kind property
             * @access private
             * 
             * @type {number}
             * 
             * @description
             * The history length. Used to keep track of potential app shutdown.
             */
            private __historyLength = 0;
        
            /**
             * @name initialize
             * @memberof plat.navigation.RoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Initializes this navigator. The {plat.ui.controls.Routeport|Routeport} will call this method and pass 
             * itself in so the navigator can store it and use it to facilitate navigation. Also subscribes to 
             * 'routeChanged' and 'beforeRouteChange' events.
             * 
             * @param {plat.ui.controls.IBaseport} baseport The {plat.ui.controls.Routeport|Routeport} 
             * associated with this {@link plat.navigation.IRoutingNavigator|IRoutingNavigator}.
             * 
             * @returns {void}
             */
            initialize(baseport: ui.controls.IBaseport): void {
                super.initialize(baseport);

                var removeListeners = this.__removeListeners,
                    $EventManager = this.$EventManagerStatic,
                    uid = this.uid;

                removeListeners.push($EventManager.on(uid, 'routeChanged', this._onRouteChanged, this));
                removeListeners.push($EventManager.on(uid, 'beforeRouteChange', this._beforeRouteChange, this));
            }
        
            /**
             * @name navigate
             * @memberof plat.navigation.RoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Allows a {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent to the new {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {string} path The URL path to navigate to.
             * @param {plat.web.IRouteNavigationOptions} options? Optional {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions} 
             * for ignoring the current ui.IBaseViewControl in the history as well as specifying a new templateUrl 
             * for the next {@link plat.ui.IBaseViewControl|IBaseViewControl} to use.
             * 
             * @returns {void}
             */
            navigate(path: string, options?: web.IRouteNavigationOptions): void {
                this.navigating = true;
                if (!this.$Router.route(path, options)) {
                    this.navigating = false;
                }
            }
        
            /**
             * @name navigated
             * @memberof plat.navigation.RoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Called by the {@link plat.ui.controls.Routeport|Routeport} to make the Navigator aware of a successful navigation.
             * 
             * @param {plat.ui.IBaseViewControl} control The {@link plat.ui.IBaseViewControl|IBaseViewControl} to which the 
             * navigation occurred.
             * @param {plat.web.IRoute<any>} parameter The navigation parameter sent to the control.
             * @param {plat.web.IRouteNavigationOptions} options The options used during navigation.
             * 
             * @returns {void}
             */
            navigated(control: ui.IBaseViewControl, parameter: web.IRoute<any>, options: web.IRouteNavigationOptions): void {
                super.navigated(control, parameter, options);
                this.currentState.route = parameter;
            }
        
            /**
             * @name goBack
             * @memberof plat.navigation.RoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Returns to the last visited {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {plat.navigation.IBaseBackNavigationOptions} options? Optional 
             * {@link plat.navigation.IBaseBackNavigationOptions|IBaseBackNavigationOptions} allowing the 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} to customize navigation. Enables navigating 
             * back to a specified point in history as well as specifying a new templateUrl to use at the 
             * next {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @returns {void}
             */
            goBack(options?: IBaseBackNavigationOptions): void {
                options = options || {};

                this.__historyLength -= 2;

                if (this.__historyLength < 0) {
                    this.$EventManagerStatic.dispatch('shutdown', this, this.$EventManagerStatic.DIRECT);
                }

                this.$Router.goBack((isNumber(options.length) ? options.length : 1));
            }
        
            /**
             * @name dispose
             * @memberof plat.navigation.RoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Cleans up memory.
             * 
             * @returns {void}
             */
            dispose(): void {
                var listeners = this.__removeListeners;
                while (listeners.length > 0) {
                    listeners.pop()();
                }
            }
        
            /**
             * @name _beforeRouteChange
             * @memberof plat.navigation.RoutingNavigator
             * @kind function
             * @access protected
             * 
             * @description
             * The method called prior to a route change event.
             * 
             * @param {plat.events.INavigationEvent<plat.web.IRoute<any>>} ev The 
             * {@link plat.events.INavigationEvent|INavigationEvent} containing information regarding 
             * the {@link plat.ui.IBaseViewControl|IBaseViewControl}, the routing information, 
             * and the {@link plat.web.Router|Router}.
             * 
             * @returns {void}
             */
            _beforeRouteChange(ev: events.INavigationEvent<web.IRoute<any>>): void {
                var event = this._sendEvent('beforeNavigate', ev.target, ev.type, ev.parameter, ev.options, true);

                if (event.cancelled) {
                    ev.cancel();
                }
            }
        
            /**
             * @name _onRouteChanged
             * @memberof plat.navigation.RoutingNavigator
             * @kind function
             * @access protected
             * 
             * @description
             * The method called when a route change is successfully performed and 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} navigation can occur.
             * 
             * @param {plat.events.INavigationEvent<plat.web.IRoute<any>>} ev The 
             * {@link plat.navigation.INavigationEvent|INavigationEvent} containing information regarding 
             * the {@link plat.ui.IBaseViewControl|IBaseViewControl}, the routing information, 
             * and the {@link plat.web.Router|Router}.
             * 
             * @returns {void}
             */
            _onRouteChanged(ev: events.INavigationEvent<web.IRoute<any>>): void {
                var state = this.currentState || <IRouteNavigationState>{},
                    viewControl = state.control,
                    injector = ev.target,
                    baseport = this.baseport;

                if (isNull(injector)) {
                    return;
                }

                this.__historyLength++;
                baseport.navigateFrom(viewControl).then(() => {
                    this.$BaseViewControlFactory.dispose(viewControl);
                    baseport.navigateTo(ev);
                }).catch((error) => {
                    postpone(() => {
                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);
                        Exception.fatal(error, Exception.NAVIGATION);
                    });
                });
            }
        }

        /**
         * The Type for referencing the '$RoutingNavigator' injectable as a dependency.
         */
        export function IRoutingNavigator(): IRoutingNavigator {
            return new RoutingNavigator();
        }

        register.injectable(__RoutingNavigator, IRoutingNavigator);

        /**
         * @name IRoutingNavigator
         * @memberof plat.navigation
         * @kind interface
         * 
         * @extends {plat.navigation.IBaseNavigator}
         * 
         * @description
         * Defines the methods that a navigator must implement if it chooses to utilize 
         * routing capabilities.
         */
        export interface IRoutingNavigator extends IBaseNavigator {
            /**
             * @name navigate
             * @memberof plat.navigation.IRoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Allows a {@link plat.ui.IBaseViewControl|IBaseViewControl} to navigate to another 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl}. Also allows for
             * navigation parameters to be sent to the new {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {string} path The URL path to navigate to.
             * @param {plat.web.IRouteNavigationOptions} options? Optional {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions} 
             * for ignoring the current ui.IBaseViewControl in the history as well as specifying a new templateUrl 
             * for the next {@link plat.ui.IBaseViewControl|IBaseViewControl} to use.
             * 
             * @returns {void}
             */
            navigate(path: string, options?: web.IRouteNavigationOptions): void;

            /**
             * @name navigated
             * @memberof plat.navigation.IRoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Called by the {@link plat.ui.controls.Routeport|Routeport} to make the Navigator aware of a successful navigation.
             * 
             * @param {plat.ui.IBaseViewControl} control The {@link plat.ui.IBaseViewControl|IBaseViewControl} to which the 
             * navigation occurred.
             * @param {plat.web.IRoute<any>} parameter The navigation parameter sent to the control.
             * @param {plat.web.IRouteNavigationOptions} options The options used during navigation.
             * 
             * @returns {void}
             */
            navigated(control: ui.IBaseViewControl, parameter: web.IRoute<any>, options: web.IRouteNavigationOptions): void;

            /**
             * @name goBack
             * @memberof plat.navigation.IRoutingNavigator
             * @kind function
             * @access public
             * 
             * @description
             * Returns to the last visited {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @param {plat.navigation.IBaseBackNavigationOptions} options? Optional 
             * {@link plat.navigation.IBaseBackNavigationOptions|IBaseBackNavigationOptions} allowing the 
             * {@link plat.ui.IBaseViewControl|IBaseViewControl} to customize navigation. Enables navigating 
             * back to a specified point in history as well as specifying a new templateUrl to use at the 
             * next {@link plat.ui.IBaseViewControl|IBaseViewControl}.
             * 
             * @returns {void}
             */
            goBack(options?: IBaseBackNavigationOptions): void;
        }

        /**
         * @name IRouteNavigationState
         * @memberof plat.navigation
         * @kind interface
         * 
         * @extends {plat.navigation.IBaseNavigationState}
         * 
         * @description
         * Defines the route type interface implemented for current state and last state.
         */
        export interface IRouteNavigationState extends IBaseNavigationState {
            /**
             * @name route
             * @memberof plat.navigation.RoutingNavigator
             * @kind property
             * @access public
             * 
             * @type {plat.web.IRoute<any>}
             * 
             * @description
             * The associated route information in the form of an 
             * {@link plat.web.IRoute|IRoute}.
             */
            route: web.IRoute<any>;
        }
    }
    /**
     * @name App
     * @memberof plat
     * @kind class
     * 
     * @implements {plat.IApp}
     * 
     * @description
     * Class for every app. This class contains hooks for Application Lifecycle Events 
     * as well as error handling.
     */
    export class App implements IApp {
        /**
         * @name $Compat
         * @memberof plat.App
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.ICompat}
         * 
         * @description
         * Reference to the {@link plat.ICompat|ICompat} injectable.
         */
        static $Compat: ICompat;

        /**
         * @name $EventManagerStatic
         * @memberof plat.App
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.events.IEventManagerStatic}
         * 
         * @description
         * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.
         */
        static $EventManagerStatic: events.IEventManagerStatic;

        /**
         * @name $Document
         * @memberof plat.App
         * @kind property
         * @access public
         * @static
         * 
         * @type {Document}
         * 
         * @description
         * Reference to the Document injectable.
         */
        static $Document: Document;

        /**
         * @name $Compiler
         * @memberof plat.App
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.processing.ICompiler}
         * 
         * @description
         * Reference to the {@link plat.processing.ICompiler|ICompiler} injectable.
         */
        static $Compiler: processing.ICompiler;

        /**
         * @name $LifecycleEventStatic
         * @memberof plat.App
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.events.ILifecycleEventStatic}
         * 
         * @description
         * Reference to the {@link plat.events.ILifecycleEventStatic|ILifecycleEventStatic} injectable.
         */
        static $LifecycleEventStatic: events.ILifecycleEventStatic;

        /**
         * @name start
         * @memberof plat.App
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * A static method for initiating the app startup.
         * 
         * @returns {void}
         */
        static start(): void {
            if (!App.$Compat.isCompatible) {
                var $exception: IExceptionStatic = acquire(__ExceptionStatic);
                $exception.fatal('PlatypusTS only supports modern browsers where ' +
                    'Object.defineProperty is defined', $exception.COMPAT);
                return;
            }

            App.__addPlatCss();

            var $EventManagerStatic = App.$EventManagerStatic;

            $EventManagerStatic.dispose('__app__');
            $EventManagerStatic.on('__app__', 'ready', App.__ready);
            $EventManagerStatic.on('__app__', 'shutdown', App.__shutdown);
            $EventManagerStatic.initialize();
        }

        /**
         * @name registerApp
         * @memberof plat.App
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * A static method called upon app registration. Primarily used 
         * to initiate a ready state in the case that amd is being used.
         * 
         * @param {any} app The app instance.
         * 
         * @returns {void}
         */
        static registerApp(app: any): void {
            if (!isNull(App.app) && isString(App.app.uid)) {
                App.$EventManagerStatic.dispose(App.app.uid);
            }

            App.app = app;

            if (App.$Compat.amd) {
                var $LifecycleEventStatic = App.$LifecycleEventStatic,
                    dispatch = $LifecycleEventStatic.dispatch;

                postpone(() => {
                    dispatch('ready', $LifecycleEventStatic);
                });
            }
        }

        /**
         * @name load
         * @memberof plat.App
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Kicks off compilation of the DOM from the specified node. If no node is specified, 
         * the default start node is document.body.
         * 
         * @param {Node} node The node at which DOM compilation begins.
         * 
         * @returns {void}
         */
        static load(node?: Node): void {
            var $LifecycleEventStatic = App.$LifecycleEventStatic,
                $compiler = App.$Compiler,
                body = App.$Document.body,
                head = App.$Document.head;

            $LifecycleEventStatic.dispatch('beforeLoad', App);

            if (isNull(node)) {
                $compiler.compile(head);
                body.setAttribute(__Hide, '');
                $compiler.compile(body);
                body.removeAttribute(__Hide);
                return;
            }

            if (isFunction((<Element>node).setAttribute)) {
                (<Element>node).setAttribute(__Hide, '');
                $compiler.compile(node);
                (<Element>node).removeAttribute(__Hide);
            } else {
                $compiler.compile(node);
            }
        }

        /**
         * @name app
         * @memberof plat.App
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.IApp}
         * 
         * @description
         * The instance of the registered {@link plat.IApp|IApp}.
         */
        static app: IApp = null;

        /**
         * @name __ready
         * @memberof plat.App
         * @kind function
         * @access private
         * @static
         * 
         * @description
         * A static method called when the application is ready. It calls the app instance's 
         * ready function as well as checks for the presence of a module loader. If one exists, 
         * loading the DOM falls back to the app developer. If it doesn't, the DOM is loaded from 
         * document.body.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} for the app ready.
         * 
         * @returns {void}
         */
        private static __ready(ev: events.ILifecycleEvent): void {
            dependency.Injector.initialize();

            if (!isNull(App.app)) {
                App.__registerAppEvents(ev);
            }

            if (!App.$Compat.amd) {
                App.load();
            }
        }

        /**
         * @name __shutdown
         * @memberof plat.App
         * @kind function
         * @access private
         * @static
         * 
         * @description
         * A static method called when the application wants to programmatically shutdown.
         * 
         * @returns {void}
         */
        private static __shutdown(): void {
            var app = (<any>navigator).app;

            if (!isNull(app) && isFunction(app.exitApp)) {
                app.exitApp();
            }
        }

        /**
         * @name __registerAppEvents
         * @memberof plat.App
         * @kind function
         * @access private
         * @static
         * 
         * @description
         * A static method called to register all the {@link plat.events.ILifecycleEvent|ILifecycleEvents} for an app instance.
         * 
         * @returns {void}
         */
        private static __registerAppEvents(ev: events.ILifecycleEvent): void {
            var app = App.app;

            if (isFunction((<dependency.IInjector<any>>(<any>app)).inject)) {
                App.app = app = (<dependency.IInjector<any>>(<any>app)).inject();
            }

            app.on('suspend', app.suspend);
            app.on('resume', app.resume);
            app.on('online', app.online);
            app.on('offline', app.offline);
            app.on('error', app.error);

            if (isFunction(app.ready)) {
                app.ready(ev);
            }
        }

        /**
         * @name __addPlatCss
         * @memberof plat.App
         * @kind function
         * @access private
         * @static
         * 
         * @description
         * We need to add [plat-hide] as a css property if platypus.css doesn't exist so we can use it to temporarily 
         * hide elements.
         * 
         * @returns {void}
         */
        private static __addPlatCss(): void {
            var $document = App.$Document;
            if (App.$Compat.platCss) {
                return;
            } else if (!isNull($document.styleSheets) && $document.styleSheets.length > 0) {
                (<CSSStyleSheet>$document.styleSheets[0]).insertRule('[plat-hide] { display: none !important; }', 0);
                return;
            }

            var style = <HTMLStyleElement>document.createElement('style');

            style.textContent = '[plat-hide] { display: none !important; }';
            document.head.appendChild(style);
        }

        /**
         * @name uid
         * @memberof plat.App
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {string}
         * 
         * @description
         * A unique id, created during instantiation.
         */
        uid: string;

        /**
         * @name constructor
         * @memberof plat.App
         * @kind function
         * @access public
         * 
         * @description
         * Class for every app. This class contains hooks for Application Lifecycle Management (ALM)
         * as well as error handling and navigation events.
         * 
         * @returns {plat.App}
         */
        constructor() {
            var ContextManager: observable.IContextManagerStatic = acquire(__ContextManagerStatic);
            ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));
        }

        /**
         * @name suspend
         * @memberof plat.App
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app is suspended.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        suspend(ev: events.ILifecycleEvent): void { }

        /**
         * @name resume
         * @memberof plat.App
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app resumes from the suspended state.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        resume(ev: events.ILifecycleEvent): void { }

        /**
         * @name error
         * @memberof plat.App
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when an internal error occures.
         * 
         * @param {plat.events.IErrorEvent<Error>} ev The {@link plat.events.IErrorEvent|IErrorEvent} object.
         * 
         * @returns {void}
         */
        error(ev: events.IErrorEvent<Error>): void { }

        /**
         * @name ready
         * @memberof plat.App
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app is ready.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        ready(ev: events.ILifecycleEvent): void { }

        /**
         * @name online
         * @memberof plat.App
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app regains connectivity and is now in an online state.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        online(ev: events.ILifecycleEvent): void { }

        /**
         * @name offline
         * @memberof plat.App
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app loses connectivity and is now in an offline state.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        offline(ev: events.ILifecycleEvent): void { }

        /**
         * @name dispatchEvent
         * @memberof plat.App
         * @kind function
         * @access public
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to all 
         * listeners based on the {@link plat.events.EventManager.DIRECT|DIRECT} method. Propagation 
         * will always start with the sender, so the sender can both produce and consume the same event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * {@link plat.App.on|app.on()} method.
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent(name: string, ...args: any[]): void {
            App.$EventManagerStatic.dispatch(name, this, App.$EventManagerStatic.DIRECT, args);
        }

        /**
         * @name on
         * @memberof plat.App
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Registers a listener for a beforeNavigate event. The listener will be called when a beforeNavigate 
         * event is propagating over the app. Any number of listeners can exist for a single event name. 
         * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method, 
         * and thereby preventing the navigation.
         * 
         * @param {string} name='beforeNavigate' The name of the event, cooinciding with the beforeNavigate event.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the beforeNavigate event is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener. 
         */
        on(name: 'beforeNavigate', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.App
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Registers a listener for a navigating event. The listener will be called when a navigating 
         * event is propagating over the app. Any number of listeners can exist for a single event name. 
         * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method, 
         * and thereby preventing the navigation.
         * 
         * @param {string} name='navigating' The name of the event, cooinciding with the navigating event.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigating 
         * event is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener. 
         */
        on(name: 'navigating', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.App
         * @kind function
         * @access public
         * @variation 2
         * 
         * @description
         * Registers a listener for a navigated event. The listener will be called when a navigated 
         * event is propagating over the app. Any number of listeners can exist for a single event name. 
         * This event is not cancelable.
         * 
         * @param {string} name='navigated' The name of the event, cooinciding with the navigated event.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigated 
         * event is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener. 
         */
        on(name: 'navigated', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.App
         * @kind function
         * @access public
         * @variation 3
         * 
         * @description
         * Registers a listener for a routeChanged event. The listener will be called when a routeChange event 
         * is propagating over the app. Any number of listeners can exist for a single event name.
         * 
         * @param {string} eventName='routeChange' This specifies that the listener is for a routeChange event.
         * @param {(ev: plat.events.INavigationEvent<plat.web.IRoute<any>>) => void} listener The method called 
         * when the routeChange is fired. The route argument will contain a parsed route.
         * @returns {plat.IRemoveListener} A method for removing the listener.
         */
        on(name: 'routeChanged', listener: (ev: events.INavigationEvent<web.IRoute<any>>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.App
         * @kind function
         * @access public
         * @variation 4
         * 
         * @description
         * Registers a listener for a {@link plat.events.NavigationEvent|NavigationEvent}. The listener will be called 
         * when a NavigationEvent is propagating over the app. Any number of listeners can exist for a single event name.
         * 
         * @param {string} name The name of the event, cooinciding with the {@link plat.events.NavigationEvent|NavigationEvent} name.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the 
         * {@link plat.events.NavigationEvent|NavigationEvent} is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener.
         */
        on(name: string, listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.App
         * @kind function
         * @access public
         * @variation 5
         * 
         * @description
         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when 
         * a DispatchEvent is propagating over the app. Any number of listeners can exist for a single event name.
         * 
         * @param {string} name The name of the event, cooinciding with the DispatchEvent name.
         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when 
         * the DispatchEvent is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener.
         */
        on(name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener {
            return App.$EventManagerStatic.on(this.uid, name, listener, this);
        }

        /**
         * @name load
         * @memberof plat.App
         * @kind function
         * @access public
         * 
         * @description
         * Kicks off compilation of the DOM from the specified node. If no node is specified, 
         * the default start node is document.body. This method should be called from the app when 
         * using module loaders. If a module loader is in use, the app will delay loading until 
         * this method is called.
         * 
         * @param {Node} node The node where at which DOM compilation begins.
         * 
         * @returns {void}
         */
        load(node?: Node): void {
            App.load(node);
        }
    }

    /**
     * The Type for referencing the '$AppStatic' injectable as a dependency.
     */
    export function IAppStatic(
        $Compat?: ICompat,
        $EventManagerStatic?: events.IEventManagerStatic,
        $Document?: Document,
        $Compiler?: processing.ICompiler,
        $LifecycleEventStatic?: events.ILifecycleEventStatic): IAppStatic {
            App.$Compat = $Compat;
            App.$EventManagerStatic = $EventManagerStatic;
            App.$Document = $Document;
            App.$Compiler = $Compiler;
            App.$LifecycleEventStatic = $LifecycleEventStatic;
            return App;
    }

    register.injectable(__AppStatic, IAppStatic, [
        __Compat,
        __EventManagerStatic,
        __Document,
        __Compiler,
        __LifecycleEventStatic
    ], __STATIC);

    /**
     * The Type for referencing the '$App' injectable as a dependency.
     */
    export function IApp($AppStatic?: IAppStatic): IApp {
        return $AppStatic.app;
    }

    register.injectable(__App, IApp, [__AppStatic], __INSTANCE);

    /**
     * @name IAppStatic
     * @memberof plat
     * @kind interface
     * 
     * @description
     * The external interface for the '$AppStatic' injectable.
     */
    export interface IAppStatic {
        /**
         * @name start
         * @memberof plat.IAppStatic
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * A static method for initiating the app startup.
         * 
         * @returns {void}
         */
        start(): void;

        /**
         * @name registerApp
         * @memberof plat.IAppStatic
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * A static methods called upon app registration. Primarily used 
         * to initiate a ready state in the case that amd is being used.
         * 
         * @returns {void}
         */
        registerApp(app: dependency.IInjector<IApp>): void;

        /**
         * @name load
         * @memberof plat.IAppStatic
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * Kicks off compilation of the DOM from the specified node. If no node is specified,
         * the default start node is document.body.
         * 
         * @param node The node at which DOM compilation begins.
         * 
         * @returns {void}
         */
        load(node?: Node): void;

        /**
         * @name app
         * @memberof plat.IAppStatic
         * @kind property
         * @access public
         * @static
         * 
         * @type {plat.IApp}
         * 
         * @description
         * The instance of the registered {@link plat.IApp|IApp}.
         */
        app: IApp;
    }

    /**
     * @name IApp
     * @memberof plat
     * @kind interface
     * 
     * @description
     * An object implementing IApp implements the methods called by the framework to support 
     * Application Lifecycle Management (ALM) as well as error handling and navigation events.
     */
    export interface IApp {
        /**
         * @name uid
         * @memberof plat.IApp
         * @kind property
         * @access public
         * @readonly
         * 
         * @type {string}
         * 
         * @description
         * A unique id, created during instantiation.
         */
        uid: string;

        /**
         * @name suspend
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app is suspended.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        suspend? (ev: events.ILifecycleEvent): void;

        /**
         * @name resume
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app resumes from the suspended state.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        resume? (ev: events.ILifecycleEvent): void;

        /**
         * @name error
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when an internal error occures.
         * 
         * @param {plat.events.IErrorEvent} ev The {@link plat.events.IErrorEvent|IErrorEvent} object.
         * 
         * @returns {void}
         */
        error? (ev: events.IErrorEvent<Error>): void;

        /**
         * @name ready
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app is ready.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        ready? (ev: events.ILifecycleEvent): void;

        /**
         * @name online
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app regains connectivity and is now in an online state.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        online? (ev: events.ILifecycleEvent): void;

        /**
         * @name offline
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @virtual
         * 
         * @description
         * Event fired when the app loses connectivity and is now in an offline state.
         * 
         * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.
         * 
         * @returns {void}
         */
        offline? (ev: events.ILifecycleEvent): void;

        /**
         * @name dispatchEvent
         * @memberof plat.IApp
         * @kind function
         * @access public
         * 
         * @description
         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to all 
         * listeners based on the {@link plat.events.EventManager.DIRECT|DIRECT} method. Propagation 
         * will always start with the sender, so the sender can both produce and consume the same event.
         * 
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * {@link plat.App.on|app.on()} method.
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         * 
         * @returns {void}
         */
        dispatchEvent(name: string, ...args: any[]): void;

        /**
         * @name on
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @variation 0
         * 
         * @description
         * Registers a listener for a beforeNavigate event. The listener will be called when a beforeNavigate 
         * event is propagating over the app. Any number of listeners can exist for a single event name. 
         * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method, 
         * and thereby preventing the navigation.
         * 
         * @param {string} name='beforeNavigate' The name of the event, cooinciding with the beforeNavigate event.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the beforeNavigate event is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener. 
         */
        on(name: 'beforeNavigate', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @variation 1
         * 
         * @description
         * Registers a listener for a navigating event. The listener will be called when a navigating 
         * event is propagating over the app. Any number of listeners can exist for a single event name. 
         * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method, 
         * and thereby preventing the navigation.
         * 
         * @param {string} name='navigating' The name of the event, cooinciding with the navigating event.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigating 
         * event is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener. 
         */
        on(name: 'navigating', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @variation 2
         * 
         * @description
         * Registers a listener for a navigated event. The listener will be called when a navigated 
         * event is propagating over the app. Any number of listeners can exist for a single event name. 
         * This event is not cancelable.
         * 
         * @param {string} name='navigated' The name of the event, cooinciding with the navigated event.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigated 
         * event is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener. 
         */
        on(name: 'navigated', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @variation 3
         * 
         * @description
         * Registers a listener for a routeChanged event. The listener will be called when a routeChange event 
         * is propagating over the app. Any number of listeners can exist for a single event name.
         * 
         * @param {string} eventName='routeChange' This specifies that the listener is for a routeChange event.
         * @param {(ev: plat.events.INavigationEvent<plat.web.IRoute<any>>) => void} listener The method called 
         * when the routeChange is fired. The route argument will contain a parsed route.
         * @returns {plat.IRemoveListener} A method for removing the listener.
         */
        on(name: 'routeChanged', listener: (ev: events.INavigationEvent<web.IRoute<any>>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @variation 4
         * 
         * @description
         * Registers a listener for a {@link plat.events.NavigationEvent|NavigationEvent}. The listener will be called 
         * when a NavigationEvent is propagating over the app. Any number of listeners can exist for a single event name.
         * 
         * @param {string} name The name of the event, cooinciding with the {@link plat.events.NavigationEvent|NavigationEvent} name.
         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the 
         * {@link plat.events.NavigationEvent|NavigationEvent} is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener.
         */
        on(name: string, listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;
        /**
         * @name on
         * @memberof plat.IApp
         * @kind function
         * @access public
         * @variation 5
         * 
         * @description
         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when 
         * a DispatchEvent is propagating over the app. Any number of listeners can exist for a single event name.
         * 
         * @param {string} name The name of the event, cooinciding with the DispatchEvent name.
         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when 
         * the DispatchEvent is fired.
         * 
         * @returns {plat.IRemoveListener} A method for removing the listener.
         */
        on(name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener;

        /**
         * @name load
         * @memberof plat.IApp
         * @kind function
         * @access public
         * 
         * @description
         * Kicks off compilation of the DOM from the specified node. If no node is specified, 
         * the default start node is document.body. This method should be called from the app when 
         * using module loaders. If a module loader is in use, the app will delay loading until 
         * this method is called.
         * 
         * @param {Node} node The node where at which DOM compilation begins.
         * 
         * @returns {void}
         */
        load(node?: Node): void;
    }

    /**
     * @name IObject
     * @memberof plat
     * @kind interface
     * 
     * @description
     * Interface for an object where every key has the same typed value.
     * 
     * @typeparam {any} T The type of each value in the object.
     */
    export interface IObject<T> {
        /**
         * @name [key: string]
         * @memberof plat.IObject
         * @kind property
         * @access public
         * @static
         * 
         * @type {T}
         * 
         * @description
         * Every key must be of type T
         */
        [key: string]: T
    }

    /**
     * @name IRemoveListener
     * @memberof plat
     * @kind interface
     * 
     * @description
     * Defines a function that will halt further callbacks to a listener.
     * Equivalent to `() => void`.
     */
    export interface IRemoveListener {
        /**
         * @memberof plat.IRemoveListener
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * The method signature for {@link plat.IRemoveListener|IRemoveListener}.
         * 
         * @returns {void}
         */
        (): void;
    }

    /**
     * @name IPropertyChangedListener
     * @memberof plat
     * @kind interface
     * 
     * @description
     * Defines a function that will be called whenever a property has changed.
     */
    export interface IPropertyChangedListener {
        /**
         * @memberof plat.IPropertyChangedListener
         * @kind function
         * @access public
         * @static
         * 
         * @description
         * The method signature for {@link plat.IPropertyChangedListener|IPropertyChangedListener}.
         * 
         * @param {any} newValue? The new value of the observed property.
         * @param {any} oldValue? The previous value of the observed property.
         * 
         * @returns {void}
         */
        (newValue?: any, oldValue?: any): void;
    }
}
/* tslint:enable */
